from typing import List, Any, ClassVar, Callable, Union, Tuple
from pydantic import BaseModel
import re
import random

from autoreq.util import sanitize_subprogram_name


# Base classes that Cython can handle
class GenericValueMapping(BaseModel):
    """Base class for value mappings with dynamic identifier typing"""

    model_config = {
        'arbitrary_types_allowed': True,
        'ignored_types': (
            Callable,
            property,
        ),  # Tell Pydantic to ignore methods and properties
    }
    identifier: Any  # Will be specialized at runtime
    value: str

    # Mark methods with ClassVar to tell cython they're not fields
    to_vectorcast: ClassVar[Callable]

    def to_vectorcast(
        self, is_expected=False, no_pointer=False, return_was_pointer=False
    ) -> Union[str, Tuple[str, bool]]:
        patched_identifier = re.sub(r'(\w+)->', r'*\1.', self.identifier)
        patched_identifier = re.sub(r'\*(\w+)\.', r'*\1[0].', patched_identifier)

        prefix = 'TEST.EXPECTED' if is_expected else 'TEST.VALUE'

        pointer_match = re.match(r'<<pointer (.+?)>>', self.value)
        if pointer_match:
            patched_value = pointer_match.group(1)

            if not no_pointer:
                if return_was_pointer:
                    return (
                        f'TEST.VALUE:USER_GLOBALS_VCAST.<<GLOBAL>>.VECTORCAST_STR1:{patched_value}\n{prefix}:{patched_identifier}:VECTORCAST_STR1\n',
                        True,
                    )

                return f'TEST.VALUE:USER_GLOBALS_VCAST.<<GLOBAL>>.VECTORCAST_STR1:{patched_value}\n{prefix}:{patched_identifier}:VECTORCAST_STR1\n'
            else:
                if return_was_pointer:
                    return f'{prefix}:{patched_identifier}:VECTORCAST_STR1\n', False
                return f'{prefix}:{patched_identifier}:VECTORCAST_STR1\n'

        if return_was_pointer:
            return f'{prefix}:{patched_identifier}:{self.value}\n', False
        return f'{prefix}:{patched_identifier}:{self.value}\n'


class GenericTestCase(BaseModel):
    """Base class for test cases with dynamic value mapping types"""

    model_config = {
        'arbitrary_types_allowed': True,
        'ignored_types': (
            Callable,
            property,
        ),  # Tell Pydantic to ignore methods and properties
    }
    test_name: str
    test_description: str
    requirement_id: str
    unit_name: str
    subprogram_name: str
    input_values: List[Any]  # Will be specialized at runtime
    expected_values: List[Any]  # Will be specialized at runtime

    unit_names: ClassVar[property]
    as_partial: ClassVar[property]
    to_vectorcast: ClassVar[Callable]
    _get_needed_stubs: ClassVar[Callable]

    @property
    def unit_names(self):
        return [self.unit_name]

    @property
    def as_partial(self):
        return self.__class__(
            test_name=self.test_name + '-PARTIAL',
            test_description=self.test_description,
            requirement_id=self.requirement_id,
            unit_name=self.unit_name,
            subprogram_name=self.subprogram_name,
            input_values=self.input_values,
            # expected_values=[]
            expected_values=self.expected_values,
        )

    def to_vectorcast(self, use_requirement_key=True, add_uuid=False) -> str:
        test_case_str = f'TEST.UNIT:{self.unit_name}\n'
        test_case_str += f'TEST.SUBPROGRAM:{self.subprogram_name}\n'
        test_case_str += 'TEST.NEW\n'

        name = (
            self.test_name
            if not add_uuid
            else f'{self.test_name}-{random.randint(0, 100000)}'
        )

        # Prevent names with spaces in the name
        name = name.replace(' ', '_')
        test_case_str += f'TEST.NAME:{name}-REVIEW-NEEDED\n'

        if use_requirement_key:
            test_case_str += f'TEST.REQUIREMENT_KEY:{self.requirement_id}\n'

        test_case_str += 'TEST.NOTES:\n'
        test_case_str += 'WARNING: This test case was generated by an AI-based system. Please review it carefully.\n\n'

        if not use_requirement_key:
            test_case_str += f'Tested Requirement ID: {self.requirement_id}\n\n'

        for line in self.test_description.split('\n'):
            test_case_str += f'{line}\n'
        test_case_str += 'TEST.END_NOTES:\n'

        for stub in sorted(list(self._get_needed_stubs())):
            test_case_str += f'TEST.STUB:{stub}\n'

        # Sometimes the LLM duplicates assignments. Deduplicating them is a free win
        seen_inputs = set()
        seen_pointer = False
        for input_value in self.input_values:
            vectorcast_input, was_pointer = input_value.to_vectorcast(
                no_pointer=seen_pointer, return_was_pointer=True
            )
            seen_pointer = was_pointer or seen_pointer

            if vectorcast_input in seen_inputs:
                continue

            test_case_str += vectorcast_input
            seen_inputs.add(vectorcast_input)

        seen_expected = set()
        for expected_value in self.expected_values:
            vectorcast_expected = expected_value.to_vectorcast(is_expected=True)

            if vectorcast_expected in seen_expected:
                continue

            test_case_str += vectorcast_expected
            seen_expected.add(vectorcast_expected)

        test_case_str += 'TEST.END\n'
        return test_case_str

    def _get_needed_stubs(self):
        self_sanitized_name = sanitize_subprogram_name(self.subprogram_name)
        self_sanitized_name = self_sanitized_name.split('::')[-1]

        needed_stubs = set()
        for value in self.input_values + self.expected_values:
            unit_name, subprogram_name = value.identifier.split('.')[:2]

            if unit_name == 'uut_prototype_stubs':
                pass  # Add stubs for these functions too for now (could technically be removed)

            if subprogram_name == '<<GLOBAL>>':
                continue

            sanitized_subprogram_name = sanitize_subprogram_name(subprogram_name)
            sanitized_subprogram_name = sanitized_subprogram_name.split('::')[-1]

            if sanitized_subprogram_name == self_sanitized_name:
                continue

            stub = f'{unit_name}.{subprogram_name}'

            needed_stubs.add(stub)

        return needed_stubs


class GenericTestGenerationResult(BaseModel):
    test_description: str
    test_mapping_analysis: str
    test_case: Any  # type: ignore
    test_cases: ClassVar[property]

    @property
    def test_cases(self):
        return [self.test_case]
