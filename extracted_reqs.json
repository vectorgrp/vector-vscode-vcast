{
    "LLR.LIC.LIC.001": "Each license  shall  be serialized with a unique ID.",
    "LLR.LIC.LIC.002": "Each license  shall  have the following customer data associated with it to help Identify and contact the customer.\n              NameCompanyE-mailPhone number",
    "LLR.LIC.LIC.003": "If a  license specifies a particular machine, then node-locked licensing  shall  only allow use of OpenECU\n              on the specified machine.",
    "LLR.LIC.LIC.004": "If a license specifies a particular user, then node-locked licensing  shall  only allow use of OpenECU by\n              the specified user.",
    "LLR.LIC.LIC.005": "The license file includes a host id and floating licensing  shall  only allow use of OpenECU if the license\n              server runs on a matching machine.",
    "LLR.LIC.LIC.006": "The license file includes a maximum number of concurrent users for each feature and floating licensing\n               shall  limit the use of features to that number.",
    "LLR.LIC.LIC.020": "Licensing  shall  allow a license for a feature to be checked out by a client only after the\n              linger time for the feature has elapsed since the most recent checkout request by any other\n              client.",
    "LLR.LIC.LIC.007": "When checking out, if licensing can choose between floating and node locked licenses for the same feature\n              then licensing  shall  pick node locked licenses in preference to floating licenses.",
    "LLR.LIC.LIC.017": "The license file includes a version per feature and licensing  shall  only allow a feature to be checked out\n              if the feature version is greater than or equal to the platform version.",
    "LLR.LIC.LIC.018": "The license file may optionally include an expiry date for a feature and licensing  shall  only allow a\n              feature with an expiry date to be checked out if the feature expiry date is in the future with respect to\n              the current time from the operating system.",
    "LLR.LIC.LIC.010": "The license  shall  restrict use of OpenECU to physical client machines.",
    "LLR.LIC.LIC.021": "A borrowed license  shall  allow use of a feature without connection to the license server only while within the specified borrow expiration time.",
    "LLR.LIC.MEX.001": "If the OPENECU feature is available and  any OpenECU block is present when a Simulink model is simulated,\n              then the platform  shall  checkout that feature before continuing to simulate.",
    "LLR.LIC.MEX.002": "If the OPENECU feature is not available and  any OpenECU block is present when a Simulink model is\n              simulated, then the platform  shall  raise an error and the simulation shall be halted.",
    "LLR.LIC.MEX.003": "If the SIMULINK_SIMULATE feature is available and  any OpenECU block is present when a Simulink model is\n              simulated, then the platform  shall  checkout that feature before continuing to simulate.",
    "LLR.LIC.MEX.004": "If the SIMULINK_SIMULATE feature is not available and  any OpenECU block is present when a Simulink model\n              is simulated, then the platform  shall  raise an error and the simulation shall be halted.",
    "LLR.LIC.MEX.005": "If the OPENECU feature is available and  any OpenECU block is present when a Simulink model is built, then\n              the platform  shall  checkout that feature before continuing to build.",
    "LLR.LIC.MEX.006": "If the OPENECU feature is not available and  any OpenECU block is present when a Simulink model is built,\n              then the platform  shall  raise an error and the build shall be halted.",
    "LLR.LIC.MEX.007": "If the SIMULINK_BUILD feature is available and  any OpenECU block is present when a Simulink model is\n              built, then the platform  shall  checkout that feature before continuing to build.",
    "LLR.LIC.MEX.008": "If the SIMULINK_BUILD feature is not available and  any OpenECU block is present when a Simulink model is\n              built, then the platform  shall  raise an error and the build shall be halted.",
    "LLR.LIC.MEX.013": "If the EXT_DIAG feature is available and  any OpenECU block requiring the EXT_DIAG feature is present when\n              a Simulink model is simulated, then the platform  shall  checkout that feature before continuing to simulate.",
    "LLR.LIC.MEX.014": "If the EXT_DIAG feature is not available and  any OpenECU block requiring the EXT_DIAG feature is present\n              when a Simulink model is simulated, then the platform  shall  raise an error and the simulation shall be\n              halted.",
    "LLR.LIC.MEX.015": "If the EXT_DIAG feature is available and  any OpenECU block requiring the EXT_DIAG feature is present when\n              a Simulink model is built, then the platform  shall  checkout that feature before continuing to build.",
    "LLR.LIC.MEX.016": "If the EXT_DIAG feature is not available and  any OpenECU block requiring the EXT_DIAG feature is present\n              when a Simulink model is built, then the platform  shall  raise an error and the build shall be halted.",
    "LLR.LIC.GEN.001": "The tool  shall  provide a GUI to the user.",
    "LLR.LIC.GEN.002": "The tool  shall  provide a method of entering the customer name.",
    "LLR.LIC.GEN.003": "The tool  shall  provide a method of entering the customer company.",
    "LLR.LIC.GEN.004": "The tool  shall  provide a method of entering the license serial number.",
    "LLR.LIC.GEN.005": "The tool  shall  provide a method of entering the license issue date.",
    "LLR.LIC.GEN.006": "The tool  shall  provide a method of indicating whether a server will be used.",
    "LLR.LIC.GEN.007": "If a server is used, the tool  shall  provide a method of specifying the server host name.",
    "LLR.LIC.GEN.008": "If a server is used, the tool  shall  provide a means of specifying the server hostid.",
    "LLR.LIC.GEN.009": "The tool  shall  provide a method of entering the maximum allowed version number for a license.",
    "LLR.LIC.GEN.010": "The tool  shall  provide a method of entering the expiration date for a license.",
    "LLR.LIC.GEN.011": "The tool  shall  provide a method of entering the hostid by user for a license.",
    "LLR.LIC.GEN.012": "The tool  shall  provide a method of entering the hostid by machine for a license.",
    "LLR.LIC.GEN.013": "For a floating license, the tool  shall  provide a method of entering the count for a license.",
    "LLR.LIC.GEN.014": "The tool  shall  enable the OPENECU feature.",
    "LLR.LIC.GEN.015": "The tool  shall  provide a method of enabling the CAPI_BUILD feature.",
    "LLR.LIC.GEN.016": "The tool  shall  provide a method of enabling the SIMULINK_BUILD feature.",
    "LLR.LIC.GEN.017": "The tool  shall  provide a method of enabling the SIMULINK_SIMULATE feature.",
    "LLR.LIC.GEN.018": "The tool  shall  provide a method of enabling the EXT_DIAG feature.",
    "LLR.LIC.GEN.020": "For any given enabled feature the tool  shall  provide a method of entering the maximum version number for\n              that feature.",
    "LLR.LIC.GEN.021": "If a feature's maximum version number is not specified, then the feature's maximum version number  shall  be\n              that of the license.",
    "LLR.LIC.GEN.022": "For any given enabled feature the tool  shall  provide a method of entering the expiration date for\n              that feature.",
    "LLR.LIC.GEN.023": "If a feature's expiration date is not specified, then the feature's expiration date  shall  be\n              that of the license.",
    "LLR.LIC.GEN.024": "For any given enabled feature the tool  shall  provide a method of entering the hostid by user for\n              that feature.",
    "LLR.LIC.GEN.025": "For any given enabled feature the tool  shall  provide a method of entering the hostid by machine for\n              that feature.",
    "LLR.LIC.GEN.026": "If a feature's hostid is not specified, then the feature's hostid  shall  be\n              that of the license.",
    "LLR.LIC.GEN.027": "For a floating license, for any given enabled feature the tool  shall  provide a method of entering the\n              count for that feature.",
    "LLR.LIC.GEN.028": "For a floating license, if a feature's count is not specified, then the feature's count  shall  be\n              that of the license.",
    "LLR.LIC.GEN.029": "For each enabled feature the tool  shall  specify the use on physical machines only.",
    "LLR.LIC.GEN.030": "The license generation tool  shall  output a license file conforming to the Flexera license file format.",
    "LLR.LIC.GEN.031": "The license generation tool  shall  use the Flexera SDK to populate the signature fields of the license files with valid signatures.\n            Rationale: \n              The second part of the license generation after actually making the file, is to populate the\n              tamper-resistant signatures.  This handled by the Flexera SDK, so the tool just has to make sure to kick\n              it off by calling the executable or running a DLL.",
    "LLR.PLAT.ENV.WIN.002": "All tests  shall  be executed on all Windows platforms\n              mentioned in the HLR.",
    "LLR.PLAT.ENV.INST.005": "The build process  shall  generate installers for each\n              platform deliverable.\n            Rationale: \n              Installers are simple for users to use and allow easy\n              installation, uninstallation while making if less likely\n              the two installed version get intermingled.",
    "LLR.PLAT.ENV.INST.001": "The C-API installer, when executed,  shall  install\n              required files.",
    "LLR.PLAT.ENV.INST.002": "The Sim-API installer, when executed,  shall  install required\n              files and update the MATLAB Start-up menu.\n            Rationale: \n              It is the conventional way to provide vendor specific\n              blocksets.",
    "LLR.PLAT.ENV.INST.006": "If the optional INCA support has been selected, the Sim-API\n              installer, when executed,  shall  also install the PROF\n              files in the INCA directory.\n            \n          \n            todo",
    "LLR.PLAT.ENV.INST.003": "The installer  shall  add in the Windows Start \/ All\n              Programs a group called \"OpenECU Developer Software\" and\n              within that group, another group called after the version\n              number.",
    "LLR.PLAT.ENV.INST.004": "The installer  shall  add at a minimum in the Windows Start\n              \/ All Programs \/ OpenECU Developer Software items to\n              access User Guide, Technical Specification, Examples and\n              Uninstall.",
    "LLR.PLAT.ENV.INST.007": "The installer  shall  add at a minimum in the MATLAB Start\n              menu the blockset, examples and documentation.",
    "LLR.PLAT.ENV.UNINST.001": "When the platform is uninstalled, uninstaller  shall  undo\n              everything done in the installation process (see\n              llr[LLR.PLAT.ENV.INST.*]).",
    "LLR.PLAT.COMP.CAPI.001": "The C-API developer platform  shall  support compilers\n              defined in the HLR.",
    "LLR.PLAT.COMP.CAPI.002": "Compiler and linker options  shall  be documented in the user guide, with an explanation\n              for each.\n            Rationale: \n              This allows users of the software to compile and link their applications using the same\n              options used to create the supplied software. If the user finds a compiler or linker\n              bug, the user will have enough information to determine if changing an option to work\n              around the bug will have an impact on the final application when linked with the\n              supplied software.",
    "LLR.PLAT.COMP.CAPI.003": "As a convienence, the software  shall  include files containing the compiler and linker\n              options documented in the user guide.\n            Rationale: \n              This allows users of the software to quickly use the same set of options used to create\n              the supplied software. As Pi change the option lists for new releases, if the user's\n              application points to the same options files, the new options will be used without the\n              user needing to update their build system.",
    "LLR.PLAT.TOOL.CAL.001": "The OpenECU platform  shall  support the following versions\n              of ATI Vision for reprogramming and calibration: 1.9.1 and\n              2.5.",
    "LLR.PLAT.TOOL.CAL.002": "The OpenECU platform  shall  support the following\n              versions of ETAS INCA for reprogramming and calibration: 5.1.2",
    "LLR.PLAT.TOOL.CAL.003": "The OpenECU platform  shall  support the following\n              versions of Vector CANAPE: v8.0",
    "LLR.PLAT.TOOL.CAL.006": "The OpenECU platform  shall  support the XETK-V2.0 memory emulator for\n              calibration, measurement, and reprogramming.",
    "LLR.PLAT.DBG.MICTOR.001": "The platform software  shall  initialise all processor pads in\n              a configuration suitable for connecting the debugger.\n            Rationale: \n              The Mictor connector is commonly used for iSystem or\n              WindRiver debug tools. It has all the required signals to\n              allow us to attach a debug tool with trace or an emulator\n              tool. See also llr[LLR.PLAT.DBG.ISYS.001] for information\n              about debug tools. See also llr[LLR.PLAT.TOOL.CAL.004],\n              llr[LLR.PLAT.TOOL.CAL.005] and llr[LLR.PLAT.TOOL.CAL.006]\n              for information about emulator tools.",
    "LLR.PLAT.DBG.ISYS.001": "The documented build mechanism for the C interface (ref.\n              [HLR.PLAT.CAPIBLD.001])  shall  result in a file, or files,\n              usable with the iSYSTEM IC3000 or IC5000 debuggers\n            Rationale: \n              Debuggers are used during implementation of the software and\n              have to be supported early in the development cycle.",
    "LLR.LIC.SIGN.001": "If less than 3 positional arguments are passed, then the tool  shall  raise an error.",
    "LLR.LIC.SIGN.002": "If at least 3 positional arguments are passed, the tool  shall  read the first three arguments as the\n              platform version and compare them to the actual platform version, raising an error if they do not match.",
    "LLR.LIC.SIGN.003": "When the option \"-c\" is passed, and the features OPENECU, and CAPI_BUILD are available, the tool  shall \n              check out the features OPENECU and CAPI_BUILD, and return 0 to the command line.",
    "LLR.LIC.SIGN.004": "When the option \"-c\" is passed, and one of the features OPENECU, or CAPI_BUILD are not available, the tool\n               shall  display an appropriate error message on standard out, and return a non-zero code to the command line.",
    "LLR.LIC.SIGN.005": "If the \"-c\" option is not passed and less than 5 positional arguments are passed, then the tool  shall \n              display an error message and return a non-zero code to the command line.",
    "LLR.LIC.SIGN.006": "If the tool cannot open the filenames passed in either the fourth or fifth parameter, the tool  shall \n              display an error message and return a non-zero code to the command line.",
    "LLR.LIC.SIGN.013": "If the option \"-g\" is passed, then the tool  shall  interpret the 5th positional argument as a GCC\n              mapfile.",
    "LLR.LIC.SIGN.014": "If the option \"-g\" is not passed, then the tool  shall  interpret the 5th positional argument as a Diab\n              mapfile.",
    "LLR.LIC.SIGN.007": "If either the OPENECU or the CAPI_BUILD features are unavailable, the tools  shall  display an error\n              message and return a non-zero code to the command line.",
    "LLR.LIC.SIGN.008": "If the features OPENECU, and CAPI_BUILD are available, the tool  shall  check out the features OPENECU and\n              CAPI_BUILD.",
    "LLR.LIC.SIGN.012": "The tool  shall  update the binary image with a valid signature in\n              the location specified by the symbol PSCL_LIC_SIGNATURE.",
    "LLR.LIC.SIGN.009": "The signer tool  shall  attempt to check out the EXT_DIAG feature and if successful then populate the first\n              value in the feature array  with 0x5A.",
    "LLR.LIC.SIGN.010": "If the feature EXT_DIAG is not available, then the tool  shall  and populate the first value in the feature\n              array  with an value not equal to 0x5A.",
    "LLR.LIC.SIGN.011": "Tool  shall  check in all checked out Flexera features upon exiting.",
    "LLR.PLAT.APP.ENTRY.001": "For MPC5534 and MPC5565 based ECUs, application mode  shall  declare in its header a\n              watchdog period of no more than 838.8 milliseconds, a processor clock frequency of 80\n              MHz and memory area to check to be the application's code and data, but not\n              calibration data (see\n              [LLR.PLAT.PBT.INVOKE.002]).",
    "LLR.PLAT.APP.ENTRY.003": "For MPC5674F based ECUs, application mode  shall  declare in its header a watchdog\n              period of no more than 1.016 seconds, a processor clock frequency of 264 MHz and\n              memory area to check to be the application's code and data, but not calibration data\n              (see [LLR.PLAT.PBT.INVOKE.002]).",
    "LLR.PLAT.APP.ENTRY.002": "With the application's checksum header, if the header data or the memory regions to\n              checksum described by the header fails its checksum test then the platform  shall \n              attempt to enter reprogramming mode.",
    "LLR.PLAT.APP.FCODE.001": "When application mode is invoked and the last reset was due to the watchdog,\n              application mode  shall  log the flash code '122'.",
    "LLR.PLAT.PAN.CRKCFG.008": "The following parameters  shall  be initialised for the specified crank wheel:\n            \n              ptpul_crank_in_use  shall  be set to TRUE.\n            \n              ptpul_crank_device  shall  be set to the requested device type.\n            \n              ptpul_crank_pchan  shall  be set to the required channel.\n            \n              ptpul_crank_sync  shall  be set to the required sync scheme.\n            \n              ptpul_crank_teeth  shall  be set to the number of teeth on the wheel.\n            \n              ptpul_crank_missing  shall  be set to the number of missing teeth on the wheel.\n            \n              ptpul_crank_gen_angle_clk  shall  be set to enabled or disabled as required.\n            \n              ptpul_tcr2_ticks_per_tooth  shall  be set to the calculated number of ticks per tooth.\n            \n              ptpul_tcr2_ticks_per_engine_cycle  shall  be set to tcr2_ticks_per_tooth multiplied by ptpuf_physical_teeth multiplied by 2;",
    "LLR.PLAT.PAN.CRKCFG.001": "The platform shall provide a C interface function named\n                pan_config_crank_wheel_mtg() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_lchan\n          in\n        PDX_LCHAN_T\nThe channel number of the digital input channel to be used for the crank input. \n Use the macros included by the pio.h file, of the form PIO_DIN[NAME].panf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe wheel to configure for the crank input channel. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_wheel_sync_scheme\n          in\n        PIO_CRANK_WHEEL_SYNC_T\nThe synchronisation scheme to use when syncing to the crank wheel. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL_SYNC[NAME]. \npanf_physical_teeth\n          in\n        U16\nThe number of actual teeth and missing teeth on the crank wheel. \n Range: [PIO_CRANK_TEETH_MIN, PIO_CRANK_TEETH_MAX] teethpanf_missing_teeth\n          in\n        U16\nThe number of missing teeth on the crank wheel. \n Range: [PIO_CRANK_MISSING_MIN, PIO_CRANK_MISSING_MAX] teethpanf_generate_angle_clk\n          in\n        BOOL\nSpecifies whether or not the configured crank wheel generates an angular clock.TRUE if a crank wheel generates an angular clock;FALSE otherwise.\npanf_tooth_edge\n          in\n        PIO_CRANK_TOOTH_EDGE_T\nSpecifies which edge to detect for transitions on the crank wheel. \n For VRS inputs, the differential signal will be processed in hardware first, and then the edge will be detected on this post processed digital signal. \n For hall effect, the digital signal is detected directly on the input pin. \n Use the enum included by the pio.h file, of the form PIO_CRANK_TOOTH_EDGE[NAME]. \nDEFAULT uses the default edge for the ECURISING sets the edge to rising edge detectionFALLING sets the edge to falling edge detection\n\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_IO_CHAN - channel not supportedPAN_RC_BAD_ARGS - configuration errorPAN_RC_SW_ERROR - internal software error",
    "LLR.PLAT.PAN.CRKCFG.031": "The function pan_config_crank_wheel_mtg() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKCFG.032": "The function pan_config_crank_wheel_mtg() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKCFG.003": "If the channel panf_lchan is not suitable for\n                decoding a crank signal then the function  shall  return\n                PAN_RC_BAD_IO_CHAN.",
    "LLR.PLAT.PAN.CRKCFG.004": "The function  shall  check the panf_wheel is valid in [0..PIO_CRANK_WHEEL_LAST] and return\n                PAN_RC_BAD_ARGS otherwise.\n              Rationale: \n                Some ECUs can accommodate more than one crank input channel. The\n                restriction is the underlying ECU hardware to supporting multiple\n                support customers (generally racing customers), so the interface is\n                capable of handling more than one crank input. The restriction is the underlying ECU hardware is)",
    "LLR.PLAT.PAN.CRKCFG.005": "The function  shall  check the ptpuf_wheel_sync_scheme\n                is valid in [0..PIO_CRANK_WHEEL_SYNC_LAST] and return PAN_RC_BAD_ARGS otherwise.\n              Rationale: \n                This allows for a number of different crank synchornisation schemes to be supported.",
    "LLR.PLAT.PAN.CRKCFG.006": "The function  shall  check the ptpuf_physical_teeth\n                is within the range [PIO_CRANK_TEETH_MIN..PIO_CRANK_TEETH_MAX] and return PAN_RC_BAD_ARGS\n                otherwise.\n              Rationale: \n                Some ECUs can cope with different ranges of teeth, checking the range of the input based on ECU specific macros provides\n                for compatibility across the ECU range.",
    "LLR.PLAT.PAN.CRKCFG.007": "The function  shall  check ptpuf_missing_teeth is within the range [PIO_CRANK_MISSING_MIN.\n                .PIO_CRANK_MISSING_MAX] and return PAN_RC_BAD_ARGS otherwise.\n              Rationale: \n                Some ECUs can cope with different ranges of teeth, checking the range of the input based on ECU specific macros provides\n                for compatibility across the ECU range.",
    "LLR.PLAT.PAN.CRKCFG.010": "The function  shall  use the parameter panf_wheel to set the crank wheel to configure.",
    "LLR.PLAT.PAN.CRKCFG.011": "The function  shall  use the parameter panf_lchan to set the channel used for the crank signal input.",
    "LLR.PLAT.PAN.CRKCFG.012": "The function  shall  use the parameter ptpuf_wheel_sync_scheme to set the wheel synchronisation method.",
    "LLR.PLAT.PAN.CRKCFG.013": "The function  shall  use the parameter ptpuf_physical_teeth to set the number of teeth on the wheel.",
    "LLR.PLAT.PAN.CRKCFG.014": "The function  shall  use the parameter ptpuf_missing_teeth to set the number of missing teeth on the wheel.",
    "LLR.PLAT.PAN.CRKCFG.015": "If the parameter panf_generate_angle_clk is enabled the function  shall  use the crankshaft wheel input\n                to generate an angular clock.",
    "LLR.PLAT.PAN.CRKCFG.016": "The platform shall provide a Simulink interface block named\n                pan_CrankWheelConfig that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionWheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          to configure. The selection of wheel is dependent on the target ECU hardware selected in\n          the put_Identification block.\n        \n      \n                Calibratable: no.\n              ChannelParamList\n        \n          Specifies the input channel for the\n          crankshaft sensor input selected for this Wheel. The selection of channel is dependent\n          on the target ECU hardware selected in the put_Identification\n          block.\n        \n      \n                Calibratable: no.\n              Wheel typeParamList\n        \n          Specifies the expected pattern\n          of teeth on the crankshaft encoding Wheel. The selection of wheel type is dependent\n          on the target ECU hardware selected in the put_Identification\n          block.\n        \n        Missing tooth grouped\n                  A crankshaft wheel encoder with a series of equally spaced teeth followed by a gap\n                  equal in width to 1 or more teeth (the gap is often referred to as \u201cmissing teeth\u201d).\n                \n                  Supported by: M220, M221, M250 and M670.\n                \n      \n                Calibratable: no.\n              Wheel synchronisationParamList\n        \n          Specifies the algorithm\n          to use when decoding the crankshaft wheel encoding signal to gain synchronisation.\n          The selection of wheel synchronisation is dependent on the target ECU hardware selected\n          in the put_Identification block.\n        \n        Tooth-missing-tooth\n                  The algorithm searches for at least one tooth followed by a gap of teeth\n                  followed by a single tooth, before declaring synchronisation. This method\n                  results in quicker synchronisation than the Tooth-missing Tooth-missing\n                  method.\n                \n                  Supported by: M220, M221, M250 and M670.\n                \n      \n                Calibratable: no.\n              Physical teeth plus missing teethParamInteger\n        \n          Specifies\n          the number of actual teeth and missing teeth on the crankshaft wheel encoder.\n        \n        \n          Range: [12, 60] teeth\n        \n      \n                Calibratable: no.\n              Missing teethParamInteger\n        \n          Specifies the number of\n          consecutive missing teeth on the crankshaft wheel encoder.\n        \n        \n          Range: [1, 3] teeth\n        \n      \n                Calibratable: no.\n              Generate angle clockParamBoolean\n        \n          Specifies whether or not the decoded\n          crankshaft wheel input is used to generate an angular clock.\n          The ECU uses this angular clock to keep track of the engine position\n          and to schedule events on an angular basis.\n        \n      \n                Calibratable: no.\n              Tooth edge polarityParamList\n        \n          Specifies the polarity of the input signal to be used\n          as the tooth indication when decoding the crankshaft wheel.\n          Note that this polarity refers to the internal polarity on\n          the microprocessor, and therefore its meaning with respect\n          to the polarity on the external pin varies between target\n          ECUs, as detailed below.\n        \n        Default\n                  With this choice, for a Hall-effect input, a falling edge is the tooth indication.\n                  For a VRS-style input, the tooth indication always corresponds to the zero crossing\n                  point where the positive signal falls below the negative signal. Note that for a\n                  VRS-style input, the default selection should always be preferred, since the other\n                  edge of the processed signal will correspond to the arming point, when the voltage\n                  rises above a threshold that depends on the previous peak values. Since a variable\n                  reluctance sensor typically has two output signals, one can always ensure that the\n                  the positive-to-negative zero crossing point matches the desired tooth indication\n                  by swapping the connections if necessary.\n                \n                  Supported by: M220, M221, M250 and M670.\n                Falling\n                  The interpretation of this field depends on the target ECU hardware selected\n                  in the put_Identification block.\n                  For the M220 and M670 targets, \u201cFalling\u201d is the inverse of\n                  \u201cDefault\u201d. For all other targets, \u201cFalling\u201d is the\n                  same as \u201cDefault\u201d.\n                \n                  Supported by: M220, M221, M250 and M670.\n                Rising\n                  The interpretation of this field depends on the target ECU hardware selected\n                  in the put_Identification block.\n                  For the M220 and M670 targets, \u201cRising\u201d is the same as \u201cDefault\u201d.\n                  For all other targets, \u201cRising\u201d is the inverse of \u201cDefault\u201d.\n                \n                  Supported by: M220, M221, M250 and M670.\n                \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKCFG.116": "The block pan_CrankWheelConfig shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKCFG.216": "The block pan_CrankWheelConfig shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.CRKCFG.017": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKCFG.018": "If more than one pan_CrankWheelConfig block with the same Wheel\n                 is detected then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKCFG.019": "If a pan_EngineConfig block is detected and Generate angle clock is\n                 disabled then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKCFG.020": "If the parameter Physical teeth plus missing teeth is out of range\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKCFG.021": "If the parameter Missing teeth is out of range\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKCFG.022": "None.",
    "LLR.PLAT.PAN.CRKCFG.023": "The block  shall  run once at initialisation on the target.",
    "LLR.PLAT.PAN.CRKCFG.024": "The block  shall  use the mask parameter Wheel to set the crank wheel to configure.",
    "LLR.PLAT.PAN.CRKCFG.025": "The block  shall  use the mask parameter Channel to set the channel used for the crank signal input.",
    "LLR.PLAT.PAN.CRKCFG.026": "The block  shall  use the mask parameter Wheel type to set the type of synchronisation used for the crank signal.",
    "LLR.PLAT.PAN.CRKCFG.027": "The block  shall  use the mask parameter Wheel synchronisation to set the wheel synchronisation method.",
    "LLR.PLAT.PAN.CRKCFG.028": "The block  shall  use the mask parameter Physical teeth plus missing teeth to set the number of teeth on the wheel.",
    "LLR.PLAT.PAN.CRKCFG.029": "The block  shall  use the mask parameter Missing teeth to set the number of missing teeth on the wheel.",
    "LLR.PLAT.PAN.CRKCFG.030": "If the mask parameter Generate angle clock is enabled the block  shall  use the crankshaft wheel input\n                to generate an angular clock.",
    "LLR.PLAT.PAN.CRKMOV.001": "Motion of the crank wheel  shall  be indicated upon detection of the first tooth\n              after a configured number of blanking teeth on the crank wheel.",
    "LLR.PLAT.PAN.CRKMOV.002": "The indication of motion of the crank wheel  shall  persist until a\n              stall of the crank wheel is detected. Where a stall is defined as a\n              timeout due to lack of detected teeth.",
    "LLR.PLAT.PAN.CRKMOV.003": "The platform shall provide a C interface function named\n                pan_get_crank_wheel_movement() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_crank_movement\n          out\n        BOOL *\nPointer to the boolean result of whether the crank is moving. \n Cannot be NULL\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configured",
    "LLR.PLAT.PAN.CRKMOV.103": "The function pan_get_crank_wheel_movement() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKMOV.203": "The function pan_get_crank_wheel_movement() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKMOV.005": "The function  shall  check that the pointer to the flag panf_crank_movement is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKMOV.006": "The function  shall  check the panf_wheel\n                is valid in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKMOV.007": "If the interface parameter checks pass then the function  shall \n                write the acquired boolean value indicating movement\n                (0 indicates no movement, 1 indicates movement) of the selected\n                crank wheel panf_wheel through\n                panf_crank_movement,\n                otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKMOV.008": "The platform shall provide a Simulink interface block named\n                pan_CrankWheelMovement that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_movementInportBoolean\n        \n          Only used under\n          simulation. Under simulation, the value of this inport is passed through to\n          outport movement.\n        \n        \n          Range: 0 or 1\n        \n      movementOutportBoolean\n        \n          Set to 0 if the crankshaft wheel\n          input appears to have stopped (i.e., is below the frequency measurement threshold),\n          and set to 1 if the crankshaft wheel input appears to be moving.\n        \n        \n          Range: 0 or 1\n        \n      WheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          to measure for movement. The selection of wheel must match a pan_CrankWheelConfig\n          block elsewhere in the model.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to\n          enable inport sim_movement.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKMOV.108": "The block pan_CrankWheelMovement shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKMOV.208": "The block pan_CrankWheelMovement shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.CRKMOV.009": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKMOV.010": "If a pan_CrankWheelConfig block is not found in the model with the same Wheel\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKMOV.011": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKMOV.012": "The value of inport sim_movement  shall  be written to outport\n                movement.",
    "LLR.PLAT.PAN.CRKMOV.013": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAN.CRKMOV.014": "The block  shall  use the mask parameter Wheel to set the crank wheel to check for movement.",
    "LLR.PLAT.PAN.CRKMOV.015": "The block  shall  set the outport movement to 1 if movement of the crankwheel is detected.",
    "LLR.PLAT.PAN.CRKTSPD.022": "The crank speed in rpm  shall  be deduced using a timer to measure the duration of a revolution of the crank wheel.\n              A single reference point on the wheel shall be used to start\/end the measurement. The single reference point on the\n              crank wheel used to measure the crank period shall be the first tooth after the gap.",
    "LLR.PLAT.PAN.CRKTSPD.028": "The tooth speed  shall  be derived from the last inter-tooth duration.\n              For a crank wheel with a missing-tooth-grouped pattern, the\n              duration of the missing tooth should be split based on the number\n              of missing teeth.",
    "LLR.PLAT.PAN.CRKTSPD.029": "If the ECU has not synchronised with the selected crank wheel\n              then the platform  shall  set the rotational speed to 0 rpm.",
    "LLR.PLAT.PAN.CRKTSPD.005": "The platform  shall  set crank-tooth based speed to 0 rpm if the less than two teeth have been detected.",
    "LLR.PLAT.PAN.CRKTSPD.006": "The crank speed per tooth in rpm  shall  be deduced using a timer to measure the duration of the crank tooth.\n              The tooth period shall be calculate upon detecting a falling edge on the crank input.\n              Upon detecting the first tooth after the gap, the tooth period shall be calculated as the average tooth period\n              using a known value for the number of missing teeth.",
    "LLR.PLAT.PAN.CRKTSPD.001": "The platform shall provide a C interface function named\n                pan_get_crank_speed_per_rev() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_crank_speed\n          out\n        F32 *\nPointer to where the current crank speed will be written. \n Cannot be NULL \n Range: [0, 10000] RPM\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configuredPAN_RC_CRANK_NOT_SYNCED - sync has not been gained with the crank wheel",
    "LLR.PLAT.PAN.CRKTSPD.101": "The function pan_get_crank_speed_per_rev() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKTSPD.201": "The function pan_get_crank_speed_per_rev() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKTSPD.002": "The function  shall  check the panf_wheel\n                is within in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.003": "The function  shall  check that the pointer to the crank speed panf_crank_speed is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.004": "The function  shall  check the selected toothed wheel panf_wheel has been configured at initialisation and return\n                PAN_RC_CRANK_NOT_CONFIGURED otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.007": "If the interface parameter checks pass then the function  shall \n                write the rotational speed of the selected crank wheel\n                panf_wheel to panf_crank_speed,\n                otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKTSPD.008": "The platform shall provide a C interface function named\n                pan_get_crank_speed_per_tooth() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_crank_speed\n          out\n        F32 *\nPointer to where the current crank speed will be written. \n Cannot be NULL \n Range: [0, 10000] RPM\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configured",
    "LLR.PLAT.PAN.CRKTSPD.108": "The function pan_get_crank_speed_per_tooth() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKTSPD.208": "The function pan_get_crank_speed_per_tooth() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKTSPD.009": "The function  shall  check the panf_wheel\n                is within in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.010": "The function  shall  check that the pointer to the crank speed panf_crank_speed is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.011": "The function  shall  check the selected toothed wheel panf_wheel has been configured at initialisation and return\n                PAN_RC_CRANK_NOT_CONFIGURED otherwise.",
    "LLR.PLAT.PAN.CRKTSPD.012": "If the interface parameter checks pass then the function  shall \n                write the tooth base rotational speed of the selected crank wheel,\n                panf_wheel to panf_crank_speed,\n                otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKTSPD.013": "The platform shall provide a Simulink interface block named\n                pan_CrankWheelSpeed that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_speedInportInteger\n        \n          Only used under\n          simulation. Under simulation, the value of this inport passed through to\n          outport speed.\n        \n        \n          Range: [0, 10000] rpm\n        \n      speedOutportInteger\n        \n          The measured speed of the\n          crankshaft wheel encoder selected by parameter Wheel.\n        \n        \n          Range: [0, 10000] rpm\n        \n      WheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          for speed measurement. The selection of wheel must match a pan_CrankWheelConfig\n          block elsewhere in the model.\n        \n      \n                Calibratable: no.\n              TypeParamList\n        \n          A drop down to specify the speed calculation\n          to perform. The selection of type is dependent on the target ECU hardware selected in\n          the put_Identification block.\n        \n        Per crank wheel revolution\n                  The speed as measured every 360\u00b0 crank.\n                \n                  Supported by: M220, M221, M250 and M670.\n                Per tooth\n                  The speed as calculated from the time between the last two crank teeth. When\n                  calculating a speed across the crank missing tooth area, the block adjusts the\n                  speed as if there were physical teeth present.\n                \n                  Supported by: M220, M221, M250 and M670.\n                \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to\n          enable inport sim_speed.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKTSPD.113": "The block pan_CrankWheelSpeed shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKTSPD.213": "The block pan_CrankWheelSpeed shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.CRKTSPD.014": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTSPD.015": "If a pan_CrankWheelConfig block is not found in the model with the same Wheel\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTSPD.016": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTSPD.017": "The value of inport sim_speed  shall  be written to outport\n                speed.",
    "LLR.PLAT.PAN.CRKTSPD.018": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAN.CRKTSPD.019": "The block  shall  use the mask parameter Wheel to set the crank wheel to check for movement.",
    "LLR.PLAT.PAN.CRKTSPD.020": "The block  shall  use the mask parameter Type to set the type of speed measurement to 'per tooth'\n                or 'crank revolution'.",
    "LLR.PLAT.PAN.CRKTSPD.021": "The block  shall  set the outport speed to the calculated speed.",
    "LLR.PLAT.PAN.CRKTCNT.005": "If the crank wheel has failed to synchronise to the ECU the platform  shall  indicate this.",
    "LLR.PLAT.PAN.CRKTCNT.006": "If the crank is not synchronised, the tooth count  shall  be set to zero.\n            Rationale: \n              If the crank is not synchronised then it makes sense to initialise the crank tooth to zero so that once sync\n              is achieved the tooth count will increment sequentially from zero.",
    "LLR.PLAT.PAN.CRKTCNT.007": "The platform  shall  maintain the count of the number of teeth detected by the crankshaft sensor since the gap,\n              including counts for the missing tooth or teeth.",
    "LLR.PLAT.PAN.CRKTCNT.001": "The platform shall provide a C interface function named\n                pan_get_crank_wheel_tooth() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_valid\n          out\n        BOOL *\nPointer to the boolean result of whether the value returned in panf_crank_tooth is valid. \n Cannot be NULLpanf_crank_tooth\n          out\n        U16 *\nPointer to where the current tooth will be written. The written tooth is not adjusted for the missing teeth (i.e., only physical teeth are represented). \n Cannot be NULL. \n Range: [1, PIO_CRANK_TEETH_MAX] teeth\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configured",
    "LLR.PLAT.PAN.CRKTCNT.101": "The function pan_get_crank_wheel_tooth() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKTCNT.201": "The function pan_get_crank_wheel_tooth() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKTCNT.002": "The function  shall  check the panf_wheel\n                is valid in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTCNT.003": "The function  shall  check that the pointer to the valid flag\n                ptpuf_valid is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTCNT.004": "The function  shall  check that the pointer to the current tooth location\n                ptpuf_crank_tooth is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKTCNT.008": "If the interface parameter checks pass then the function  shall \n                write the current tooth value of the selected\n                crank wheel panf_wheel through\n                ptpuf_crank_tooth,\n                otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKTCNT.009": "The platform shall provide a Simulink interface block named\n                pan_CurrentCrankTooth that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_validInportBoolean\n        \n          Only used under\n          simulation. Under simulation, the value of this inport passed through to the\n          valid outport.\n        \n        \n          Range: 0 or 1\n        \n      sim_toothInportInteger\n        \n          Only used under\n          simulation. Under simulation, the value of this inport passed through to the\n          tooth outport.\n        \n        \n          Range: [1, n-1] tooth (where n is\n          the number of physical teeth on the crankshaft wheel encoder)\n        \n      validOutportBoolean\n        \n          Set to 0 when the ECU cannot\n          provide a crank tooth (for instance, the ECU has not synchronised to the\n          crankshaft wheel encoder), set to 1 when the outport tooth is valid.\n        \n        \n          Range: 0 or 1\n        \n      toothOutportInteger\n        \n          The number of the last detected tooth\n          of the crankshaft wheel encoder. The block only provides an indication of the physical\n          teeth (missing teeth are not estimated). For instance, the block will have a range of\n          [1, 58] for a crankshaft wheel encoder with 58 physical teeth and two missing teeth.\n        \n        \n          Range: [1, n-1] tooth (where n is\n          the number of physical teeth on the crankshaft wheel encoder)\n        \n      WheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          for tooth measurement. The selection of wheel must match a pan_CrankWheelConfig\n          block elsewhere in the model.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to\n          enable inports sim_valid and sim_tooth.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKTCNT.109": "The block pan_CurrentCrankTooth shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKTCNT.209": "The block pan_CurrentCrankTooth shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.CRKTCNT.010": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTCNT.011": "If a pan_CrankWheelConfig block is not found in the model with the same Wheel\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTCNT.012": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKTCNT.013": "The value of inport sim_valid  shall  be written to outport\n                valid.",
    "LLR.PLAT.PAN.CRKTCNT.014": "The value of inport sim_tooth  shall  be written to outport\n                tooth.",
    "LLR.PLAT.PAN.CRKTCNT.015": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAN.CRKTCNT.016": "The block  shall  use the mask parameter Wheel to set the crank wheel to check for tooth number.",
    "LLR.PLAT.PAN.CRKTCNT.017": "The block  shall  write the tooth validity status to the outport valid.",
    "LLR.PLAT.PAN.CRKTCNT.018": "The block  shall  write the detected tooth number to the outport tooth.",
    "LLR.PLAT.PAN.CRKSYNC.006": "When requested by the application, synchronisation of\n            the crank wheel  shall  be reported when a\n            missing tooth gap has been detected and verified. Loss of\n            synchronisation of the crank wheel shall be reported\n            upon detecting the crank wheel has transitioned into a stall. Prior\n            to detecting the first missing tooth gap an unsynchronised crank\n            wheel shall be indicated to\n            the host application.",
    "LLR.PLAT.PAN.CRKSYNC.001": "The platform shall provide a C interface function named\n                pan_get_crank_wheel_sync() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \npanf_crank_sync\n          out\n        BOOL *\nPointer to the boolean result of whether the crank is synced. \n Cannot be NULL\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configured",
    "LLR.PLAT.PAN.CRKSYNC.101": "The function pan_get_crank_wheel_sync() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKSYNC.201": "The function pan_get_crank_wheel_sync() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKSYNC.002": "The function  shall  check the panf_wheel\n                is valid in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKSYNC.003": "The function  shall  check that the pointer to the flag panf_crank_sync is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKSYNC.004": "The function  shall  check the selected toothed wheel panf_wheel has been configured at initialisation and return\n              PAN_RC_CRANK_NOT_CONFIGURED otherwise.",
    "LLR.PLAT.PAN.CRKSYNC.005": "The function  shall  return PAN_RC_OK if interface parameter checks pass.",
    "LLR.PLAT.PAN.CRKSYNC.007": "If the interface parameter checks pass then the function  shall \n                write the acquired boolean value indicating sync\n                (0 indicates no sync, 1 indicates sync) of the selected\n                crank wheel panf_wheel through\n                ptpuf_crank_sync, otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKSYNC.008": "The platform shall provide a Simulink interface block named\n                pan_CrankWheelSync that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_syncInportBoolean\n        \n          Only used under\n          simulation. Under simulation, the value of this inport passed through to\n          outport sync.\n        \n        \n          Range: 0 or 1\n        \n      syncOutportBoolean\n        \n          Set to 0 if the block has not gained\n          synchronisation with the crankshaft wheel encoder, set to 1 if synchronisation has\n          been achieved.\n        \n        \n          Range: 0 or 1\n        \n      WheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          for synchronisation information. The selection of wheel must match a\n          pan_CrankWheelConfig block elsewhere in the model.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to\n          enable inport sim_sync.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKSYNC.108": "The block pan_CrankWheelSync shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKSYNC.208": "The block pan_CrankWheelSync shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.CRKSYNC.009": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKSYNC.010": "If a pan_CrankWheelConfig block is not found in the model with the same Wheel\n                then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKSYNC.011": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKSYNC.012": "The value of inport sim_sync  shall  be written to outport\n                sync.",
    "LLR.PLAT.PAN.CRKSYNC.013": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAN.CRKSYNC.014": "The block  shall  use the mask parameter Wheel to set the crank wheel to check for sync.",
    "LLR.PLAT.PAN.CRKSYNC.015": "The block  shall  set the outport sync to 1 if crank sync is detected.",
    "LLR.PLAT.PAN.CRKDIN.014": "When requested by the application the platform  shall  give the voltage state on the pin for the specified crank wheel.",
    "LLR.PLAT.PAN.CRKDIN.001": "The platform shall provide a C interface function named\n                pan_get_crank_pin_state() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_wheel\n          in\n        PIO_CRANK_WHEEL_T\nThe configured crank wheel to read. \n Use the enum included by the pio.h file, of the form PIO_CRANK_WHEEL[NAME]. \n Range: [0, PIO_CRANK_WHEEL_LAST - 1]panf_crk_pin_state\n          out\n        BOOL *\nThe state of the crank pin is written through this pointer. Cannot be NULL. \n Range: 0 or 1\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration errorPAN_RC_CRANK_NOT_CONFIGURED - crank wheel has not been configured",
    "LLR.PLAT.PAN.CRKDIN.101": "The function pan_get_crank_pin_state() shall support the targets:\n                      M250-000 and M670-000.",
    "LLR.PLAT.PAN.CRKDIN.201": "The function pan_get_crank_pin_state() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.CRKDIN.002": "The function  shall  check the selected toothed wheel panf_wheel has been configured at initialisation\n              and return PAN_RC_CRANK_NOT_CONFIGURED otherwise.",
    "LLR.PLAT.PAN.CRKDIN.003": "The function  shall  check that the pointer to the valid flag\n                panf_crk_pin_state is\n                not NULL and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKDIN.004": "The function  shall  check the panf_wheel\n                is valid in [0..PIO_CRANK_WHEEL_LAST] and return PAN_RC_BAD_ARGS otherwise.",
    "LLR.PLAT.PAN.CRKDIN.005": "If the interface parameter checks pass then the function  shall \n                write the crank pin state of the selected crank wheel\n                panf_wheel to panf_crk_pin_state,\n                otherwise it  shall  be set to zero.",
    "LLR.PLAT.PAN.CRKDIN.006": "The platform shall provide a Simulink interface block named\n                pan_CrankWheelDigitalInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_stateInportBoolean\n        \n          Only used under\n          simulation. Under simulation, the value of this inport is passed through to\n          outport state.\n        \n        \n          Range: 0 or 1\n        \n      stateOutportBoolean\n        \n          Set to 0 if the voltage level on the\n          crank pin is low, set to 1 if the voltage level on the crank pin is high.\n        \n        \n          Range: 0 or 1\n        \n      WheelParamList\n        \n          A drop down to identify the crankshaft wheel\n          to measure. The selection of wheel must match a pan_CrankWheelConfig\n          block elsewhere in the model.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to\n          enable inport sim_state.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.CRKDIN.007": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKDIN.008": "If a pan_CrankWheelConfig block is not found in the model with the same\n                Wheel then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKDIN.009": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.CRKDIN.010": "The value of inport sim_state  shall  be written to outport\n                state.",
    "LLR.PLAT.PAN.CRKDIN.011": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAN.CRKDIN.012": "The block  shall  use the mask parameter Wheel to set the crank wheel\n                to check for state.",
    "LLR.PLAT.PAN.CRKDIN.013": "The block  shall  set the outport state to the detected tooth state.",
    "LLR.PLAT.PAN.INJDIFB.001": "The platform shall provide a C interface function named\n                pan_get_injection_di_setpoint() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_inj\n          in\n        U8\nID of the injector to read back. \n Range: [1, PIO_ANG_MAX_INJECTORS]panf_pulses\n          out\n        U8 *\nThe number of elements in the arrays containing the pulse durations and on angles.\n Range: [0, PIO_ANG_INJECTOR_MAX_PULSES]panf_rel_on_angle\n          out\n        F32 *\nAn array of PTPU_DI_MAX_PULSES pulse on angles, relative to TDC to match the values passed passed to pan_set_injection_di(). \n Range: [-720, 720] degrees panf_fuel_amount\n          out\n        F32 *\nAn array of PTPU_DI_MAX_PULSES pulse amounts to match the values passed to pan_set_injection_di(). \n Range: [0, 512) mm3 if panf_duration_mode is PIO_INJDI_DURATION_MODE_VOLUME. \n Range: [0, 1000] ms if panf_duration_mode is PIO_INJDI_DURATION_MODE_TIME. \n panf_duration_offset\n          out\n        F32 *\nAn offset applied to this injector's injection durations to match the value passed to pan_set_injection_di(). \n Range: [-8.191, 8.192] ms (1\/4096)panf_drop_dead_angle\n          out\n        F32 *\nThe drop-dead angle configured for this injector to match the value passed to pan_config_injections_di(). \npanf_duration_mode\n          out\n        PIO_INJDI_DURATION_MODE_T *\nSpecifies if the fuel amount is specified in volume or time to match the value passed to pan_set_injection_di(). \n Range: PIO_INJDI_DURATION_MODE_[NAME]\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration error. This can result from passing NULL parameters or an unsupported injector number.PAN_RC_INJ_NOT_CONFIGURED - Function called without first initialising DI injectors.",
    "LLR.PLAT.PAN.INJDIFB.002": "The function pan_get_injection_di_setpoint() shall support the targets:\n                      M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.INJDIFB.003": "The function pan_get_injection_di_setpoint() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.INJDIFB.004": "The function  shall  return PAN_RC_BAD_ARGS when\n                panf_inj_id is outside of the range [1, PIO_ANG_MAX_INJECTORS].",
    "LLR.PLAT.PAN.INJDIFB.005": "The function  shall  return PAN_RC_BAD_ARGS when\n                  panf_pulses,\n                  panf_rel_on_angles,\n                  panf_fuel_amounts,\n                  panf_duration_offset,\n                  panf_drop_dead_angle or\n                  panf_duration_mode is NULL.",
    "LLR.PLAT.PAN.INJDIFB.006": "The function  shall  return PAN_RC_INJ_NOT_CONFIGURED if called\n                before correctly setting up the DI injectors.",
    "LLR.PLAT.PAN.INJDIFB.007": "If called while crank-sync has not been achieved, all injection parameters  shall  be\n                set to 0.",
    "LLR.PLAT.PAN.INJDIFB.008": "If called while crank-sync has been achieved, The number of pulses stored in eTPU\n                parameter RAM set by pan_set_injection_di for the injector\n                indicated by panf_inj  shall  be written out to\n                panf_pulses.",
    "LLR.PLAT.PAN.INJDIFB.009": "If called while crank-sync has been achieved, The pulse on angles stored in eTPU\n                parameter RAM set by pan_set_injection_di for the injector\n                indicated by panf_inj  shall  be written out to\n                panf_rel_on_angle.",
    "LLR.PLAT.PAN.INJDIFB.010": "If called while crank-sync has been achieved, The pulse amounts stored in eTPU\n                parameter RAM set by pan_set_injection_di for the injector\n                indicated by panf_inj  shall  be written out to\n                panf_fuel_amount.",
    "LLR.PLAT.PAN.INJDIFB.011": "If called while crank-sync has been achieved, The injection duration offset stored\n                in eTPU parameter RAM set by pan_set_injection_di for the\n                injector indicated by panf_inj  shall  be written out to\n                panf_duration_offset.",
    "LLR.PLAT.PAN.INJDIFB.012": "If called while crank-sync has been achieved, The drop-dead angle stored in eTPU\n                parameter RAM set by ptpu_config_injections_di for the injector\n                indicated by panf_inj  shall  be written out to\n                panf_drop_dead_angle.",
    "LLR.PLAT.PAN.INJDIFB.013": "If called while crank-sync has been achieved, The injection duration mode stored in\n                eTPU parameter RAM set by pan_set_injection_di for the injector\n                indicated by panf_inj  shall  be written out to\n                panf_duration_mode.",
    "LLR.PLAT.PAN.INJDIFB.014": "The platform shall provide a Simulink interface block named\n                pan_InjectionSetpoint_DI that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninjector_idInportReal\n        \n          The number that identifies which injector's schedule will be read back.\n        \n        \n          Range: [1, 6] unitless\n        \n      validOutportReal\n        \n          A value of 1 specifies that the data read was successfully and coherently read.\n          A value of 0 indicates that some problem occurred.\n        \n        \n          Range:[0, 1]\n        \n      on_angleOutportReal\n        \n          An array of PTPU_DI_MAX_PULSES pulse on angles, relative to TDC to\n          match the values passed to pan_Injection_DI.\n        \n        \n          Range: [-720, 720] degrees\n        \n        Note\n            The value passed to the platform is transformed to be kept with in a valid angle\n            range.  This transform cannot be reversed, so the angle is reported with the following\n            transform applied:\n          \n            on_angle = ((on_angle + 1080\u00b0) mod 720\u00b0) - 360\u00b0\n          \n      amountOutportReal\n        \n          An array of \\c PTPU_DI_MAX_PULSES pulse amounts to match the values\n          passed to pan_Injection_DI.\n        \n        \n          Range: [0, 512) mm3 if duration_mode is set to volume mode.\n                 [0, 1000] ms if duration_mode is set to time mode.\n        \n        Note\n            The best resolution of injection duration is 0.25 microseconds for M2xx targets and 0.2424 microseconds for M670.\n            Actual resolution of the duration is a function of the maximum duration of all pulses in this schedule request.\n            In the current implementation, granularity doubles every power of two times the maximum timer duration.  The maximum\n            timer duration is 16.384 ms for M2xx targets, and 15.887 ms for M670.  For example, the M2xx resolution is\n            0.25 us if the maximum pulse duration is less than 16.384 ms, and the resolution will go to 0.50 us if the\n            maximum pulse duration is between 16.384 us and 32.7675 us, etc.\n          \n      duration_offsetOutportReal\n        \n          An offset applied to this injector's injection durations to match the\n          value passed to pan_Injection_DI.\n        \n        \n          Range: [-8.192, 8.192] milliseconds\n        \n      duration_modeOutportReal\n        \n          Specifies if the fuel amount is specified in volume or time to match the\n          value passed to pan_Injection_DI.\n        \n        \n          Range:[0, 1]\n        \n      drop_dead_angleOutportReal\n        \n          Specifies the drop dead angle as set by he parameter value passed to\n          pan_InjectorConfig_DI.\n        \n      Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.INJDIFB.015": "The block pan_InjectionSetpoint_DI shall support the targets:\n            M220-000, M221-000, M250-000 and M670-000.",
    "LLR.PLAT.PAN.INJDIFB.016": "The block pan_InjectionSetpoint_DI shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.INJDIFB.017": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.INJDIFB.018": "If the block is executed without DI injection being setup then the block  shall  set\n                the outport valid to 0.",
    "LLR.PLAT.PAN.INJDIFB.019": "If the inport injector_id is outside\n                its range than the block  shall  set the outport\n                valid to 0.",
    "LLR.PLAT.PAN.INJDIFB.020": "if the block successfully executes, then the block  shall  set the outport\n                valid to 1.",
    "LLR.PLAT.PAN.INJDIFB.021": "If called while crank-sync has been achieved, The pulse on angles stored in eTPU\n                parameter RAM set by pan_Injection_DI for the injector\n                indicated by injector_id  shall  be\n                written to the outport on_angle.",
    "LLR.PLAT.PAN.INJDIFB.022": "If called while crank-sync has been achieved, The pulse amounts stored in eTPU\n                parameter RAM set by pan_Injection_DI for the injector\n                indicated by injector_id  shall  be\n                written to the outport amount.",
    "LLR.PLAT.PAN.INJDIFB.023": "If called while crank-sync has been achieved, The pulse duration offset stored in\n                eTPU parameter RAM set by pan_Injection_DI for the injector\n                indicated by injector_id  shall  be\n                written to the outport duration_offset.",
    "LLR.PLAT.PAN.INJDIFB.024": "If called while crank-sync has been achieved, The\n                drop-dead angle\n                stored in eTPU parameter RAM set by pan_InjectorConfig_DI for\n                the injector indicated by injector_id\n                 shall  be written to the outport\n                drop_dead_angle.",
    "LLR.PLAT.PAN.INJDIFB.025": "If called while crank-sync has been achieved, The\n                pulse duration mode\n                stored in eTPU parameter RAM set by pan_Injection_DI for the\n                injector indicated by injector_id\n                 shall  be written to the outport\n                duration_mode.",
    "LLR.PLAT.PAN.INJGPIFB.001": "The platform shall provide a C interface function named\n                pan_get_injection_gpi_setpoint() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_cyl\n          in\n        U8\nThe cylinder that is being read back up. \n Range: [1, PAN_MAX_CYLINDERS]panf_enable_post_pulses\n          out\n        U8 *\nTRUE if a post pulse should occur or FALSE otherwise to match the value passed to pan_set_injection_gpi().panf_rel_on_angle\n          out\n        F32 *\nThe angle at which to start injection pulse from TDC firing of cylinder to match the value passed to pan_set_injection_gpi(). Range: [-360, 360] degrees panf_flow_time\n          out\n        F32 *\nThe duration of injection flow time to match the value passed to pan_set_injection_gpi(). Range: [0, 349.5] mspanf_dead_time\n          out\n        F32 *\nThe duration of injection dead time to match the value passed to pan_set_injection_gpi(). Range: [0, 349.5] ms \npanf_end_of_intake_angle\n          out\n        F32 *\nThe angle at which to turn injector off to match the value passed to pan_set_injection_gpi(). Range: [0, 720] degreespanf_split_fuel_factor\n          out\n        F32 *\nThe fraction of the flow time used when in split-fuel mode to match the value passed to pan_set_injection_gpi(). Range [0, 1) absolute\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - configuration error. This can result from passing NULL parameters or an unsupported cylinder numberPAN_RC_ENGINE_NOT_CONFIGURED - Function called without first initialising DI injectors.",
    "LLR.PLAT.PAN.INJGPIFB.002": "The function pan_get_injection_gpi_setpoint() shall support the targets:\n                      M220-000, M221-000 and M670-000.",
    "LLR.PLAT.PAN.INJGPIFB.003": "The function pan_get_injection_gpi_setpoint() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.INJGPIFB.004": "The function  shall  return PAN_RC_BAD_ARGS when\n                panf_cyl is outside of the range [1, PAN_MAX_CYLINDERS].",
    "LLR.PLAT.PAN.INJGPIFB.005": "The function  shall  return PAN_RC_BAD_ARGS when\n                  panf_enable_post_pulses,\n                  panf_rel_on_angle,\n                  panf_flow_time,\n                  panf_dead_time,\n                  panf_end_of_intake_angle or\n                  panf_split_fuel_factor is NULL.",
    "LLR.PLAT.PAN.INJGPIFB.006": "The function  shall  return PAN_RC_ENGINE_NOT_CONFIGURED if called\n                before correctly setting up the GPI injectors.",
    "LLR.PLAT.PAN.INJGPIFB.007": "If called while crank-sync has not been achieved, all injection parameters  shall  be\n                set to 0.",
    "LLR.PLAT.PAN.INJGPIFB.008": "If called while crank-sync has been achieved, The\n                enable post-pulses setting\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for the\n                injector indicated by panf_cyl  shall  be written out to\n                panf_enable_post_pulses.",
    "LLR.PLAT.PAN.INJGPIFB.009": "If called while crank-sync has been achieved, The\n                injection on angle\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for\n                the injector indicated by panf_cyl  shall  be written out to\n                panf_rel_on_angle.",
    "LLR.PLAT.PAN.INJGPIFB.010": "If called while crank-sync has been achieved, The\n                injection flow time\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for\n                the injector indicated by panf_cyl  shall  be written out to\n                panf_flow_time.",
    "LLR.PLAT.PAN.INJGPIFB.011": "If called while crank-sync has been achieved, The\n                injection dead time\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for\n                the injector indicated by panf_cyl  shall  be written out to\n                panf_dead_time.",
    "LLR.PLAT.PAN.INJGPIFB.012": "If called while crank-sync has been achieved, The\n                end-of-intake angle\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for\n                the injector indicated by panf_cyl  shall  be written out to\n                panf_end_of_intake_angle.",
    "LLR.PLAT.PAN.INJGPIFB.013": "If called while crank-sync has been achieved, The\n                split-fuel factor\n                stored in eTPU parameter RAM set by pan_set_injection_gpi for\n                the injector indicated by panf_cyl  shall  be written out to\n                panf_split_fuel_factor.",
    "LLR.PLAT.PAN.INJGPIFB.014": "The platform shall provide a Simulink interface block named\n                pan_InjectionSetpoint_GPI that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncylinderInportReal\n        \n          The cylinder to request an injection pulse.\n        \n        \n          Range: [1, 8]\n        \n      validOutportReal\n        \n          A value of 1 specifies that the data read was successfully and coherently read.\n          A value of 0 indicates that some problem occurred.\n        \n        \n          Range:[0, 1]\n        \n      on_angleOutportReal\n        \n          The angle at which to start injection pulse from TDC firing of cylinder\n          to match the value passed to pan_Injection_GPI.\n        \n        \n          Range: [-360, 360] \u00b0\n        \n        Note\n            The value passed to the platform is transformed to be kept with in a valid angle\n            range.  This transform cannot be reserved, so the angle is reported with the following\n            transform applied:\n          \n            on_angle = on_angle mod 720\u00b0\n          \n      flow_timeOutportReal\n        \n          The duration of injection flow time to match the value passed to\n          pan_Injection_GPI.\n        \n        \n          Range: [0, 350] ms\n        \n      dead_timeOutportReal\n        \n          The duration of injection dead time to match the value passed to\n          pan_Injection_GPI.\n        \n        \n          Range: [0, 350] ms\n        \n      end_of_intake_angleOutportReal\n        \n          The angle at which to turn injector off to match the value passed to\n          pan_Injection_GPI.\n        \n        \n          Range: [0, 720) \u00b0\n        \n        Note\n            If crank sync has not been achieved, then this value will be that of negative the TDC\n            firing angle.\n          \n      split_fuel_factorOutportReal\n        \n          The fraction of the flow time used when in split-fuel mode to match the\n          value passed to pan_Injection_GPI.\n        \n        \n          Range: [0, 1)\n        \n      Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.INJGPIFB.015": "The block pan_InjectionSetpoint_GPI shall support the targets:\n            M220-000, M221-000 and M670-000.",
    "LLR.PLAT.PAN.INJGPIFB.016": "The block pan_InjectionSetpoint_GPI shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.INJGPIFB.017": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAN.INJGPIFB.018": "If the block is executed without GPI injection being setup then the block  shall  set\n                the outport valid to 0.",
    "LLR.PLAT.PAN.INJGPIFB.019": "If the inport cylinder is outside\n                its range than the block  shall  set the outport\n                valid to 0.",
    "LLR.PLAT.PAN.INJGPIFB.020": "if the block successfully executes, then the block  shall  set the outport\n                valid to 1.",
    "LLR.PLAT.PAN.INJGPIFB.021": "If called while crank-sync has been achieved, The\n                injection on angle\n                stored in eTPU parameter RAM set by pan_Injection_GPI for the\n                injector indicated by cylinder\n                 shall  be written to the outport\n                on_angle.",
    "LLR.PLAT.PAN.INJGPIFB.022": "If called while crank-sync has been achieved, The\n                injection flow time\n                stored in eTPU parameter RAM set by pan_Injection_GPI for the\n                injector indicated by cylinder\n                 shall  be written to the outport\n                flow_time.",
    "LLR.PLAT.PAN.INJGPIFB.023": "If called while crank-sync has been achieved, The\n                injection dead time\n                stored in eTPU parameter RAM set by pan_Injection_GPI for the\n                injector indicated by cylinder\n                 shall  be written to the outport\n                dead_time.",
    "LLR.PLAT.PAN.INJGPIFB.024": "If called while crank-sync has been achieved, The\n                end-of-intake angle\n                stored in eTPU parameter RAM set by pan_Injection_GPI for the\n                injector indicated by cylinder\n                 shall  be written to the outport\n                end_of_intake_angle.",
    "LLR.PLAT.PAN.INJGPIFB.025": "If called while crank-sync has been achieved, The\n                split-fuel factor\n                stored in eTPU parameter RAM set by pan_Injection_GPI for the\n                injector indicated by cylinder\n                 shall  be written to the outport\n                split_fuel_factor.",
    "LLR.APP.PAN.OUTAG.CFG.001": "The application  will  invoke an interface during application initialisation to declare generic angular output channels whose start angles, durations, start actions, and end actions may be set during run time.",
    "LLR.PLAT.PAN.OUTAG.CFG.002": "During or after application initialisation, the platform  shall  ensure the hardware is correctly initialised to set generic angular output channels declared by the application.",
    "LLR.PLAT.PAN.OUTAG.CFG.003": "The initialisation process  shall  set the generic angular output channel to the stall action defined by the application.",
    "LLR.PLAT.PAN.OUTAG.CFG.004": "The platform shall provide a C interface function named\n                pan_config_angular_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_ang_out_channel\n          in\n        PDX_LCHAN_T\nThe output channel. Use the macros included by the pio.h file, of the form PIO_ANGOT_[NAME].panf_ang_out_mode\n          in\n        PIO_ANG_OUTPUT_MODE_T\nThe angular output mode, angle-angle or angle-time. Use the PIO_ANG_OUTPUT_MODE_T macros included by the pio.h file.panf_ang_out_stall_action\n          in\n        PIO_ANG_OUTPUT_STALL_ACTION_T\nThe action to take on a stall. This also specifies the initial output state. Use the PIO_ANG_STALL_ACTION_T macros included by the pio.h file.\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - out of range value passedPAN_RC_SDM_ALLOC_ERROR - error allocating eTPU RAM",
    "LLR.PLAT.PAN.OUTAG.CFG.005": "The function pan_config_angular_output() shall support the targets:\n                      M670-000.",
    "LLR.PLAT.PAN.OUTAG.CFG.006": "The function pan_config_angular_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.OUTAG.CFG.007": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_channel cannot be mapped to a potential hardware output.",
    "LLR.PLAT.PAN.OUTAG.CFG.008": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_mode is out of range.",
    "LLR.PLAT.PAN.OUTAG.CFG.009": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_stall_action is out of range.",
    "LLR.PLAT.PAN.OUTAG.CFG.010": "If the interface checks pass then the function  shall  set the output mode to the panf_ang_out_mode parameter.",
    "LLR.PLAT.PAN.OUTAG.CFG.011": "If the interface checks pass then the function  shall  set the stall action to the panf_ang_out_stall_action parameter.",
    "LLR.PLAT.PAN.OUTAG.CFG.012": "The platform shall provide a Simulink interface block named\n                pan_AngularOutputConfig that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionChannelParamList\n        \n          Specifies the output channel to configure.\n        \n      \n                Calibratable: no.\n              ModeParamList\n        \n          Specifies the output mode which can be Angle-Angle or Angle-Time.\n        \n      \n                Calibratable: no.\n              Stall ActionParamList\n        \n          Specifies the pin state to be output when the engine stalls, i.e. when\n          synchronisation with the crank wheel is lost. This also determines the\n          pin state to be output when the ECU is first powered on.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.OUTAG.CFG.013": "The block pan_AngularOutputConfig shall support the targets:\n            M670-000.",
    "LLR.PLAT.PAN.OUTAG.CFG.014": "The block pan_AngularOutputConfig shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.OUTAG.CFG.015": "Target type is checked by the interface, if\n                it is unsupported then the interface  shall  raise an error.",
    "LLR.PLAT.PAN.OUTAG.CFG.016": "If the same parameter for the mask Channel \n                is used in another block within the model, then the block  shall  raise an error.",
    "LLR.PLAT.PAN.OUTAG.CFG.017": "The block  shall  schedule itself to run with a constant sample time.",
    "LLR.PLAT.PAN.OUTAG.CFG.018": "The block  shall  use the mask parameter \n                Mode\n                to set the output mode of the angular output.",
    "LLR.PLAT.PAN.OUTAG.CFG.019": "The block  shall  use the mask parameter \n                Stall Action\n                to set the stall action of the angular output.",
    "LLR.PLAT.PAN.OUTAG.OUT.001": "During application run time, the platform  shall  set the output channel state to the immediate output state requested.",
    "LLR.PLAT.PAN.OUTAG.OUT.002": "If the platform is synced to the crank wheel, the platform  shall  set the output channel state to the start action state at the\n              start angle, and the end action state after the duration from the start angle.",
    "LLR.PLAT.PAN.OUTAG.OUT.003": "The platform  shall  support the scheduling of up to six start action, end action, start angle, and duration events at a time.",
    "LLR.PLAT.PAN.OUTAG.OUT.004": "If the platform engine sync state is 360 mode, the platform  shall  schedule the start angles modulo 360 degrees.",
    "LLR.PLAT.PAN.OUTAG.OUT.005": "If the platform engine sync state is 720 mode, the platform  shall  schedule the start angles modulo 720 degrees.",
    "LLR.PLAT.PAN.OUTAG.OUT.006": "If the requested cylinder is zero, the platform  shall  schedule the start angle relative to the crank wheel absolute angle.",
    "LLR.PLAT.PAN.OUTAG.OUT.007": "If the requested cylinder is non-zero, the platform  shall  schedule the start angle relative to the cylinder TDC angle.",
    "LLR.PLAT.PAN.OUTAG.OUT.008": "If the output mode is set to Angle-Angle, the platform  shall  schedule the output duration in units of degrees.",
    "LLR.PLAT.PAN.OUTAG.OUT.009": "If the output mode is set to Angle-Time, the platform  shall  schedule the output duration in units of time.",
    "LLR.PLAT.PAN.OUTAG.OUT.010": "If allow end modification is set, the platform  shall  allow the duration or end action of an active pulse \n              to be updated.",
    "LLR.PLAT.PAN.OUTAG.OUT.011": "If allow end modification is clear, the platform  shall  not change the duration or end action of an active pulse.",
    "LLR.PLAT.PAN.OUTAG.OUT.012": "If allow cycle repeat is set, the platform  shall  repeat the schedule of events every 360 or 720 degrees depending \n              on the engine sync state.",
    "LLR.PLAT.PAN.OUTAG.OUT.013": "The platform  shall  delay the start angle of an output event if it falls within the min off time after the end action\n              of a previous pulse.",
    "LLR.PLAT.PAN.OUTAG.OUT.014": "If an output pulse start angle has passed for the current engine cycle, the platform  shall  schedule the pulse to start\n              in the next engine cycle.",
    "LLR.PLAT.PAN.OUTAG.OUT.015": "If an output pulse start angle is scheduled for the current engine cycle, and an update is made such that the new \n              start angle is in the past, the platform  shall  postpone the update until the next engine cycle, keeping the already\n              scheduled start angle.",
    "LLR.PLAT.PAN.OUTAG.OUT.016": "The platform shall provide a C interface function named\n                pan_set_angular_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpanf_ang_out_channel\n          in\n        PDX_LCHAN_T\nThe output channel. Use the macros included by the pio.h file, of the form PIO_ANGOT_[NAME].panf_ang_out_cyl_id\n          in\n        U32\nThis parameter specifies how to interpret the start angle. If the value passed here is zero then the value passed in panf_ang_out_start_angle is interpreted as an angle relative to crank zero. If the value passed is a valid cylinder number (starting from 1) then the start angle is intepreted relative to that cylinder's TDC angle.\n Range: 0 or [1, PIO_ANG_MAX_CYLINDERS]panf_ang_out_action_now\n          in\n        PIO_ANG_OUTPUT_ACTION_T\nThe action to be taken with immediate effect. Use one of the PIO_ANG_OUTPUT_ACTION_T macros included by the pio.h file. It is expected that this will usually be set to \"no change\", which makes it effectively invisible. However, this allows an application to drive an output at an approximate periodic rate (e.g. called from a periodic task) when crank sync has not be attained.panf_ang_out_num_pulses\n          in\n        U8\nThe number of elements in the arrays containing the pulse start angles, durations, start actions, and end actions. Each array must be of the same length. on angles.\n Range: [1, PIO_NUM_ANG_OUTPUT_MAX_PULSES]panf_ang_out_start_action\n          in\n        volatile const PIO_ANG_OUTPUT_ACTION_T *\nAn array of panf_ang_out_num_pulses actions to be taken at the start of each pulse event. Use one of the PIO_ANG_OUTPUT_ACTION_T macros included by the pio.h file.panf_ang_out_end_action\n          in\n        volatile const PIO_ANG_OUTPUT_ACTION_T *\nAn array of panf_ang_out_num_pulses actions to be taken at the end of each pulse event. Use one of the PIO_ANG_OUTPUT_ACTION_T macros included by the pio.h file.panf_ang_out_start_angle\n          in\n        volatile const F32 *\nAn array of panf_ang_out_num_pulses angles at which each pulse event starts. This can be crank-relative or TDC-relative depending on the value of panf_ang_out_cyl_id. Positive angles are interpreted as after TDC. The angle is folded to the range [0 720] degrees or [0 360] degrees as appropriate, and an event is then scheduled for the next such angle to occur. For a 4-stroke engine, the range [0 360] degrees is used until full engine sync (i.e. synchronisation with the cam input) has been attained. \n Range: [-720, 720] degreespanf_ang_out_duration\n          in\n        volatile const F32 *\nAn array of panf_ang_out_num_pulses durations of each event which can be either an angle or a time, depending on the mode of operation, as specified by the panf_ang_out_mode parameter in prerequisite call to pan_config_angular_output(). A duration of zero is allowed, in which case the pulse is skipped, and the next non-zero pulse is used.\n Range: [0, 360000] degrees or [0, 2000] mspanf_ang_out_allow_end_mod\n          in\n        BOOL\nA flag used to specify whether or not the event currently underway at the same index in the array of events should be adjusted according to the new input data. If this function is called after an event has started and before it has finished, then if this flag is set the end of the event will be adjusted to reflect the new duration and end action. If the duration would place the end point in the past, then the event is terminated immediately. Note that in this case, if any immediate action has been requested, the immediate action will be closely followed by the end action. \n On the other hand, if this function is called while an event is underway and this flag is clear, then the current event is not affected, and the data is used to schedule a subsequent event once the current event is over. Any immediate action is still honoured, however. \n Range: FALSE or TRUEpanf_ang_out_allow_cycle_repeat\n          in\n        BOOL\nA flag used to specify whether or not the schedule of pulses should be repeated automatically in the next engine cycle using the same values.\n Range: FALSE or TRUEpanf_ang_out_min_off_time\n          in\n        F32\nThis parameter can be used to mandate a minimum time between pulse events after the end action of one event and the start action of the next event. Note a value out of range will be clipped at the endpoints. \n Range: [PIO_TIME_ANG_OUTPUT_MIN_OFF_TIME_MIN, PIO_TIME_ANG_OUTPUT_MIN_OFF_TIME_MAX] ms\n                The function returns a value of type\n                PAN_RC_T\n                with a value of:\n              PAN_RC_OK - successful actionPAN_RC_BAD_ARGS - input data out of rangePAN_RC_SDM_ALLOC_ERROR - error allocating eTPU RAM",
    "LLR.PLAT.PAN.OUTAG.OUT.017": "The function pan_set_angular_output() shall support the targets:\n                      M670-000.",
    "LLR.PLAT.PAN.OUTAG.OUT.018": "The function pan_set_angular_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAN.OUTAG.OUT.019": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_channel \n                cannot be mapped to a potential hardware output.",
    "LLR.PLAT.PAN.OUTAG.OUT.020": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_cyl_id \n                is below zero or greater than the total number of cylinders configured.",
    "LLR.PLAT.PAN.OUTAG.OUT.021": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_action_now \n                is greater or equal to PIO_ANG_OUTPUT_ACTION_LAST.",
    "LLR.PLAT.PAN.OUTAG.OUT.022": "The function  shall  return PDX_RC_BAD_ARGS when panf_ang_out_num_pulses \n                is below zero or greater than PIO_NUM_ANG_OUTPUT_MAX_PULSES.",
    "LLR.PLAT.PAN.OUTAG.OUT.023": "The function  shall  return PAN_RC_BAD_ARGS when \n                panf_ang_out_start_action, \n                panf_ang_out_end_action, \n                panf_ang_out_start_angle, or \n                panf_ang_out_duration, is NULL.",
    "LLR.PLAT.PAN.OUTAG.OUT.024": "The function  shall  clip the panf_ang_out_min_off_time parameter to the range \n                [PIO_TIME_ANG_OUTPUT_MIN_OFF_TIME_MIN, PIO_TIME_ANG_OUTPUT_MIN_OFF_TIME_MAX].",
    "LLR.PLAT.PAN.OUTAG.OUT.025": "If the interface checks pass then the function  shall  set the immediate output action to the \n                panf_ang_out_action_now parameter for the panf_ang_out_channel channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.026": "If the interface checks pass then the function  shall  set the panf_ang_out_num_pulses\n                number of parameters from the \n                panf_ang_out_start_action,\n                panf_ang_out_end_action,\n                panf_ang_out_start_angle, and\n                panf_ang_out_duration arrays to the start action, end action, start angle, and durations\n                for the panf_ang_out_channel channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.027": "If the interface checks pass then the function  shall  set the allow end modification flag to the \n                panf_ang_out_allow_end_mod parameter for the panf_ang_out_channel channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.028": "If the interface checks pass then the function  shall  set allow cycle repeat flag to the \n                panf_ang_out_allow_cycle_repeat parameter for the panf_ang_out_channel channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.029": "If the interface checks pass then the function  shall  set the minimum off time to the \n                panf_ang_out_min_off_time parameter for the panf_ang_out_channel channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.030": "The platform shall provide a Simulink interface block named\n                pan_AngularOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncylinderInportInteger\n        \n          This determines how the start_angle is to be interpreted.\n          If zero is passed, then the start_angle is interpreted relative\n          to crank zero. If a number between 1 and the number of cylinders specified (via the\n           pan_EngineConfig block) is passed, then\n          the start_angle is interpreted relative to that cylinder's top-dead\n          centre (TDC) angle.\n      \n        \n          Range: 0 or [1, 8] (but not exceeding the number of cylinders specified by the\n          pan_EngineConfig block under parameter\n          TDC angles)\n        \n      immediate_actionInportInteger\n        \n          The action to apply immediately (i.e. when the block iterates) to the output state,\n          as specified by ???.\n        \n        \n          Range: specified by the enumeration in ???\n        \n      start_actionInportInteger\n        \n          A vector of actions to apply to the output state at the angle specified by\n          start_angle, as specified by\n          ???.  This vector may contain up to six \n          elements and must be the same width and have the same ordering as the \n          end_action,\n          start_angle, and\n          duration vectors.\n        \n        \n          Range: specified by the enumeration in ???\n        \n      end_actionInportInteger\n        \n          A vector of actions to apply to the output state after the specified duration\n          has elapsed since the start_angle, as specified by\n          ???.  This vector may contain up to six \n          elements and must be the same width and have the same ordering as the \n          start_action,\n          start_angle, and\n          duration vectors.\n        \n        \n          Range: specified by the enumeration in ???\n        \n      start_angleInportReal\n        \n          A vector of requested start angles for the beginning of the output event.\n          The interpretation of this angle is determined by the value passed\n          to the cylinder inport. The value of the angle\n          is folded to the range modulo 360\u00b0 or 720\u00b0 as appropriate\n          as explained above.  This vector may contain up to six \n          elements and must be the same width and have the same ordering as the \n          start_action,\n          end_action, and\n          duration vectors.\n        \n        \n          Range: [-720, 720] \u00b0\n        \n      durationInportReal\n        \n          A vector of either angles or times depending on the  Mode\n          specified in the instance of the pan_AngularOutputConfig\n          block that exists for this channel. When the Mode is\n          \u201cAngle-Angle\u201d, then the durations are angles in degrees; if it is \u201cAngle-Time\u201d\n          then the durations are times in milliseconds. The duration specifies when after the start_angle\n          to apply the pin action specified by the end_action.  This vector may contain up to six \n          elements and must be the same width and have the same ordering as the \n          start_action,\n          end_action, and\n          start_angle vectors.\n        \n        \n          Range: [0, 360000] \u00b0 or [0, 2000] ms\n        \n      allow_end_modificationInportBoolean\n        \n          A flag that applies only when an event is currently underway. If TRUE, then the duration\n          and end_action are updated to the new data passed. If FALSE, the data is used\n          on the next instance of the event.\n        \n        \n          Range: [0, 1]\n        \n      allow_cycle_repeatInportBoolean\n        \n          A flag that specifies if the schedule of events should be repeated in the next engine cycle. \n          If TRUE, then schedule of events will be repeated.  If FALSE, the schedule will be used only once.\n        \n        \n          Range: [0, 1]\n        \n      min_off_timeInportReal\n        \n          The minimum time between events, delaying the start of subsequent events if necessary.\n        \n        \n          Range: [0, 5] ms\n        \n      ChannelParamList\n        \n          The output pin to drive.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAN.OUTAG.OUT.031": "The block pan_AngularOutput shall support the targets:\n            M670-000.",
    "LLR.PLAT.PAN.OUTAG.OUT.032": "The block pan_AngularOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAN.OUTAG.OUT.033": "Target type is checked by the interface, if\n                it is unsupported then the interface  shall  raise an error.",
    "LLR.PLAT.PAN.OUTAG.OUT.034": "The block  shall  raise an error, if there is no matching configuration block for the mask parameter \n                Channel.",
    "LLR.PLAT.PAN.OUTAG.OUT.035": "The block  shall  raise an error if the width of the \n                start_action,\n                end_action,\n                start_angle, and\n                duration inports\n                are not the same size.",
    "LLR.PLAT.PAN.OUTAG.OUT.036": "The block  shall  raise an error if the width of the \n                start_action,\n                end_action,\n                start_angle, and\n                duration inports\n                are below 1, or greater than PIO_NUM_ANG_OUTPUT_MAX_PULSES.",
    "LLR.PLAT.PAN.OUTAG.OUT.037": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block is within.",
    "LLR.PLAT.PAN.OUTAG.OUT.038": "The block  shall  use the inport\n                cylinder\n                to set the cylinder to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.039": "The block  shall  use the inport\n                immediate_action\n                to set the immediate action to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.040": "The block  shall  use the inport\n                start_action\n                to set the start actions to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.041": "The block  shall  use the inport\n                end_action\n                to set the end actions to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.042": "The block  shall  use the inport\n                start_angle\n                to set the start angles to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.043": "The block  shall  use the inport\n                duration\n                to set the durations to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.044": "The block  shall  use the inport\n                allow_end_modification\n                to set the allow end modification flag to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.045": "The block  shall  use the inport\n                allow_cycle_repeat\n                to set the allow cycle repeat flag to use for the\n                Channel.",
    "LLR.PLAT.PAN.OUTAG.CFG.046": "The block  shall  use the inport\n                min_off_time\n                to set the minimum off time to use for the\n                Channel.",
    "LLR.APP.PAX.ADCIN.001": "The application  will  invoke an interface during application initialisation to declare\n              logical analogue input channels that will be read during run time.",
    "LLR.PLAT.PAX.ADCIN.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to read logical analogue input channels declared by the\n              application.",
    "LLR.PLAT.PAX.ADCIN.002": "During application run time, the platform  shall  convert analogue input channels and make\n              the results available to the application at the application's fastest rate.\n            Rationale: \n              The quickest the application can run is every millisecond. By converting the analogue\n              input channels every 0.5 milliseconds, a new converted value for an input channel can be\n              made available to the application each time the application runs, even if the conversion\n              of analogue inputs channels occurs asynchronously to the application.",
    "LLR.PLAT.PAX.ADCIN.003": "The platform shall provide a C interface function named\n                pax_adc_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpaxf_lchan\n          in\n        PAX_LCHAN_T\nThe channel number of the analogue input channel to be read. Use the macros included by the pio.h file, of the form PIO_AIN_[NAME].paxf_adc\n          out\n        S16 *\nPointer to the conversion result for the analogue input channel.\n Can be NULL during application initialisation.\n Cannot be NULL during application run.\n Range: [-1, 1] @ 1\/4096 A\/D counts per LSBpaxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PAX_RC_T\n                with a value of:\n              PAX_RC_OK - if normal operationPAX_RC_BAD_ARGS - if an internal error has occurredPAX_RC_SW_ERROR - if a recoverable error has been raised.",
    "LLR.PLAT.PAX.ADCIN.103": "The function pax_adc_input() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PAX.ADCIN.203": "The function pax_adc_input() shall be in the license group:\n                      None (Main library).\n                    Note: \n              The interface is overloaded in that it can perform initialisation of a channel and\n              reading of a channel. A future change may separate these functionalities to clarify\n              the interface.",
    "LLR.PLAT.PAX.ADCIN.005": "The function  shall  reject a logical channel number which cannot be mapped to a\n                potential hardware input by returning PAX_RC_BAD_ARGS.\n              Note: \n                A \u201cpotential hardware input\u201d as something the\n                processor can read, a physical quantity, in any variant of the hardware.",
    "LLR.PLAT.PAX.ADCIN.006": "During application run time, when paxf_adc is\n                 NULL then the function  shall  return\n                 PAX_RC_BAD_ARGS",
    "LLR.PLAT.PAX.ADCIN.007": "If the interface checks pass then the function  shall  write the converted\n                analogue-to-digital value for the logical channel through paxf_adc.\n              Note: \n                If the logical channel number does not match a physically connected channel, then the\n                converted value is undefined.\n              Note: \n                The interface provides the converted analogue-to-digital value without scaling this to\n                the voltage range prior to scaling by the hardware. It is up to the application to\n                convert the analogue-to-digital value to a voltage if required.",
    "LLR.PLAT.PAX.ADCIN.008": "The platform shall provide a Simulink interface block named\n                pai_BasicAnalogInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_adcInportReal\n        \n          Only used under simulation when the parameter Provide simulation input? is ticked.\n          The outport voltage is written to the value of this inport scaled from A\/D counts\n          to a voltage.\n        \n        \n          Range: [-1023, 1023] A\/D counts\n        \n      voltageOutportReal\n        \n          The raw input reading converted\n          to a voltage assuming the input range is -5V to 5V. The outport must then be scaled\n          by the application to the range given for the channel in the target's technical specification.\n        \n        \n          Range: [-5, 5] volts\n        \n      ChannelParamList\n        \n          The channel pin for this analogue input.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          Tick to enable inport sim_adc.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAX.ADCIN.108": "The block pai_BasicAnalogInput shall support the targets:\n            All targets.",
    "LLR.PLAT.PAX.ADCIN.208": "The block pai_BasicAnalogInput shall be in the license group:\n            None (Main library).\n          Note: \n              The prefix to the interface block does not match the feature prefix (PAX) because the\n              prefix names came into existance at different times. The block cannot be renamed\n              because this would break backwards compatibility in customer's models.",
    "LLR.PLAT.PAX.ADCIN.015": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PAX.ADCIN.009": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAX.ADCIN.010": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAX.ADCIN.014": "If parameter Provide simulation input?\n                is true then the sim_adc inport  shall  be available on the block,\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PAX.ADCIN.011": "If parameter Provide simulation input?\n                is false then the block  shall  set the value of outport\n                voltage to zero.",
    "LLR.PLAT.PAX.ADCIN.012": "If parameter Provide simulation input?\n                is true then the block  shall  set the value of outport\n                voltage to the value of inport\n                sim_adc, scaled and clipped\n                to match the range of the outport.",
    "LLR.PLAT.PAX.ADCIN.013": "The block  shall  write the converted analogue-to-digital value for the logical channel\n                identified by parameter Channel,\n                to the outport voltage, scaled to match\n                the range of the outport.",
    "LLR.PLAT.PAX.ANALOG.001": "The platform shall provide a C interface function named\n                put_process_analog_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_raw_adc_value\n          in\n        F32\nThe raw A\/D value as obtained from a call to the basic analogue input code. \n Range: [-4096, 4096] A\/D counts, [-5, 5] voltsputf_adc_sample_rate\n          in\n        F32\nThe rate at which this function is called for fault filtering on the given A\/D channel raw values. \n Range: [0.001, 3600] secondsputf_analogue_value\n          out\n        F32 *const\nPointer to the value that will represent the output of the A\/D conversion to an engineering value once the fault filtering has taken place. \n Cannot be NULL.putf_confirmed_min_raw_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value being below the minimum allowed value. \n Cannot be NULL.putf_confirmed_max_raw_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value being above the maximum allowed value. \n Cannot be NULL.putf_confirmed_slew_rate_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value changing faster than the maximum allowed slew rate value. \n Cannot be NULL.putf_confirmed_min_eng_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the engineering A\/D value being below the minimum allowed value. \n Cannot be NULL.putf_confirmed_max_eng_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the engineering A\/D value being above the maximum allowed value. \n Cannot be NULL.putf_transient_fault_flag\n          out\n        U8 *const\nPointer to the flag that will indicate if a transient fault has been detected. This will cause the output analogue value to be latched at the last valid engineering value or zero if the fault is present on the first iteration. \n Cannot be NULL.putf_adc_channel_cal_data\n          in\n        const PUT_ANALOGUE_CAL_DATA_T *const\nPointer to A\/D channel calibration data structure. \n Cannot be NULL.putf_adc_channel_wrk_data\n          in\n        PUT_ANALOGUE_WORKSPACE_T *const\nPointer to A\/D channel workspace data structure. This provides persistence for data in between calls to the filter function. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PAX.ANALOG.101": "The function put_process_analog_input() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PAX.ANALOG.201": "The function put_process_analog_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAX.ANALOG.002": "The function  shall  reject calls with a NULL\n            pointer is any of the following parameters\n            putf_analogue_value,\n            putf_confirmed_min_raw_range_fault,\n            putf_confirmed_max_raw_range_fault,\n            putf_confirmed_slew_rate_fault,\n            putf_confirmed_min_eng_range_fault,\n            putf_confirmed_max_eng_range_fault,\n            putf_transient_fault_flag,\n            putf_adc_channel_cal_data or\n            putf_adc_channel_wrk_data\n            by raising a recoverable  error PSY_PUT\/PUT_ANALOG_INPUT_FILTER_INVALID_ARG.",
    "LLR.PLAT.PAX.ANALOG.003": "The analogue processing function  shall  convert a raw ADC value\n            putf_raw_adc_value into an engineering value using the 1d table lookup\n            given in the data structure putf_adc_channel_cal_data.",
    "LLR.PLAT.PAX.ANALOG.004": "If the raw ADC value is outside the bounds of allowable raw ADC values,\n            [putf_confirmed_min_raw_range_fault\n            .. putf_confirmed_max_raw_range_fault], the transient fault error flag\n            putf_transient_fault_flag shall  be raised at the interface of the\n            analogue processing function.",
    "LLR.PLAT.PAX.ANALOG.005": "If the rate of change of the raw ADC value falls outside the bounds of the allowable slew\n            rates, the function  shall  raise the putf_transient_fault_flag flag.",
    "LLR.PLAT.PAX.ANALOG.006": "If the converted engineering value is outside the bounds of allowable values, the function\n             shall  raise the putf_transient_fault_flag.",
    "LLR.PLAT.PAX.ANALOG.007": "The function  shall  apply a leaky bucket routine to the transient error flag to determine if\n            a fault is persistent.",
    "LLR.PLAT.PAX.ANALOG.008": "Upon a fault being confirmed as persistent, the analogue processing routine  shall  set the\n            confirmed fault flag(s) of whichever corresponding fault(s) has its transient fault flag(s)\n            set.",
    "LLR.PLAT.PAX.ANALOG.009": "If the leaky bucket does not result in a persistent fault, the function  shall  clear all the\n            confirmed fault flags.",
    "LLR.PLAT.PAX.ANALOG.010": "The platform shall provide a Simulink interface block named\n                pai_AnalogInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_raw_valueInportReal\n        \n          Only used under simulation. Under\n          simulation, the value of this inport is used as the analogue input A\/D counts.\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      analog_valueOutportReal\n        \n          Engineering value of the analogue\n          input conversion (see Transfer function for the conversion), possibly clamped to\n          the default value if any faults are active.\n        \n      confirmed_faultsOutportBoolean\n        \n          A vector of 5 outputs. if any\n          are set, a confirmed fault condition is set.\n        \n        ElementDescriptionRange1Raw output is below lower range limit.0 or 12Raw output is above upper range limit.0 or 13Slew rate fault for raw value.0 or 14Engineering output is below lower range limit.0 or 15Engineering output is above upper range limit.0 or 1\n      transient_fault_flagOutportBoolean\n        \n          Whether the input value is\n          currently faulty (e.g. out of range). A scalar flag.\n        \n        \n          Range: 0 or 1\n        \n      ChannelParamList\n        \n          The channel pin for this analogue input.\n        \n      \n                Calibratable: no.\n              Raw data unitsParamList\n        \n          The units in which the raw analogue input data is read. Either 'ADC Counts' (default) or 'Volts'.\n        \n      \n                Calibratable: no.\n              Transfer function typeParamList\n        \n          The type of transfer function to use when converting from raw units to engineering\n          units. Either 'Map' (default) or 'Linear'.\n        \n        \n          This enables or disables the following parameters:\n        \n        ParameterMapLinearTransfer function raw axisEnabledDisabledTransfer function engineering look-upEnabledDisabledTransfer function scaleDisabledEnabledTransfer function x offsetDisabledEnabledTransfer function z offsetDisabledEnabled\n      \n                Calibratable: no.\n              Transfer function raw axisParamReal\n        \n          Vector of breakpoints for z = f(x) raw value to engineering value look-up when\n          Transfer function type is set to Map.\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Transfer function engineering look-upParamReal\n        \n          Vector of data points for engineering value look-up when\n          Transfer function type is set to Map.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Transfer function scaleParamReal\n        \n          Scale of transfer function when Transfer function type\n          is set to Linear.  'm' for z = m*(x + a) + b\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Transfer function x offsetParamReal\n        \n          Offset of transfer function when Transfer function type\n          is set to Linear.  'a' for z = m*(x + a) + b\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Transfer function z offsetParamReal\n        \n          Offset of transfer function when Transfer function type\n          is set to Linear.  'b' for z = m*(x + a) + b\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Default engineering valueParamReal\n        \n          Engineering value to be output if a fault condition is confirmed for this input.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Separate min\/max values?ParamBoolean\n        \n          Tick to separate min and max values into separate values, or combine into a vector.\n        \n        \n          This is accomplished by enabling or disabling the following parameters:\n        \n        ParameterUncheckedCheckedMinimum engineering value, Maximum engineering valueEnabledDisabledMinimum raw value, Maximum raw valueEnabledDisabledMinimum engineering valueDisabledEnabledMaximum engineering valueDisabledEnabledMinimum raw valueDisabledEnabledMaximum raw valueDisabledEnabled\n      \n                Calibratable: no.\n              Minimum engineering value, Maximum engineering valueParamReal\n        \n          Vector of minimum and maximum permissible engineering values before\n          input considered faulty when Separate min\/max values? is unchecked.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Minimum raw value, Maximum raw valueParamInteger\n        \n          Vector of minimum and maximum permissible raw values before input\n          considered faulty when Separate min\/max values? is unchecked.\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Minimum engineering valueParamReal\n        \n          Minimum permissible engineering values before input considered faulty\n          when Separate min\/max values? is checked.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Maximum engineering valueParamReal\n        \n          Maximum permissible engineering values before input considered faulty\n          when Separate min\/max values? is checked.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Minimum raw valueParamInteger\n        \n          Minimum permissible raw values before input considered faulty\n          when Separate min\/max values? is checked.\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Maximum raw valueParamInteger\n        \n          Maximum permissible raw values before input considered faulty\n          when Separate min\/max values? is checked.\n        \n        \n          Range: [-1023, 1023] A\/D counts, [-5, 5] Volts\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Absolute raw slew rate limitParamReal\n        \n          Maximum absolute\n          rate of change of input calculated over one model iteration before input\n          considered faulty.\n        \n        \n          Range: [-inf, inf] A\/D counts\/sec, [-inf, inf] Volts\/sec,\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Leaky bucket rise rateParamInteger\n        \n          Rate at which leaky\n          bucket is filled when input is faulty in some respect.\n        \n        \n          Range: [0, 1000] \/sec\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Leaky bucket fall rateParamInteger\n        \n          Rate at which leaky\n          bucket is emptied if it is not already empty.\n        \n        \n          Range: [0, 1000] \/sec\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Leaky bucket hysteresis levelParamReal\n        \n          Level below which bucket depth must fall before fault is\n          no longer considered faulty. If set to a negative value, fault remains\n          latched. As a special case, if the hysteresis depth is set negative, should the\n          input ever reach a confirmed fault state it remains \"latched\" there until the ECU\n          device is powered down.\n        \n        \n          Range: [-1, 1] unitless\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block\n          execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          Tick to enable inport sim_raw_value.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PAX.ANALOG.110": "The block pai_AnalogInput shall support the targets:\n            All targets.",
    "LLR.PLAT.PAX.ANALOG.210": "The block pai_AnalogInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PAX.ANALOG.011": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PAX.ANALOG.012": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PAX.ANALOG.013": "The block  shall  schedule itself to run on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PAX.ANALOG.019": "If parameter Provide simulation input?\n                is true then the sim_raw_value inport  shall  be available on the block,\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PAX.ANALOG.014": "If parameter Provide simulation input?\n                is false then the block  shall  set the value of outport,\n                analog_value to zero.",
    "LLR.PLAT.PAX.ANALOG.015": "If parameter Provide simulation input?\n                is true then the block  shall  set the value of outport,\n                analog_value to the value of inport\n                sim_raw_value, scaled and clipped according to the specified transfer function\n                to match the range of the outport.",
    "LLR.PLAT.PAX.ANALOG.016": "The block  shall  write the converted analogue-to-digital value for the logical channel\n                identified by parameter Channel,\n                to the outport analog_value, scaled and clipped according to the specified transfer function to match\n                the range of the outport.",
    "LLR.PLAT.PAX.ANALOG.017": "If a transient fault has been detected then the platform  shall  set the outport,\n                transient_fault_flag to true, otherwise it  shall  be false.",
    "LLR.PLAT.PAX.ANALOG.018": "If any confirmed faults have been detected then the platform  shall  set the corresponding\n                bit on the outport, confirmed_faults to true, otherwise they  shall  be\n                false.",
    "LLR.APP.PAX.CCOUT.001": "The application  will  invoke an interface during application initialisation to declare\n              logical analogue output channels that will be driven during run time.",
    "LLR.PLAT.PAX.CCOUT.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to drive constant current output channels declared by the application.",
    "LLR.PLAT.PAX.CCOUT.002": "When the interface is called, the platform  shall  drive the channel to the desired\n              current.",
    "LLR.PLAT.PAX.CCOUT.003": "The platform shall provide a C interface function named\n                pax_cc_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpaxf_lchan\n          in\n        PAX_LCHAN_T\nThe channel number of the constant current output channel to drive. Use the macros included by the pio.h file, of the form PIO_CCOT_[NAME].paxf_cc\n          in\n        S16\nThe required current to be driven, given as a unit range. Consider hardware effects such as low-side\/high-side driven, etc.. \n Range: [0, 2] A @ 1 mA per LSB (for M670 targets) \npaxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PAX_RC_T\n                with a value of:\n              PAX_RC_OK - if normal operationPAX_RC_SW_ERROR - if a recoverable error has been raisedPAX_RC_BAD_ARGS - if pax_lchan argument is incorrect",
    "LLR.PLAT.PAX.CCOUT.103": "The function pax_cc_output() shall support the targets:\n                      M550-000 and M670-000.",
    "LLR.PLAT.PAX.CCOUT.203": "The function pax_cc_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAX.CCOUT.005": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PAX_RC_BAD_ARGS.",
    "LLR.PLAT.PAX.CCOUT.006": "If the interface checks pass then the function  shall  drive the output for the\n                logical channel with the value passed in paxf_cc.",
    "LLR.PLAT.PAX.AOUT.001": "When the interface is called, the platform  shall  drive the output pin to the desired\n              output level by setting both channels of a digital potentiometer (connected in parallel).",
    "LLR.PLAT.PAX.AOUT.002": "The platform shall provide a C interface function named\n                pax_dac_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpaxf_lchan\n          in\n        PAX_LCHAN_T\nThe channel number of the analog output channel to write. Use the macros included by the pio.h file, of the form PIO_AOT_[NAME].paxf_dac_level\n          in\n        S16\nThe required analog output level fo 12bit DAC output. \n Range: [-1, 1] @ 1\/4096 A\/D counts per LSBpaxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PAX_RC_T\n                with a value of:\n              PAX_RC_OK - if normal operationPAX_RC_SW_ERROR - if a recoverable error has been raisedPAX_RC_BAD_ARGS - if pax_lchan argument is incorrect",
    "LLR.PLAT.PAX.AOUT.102": "The function pax_dac_output() shall support the targets:\n                      M110-000 and M221-000.",
    "LLR.PLAT.PAX.AOUT.202": "The function pax_dac_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PAX.AOUT.003": "The return code  shall  be one of the following:\n            PAX_RC_OK - if normal operation\nPAX_RC_SW_ERROR - if a recoverable error has been raised\nPAX_RC_BAD_ARGS - if pax_lchan argument is incorrect",
    "LLR.PLAT.PAX.AOUT.004": "The function  shall  reject an analogue output command that is outside\n                of legal range of [0.0, 1.0] by returning\n                PAX_RC_BAD_ARGS.",
    "LLR.PLAT.PAX.AOUT.005": "If the interface checks pass then the function  shall  drive the output for the\n                logical channel with the value passed in paxf_dac_data.",
    "LLR.PLAT.PBT.EXCEP.001": "When the processor takes an unrecoverable exception then boot mode  shall  reset the processor.",
    "LLR.PLAT.PBT.EXCEP.002": "When the processor takes a recoverable exception then boot mode  shall  recover and continue\n              execution.",
    "LLR.PLAT.PBT.MODE.001": "If no attempt is made to enter another mode (see subsequent requirements) then boot\n              mode  shall  attempt to enter application mode.\n            Note: \n              This implicitly includes the condition where the FEPS pin, if supported by an ECU, is\n              grounded or left floating.",
    "LLR.PLAT.PBT.MODE.002": "For ECUs with a FEPS pin that supports a positive voltage threshold, if the FEPS\n              voltage is above the threshold when the processor comes out of reset then boot mode\n               shall  attempt to enter reprogramming mode.\n            Note: \n              The following ECUs support a FEPS pin with a positive threshold:\n              M220, M250, M460 and M461.",
    "LLR.PLAT.PBT.MODE.003": "For ECUs with a FEPS pin that supports a negative voltage threshold, if the FEPS\n              voltage is below the threshold when the processor comes out of reset then boot mode\n               shall  attempt to enter reprogramming mode.\n            Note: \n              The following ECUs support a FEPS pin with a negative threshold: M220, M250, M460 and\n              M461.",
    "LLR.PLAT.PBT.MODE.004": "For ECUs with a FEPS pin, if the FEPS voltage circuitry appears to be in error then\n              boot mode  shall  attempt to enter reprogramming mode.",
    "LLR.PLAT.PBT.RESET.001": "If 5 or more powered resets occur sequentially, within 60 seconds of each other, then\n              boot mode  shall  attempt to enter reprogramming mode.\n            Rationale: \n              Any software which causes the ECU to continually reset may be causing intermittent\n              behaviour. To prevent intermittent behaviour from continuing, the ECU will attempt to\n              enter reprogramming mode, leaving the ECU in a running default state that can easily\n              be recovered from. Power cycling the ECU will allow an operator to attempt to restart\n              application mode.\n            Note: \n              It is entirely possible that reprogramming mode will cause a repeated reset. As the\n              reprogramming component will be written and tested by Pi, all efforts will be made to\n              ensure the reprogramming component is as robust as possible, leading to few residual\n              causes for reset (in contrast, the application component, written outside of Pi, may\n              not be as robust and is a likely candidate for repeated resets). However, a future\n              enhancement would instead flash a code on the flash code pin (if supported) and reset\n              at the end of the code.",
    "LLR.PLAT.PBT.CHECK.001": "For the processor's internal RAM, the platform software  shall  test all of the data and\n              address lines involved in reading or writing to any location of the RAM device, for shorts.\n            Rationale: \n              Although the processor's internal RAM has error correction logic, there may still be\n              issues with the address or data lines from the RAM (although this is much less likely\n              than external RAM devices, where loose solder can create a short).\n            Note: \n              See also [LLR.PLAT.PSC.BGRAM.004]\n              and [LLR.PLAT.PSC.BGRAM.005].",
    "LLR.PLAT.PBT.CHECK.002": "For the processor's internal RAM, boot mode  shall  test every bit of RAM to make sure\n              they are capable of storing both states 0 and 1.\n            Note: \n              See also [LLR.PLAT.PSC.BGRAM.003]\n              for external RAM.",
    "LLR.PLAT.PBT.CHECK.003": "If any RAM test fails then the boot mode  shall  attempt to enter reprogramming mode.\n            Note: \n              The reprogramming component will likely require RAM to run. At the moment, reprogramming\n              mode is entered regardless of the outcome of the RAM tests.",
    "LLR.PLAT.PBT.CHECK.007": "The boot mode header and all memory areas described therein\n               shall  be checksummed without regard to mode selection.\n            Rationale: \n              Executing corrupt code will lead to undefined behavior.  The chance of executing\n              corrupt code can be reduced by checking the boot code as early as possible.",
    "LLR.PLAT.PBT.CHECK.004": "With the application mode selected for the mode to enter, if the header data or\n              the memory regions to checksum described by the header fails its checksum\n              test then the platform  shall  attempt to enter reprogramming mode.\n            Rationale: \n              Checking the integrity of the mode to be entered protects against issues like partial\n              reprogramming or eventual loss of data from memory devices over long periods of time.\n              Running a mode with corrupt code will lead to undefined behaviour.",
    "LLR.PLAT.PBT.CHECK.005": "If the application header passes checksum\n              validation and it references a separate calibration header, the platform  shall \n              verify that calibration header, and actual calibration data if configured for\n              checksumming by that calibration header, and similarly to [LLR.PLAT.PBT.CHECK.004],\n              reprogramming mode is entered if it fails.\n            Rationale: \n              It is possible for the calibration area of flash to be completely erased\n              or only part-programmed even if the application code is intact. Attempting to\n              run the application with invalid calibration data is likely to lead to reset\n              or other unexpected behaviour.\n            Note: \n              The calibration data itself will not usually be protected by checksum to allow\n              calibration development work. However, it may be checksummed in the final\n              image for project release for greater security against misprogramming or\n              later corruption.",
    "LLR.PLAT.PBT.CHECK.008": "With the reprogramming mode selected for the mode to enter, if the header data or\n              the memory regions to checksum described by the header fails its checksum\n              test then the platform  shall  not attempt to enter reprogramming mode.\n            Rationale: \n              Checking the integrity of the mode to be entered protects against issues like partial\n              reprogramming or eventual loss of data from memory devices over long periods of time.\n              Running a mode with corrupt code will lead to undefined behaviour.\n            Note: \n              This may lead to a repeated reset if the reprogramming component fails its checksum\n              test. As described before, a future enhancement would instead flash a code on the\n              flash code pin (if supported) and reset at the end of the code.",
    "LLR.PLAT.PBT.CHECK.006": "For the start-up checksum of memory areas (e.g. code and calibration) referenced\n              by the header, the platform  shall  support at least the following algorithms:\n              1) CCITT 16-bit CRC and 2) IPv4 header (16-bit 1's complement sum).\n            Rationale: \n              The CRC was implemented first and so must be supported in future to maintain\n              compatibility with application images which use it. It is also the most robust\n              against detecting multiple data errors.\n            \n              The IPv4 16-bit sum is faster to compute and was added to improve boot-up\n              time to meet a Torchwood project requirement. It wraps bits carried from bit\n              15 back into the low-order bits of the sum, reducing the probability of\n              undetected multiple errors in the high bit which might otherwise 'cancel'.\n              It is not sensitive to changes in data ordering and insertions or deletions\n              of all-zero words, but while all of those are possible errors in serial streams,\n              they are not a concern in checksumming memory. Finally the algorithm allows\n              the parallel sum of 16-bit words in multiple sums which can then be recombined,\n              allowing optimisation of implementation through parallel processing.\n            Note: \n              Also note that in addition to the checksum value, further detection of\n              misprogrammed or corrupt flash locations is provided by ECC detection\n              in 5xxx implementations.",
    "LLR.PLAT.PBT.INVOKE.001": "Once the mode to enter has been selected, boot mode  shall  configure the processor\n              based on information from the mode's header, then invoke the mode.",
    "LLR.PLAT.PBT.INVOKE.002": "At a minimum the boot component  shall  configure the following items from the mode's header:\n            \n                  memory devices and areas;\n                \n                  watchdog;\n                \n                  clock frequency.\n                Rationale: \n              Although the header for each mode can contain additional processor configuration, the\n              requirement contentrates on the essential items. Memory devices require setup to allow\n              other requirements that perform checksums to complete. The watchdog is specified to\n              allow the processor to reset if boot code becomes stuck. The processor clock frequency\n              is specified to allow other requirements that perform checks to complete in the\n              required start-up time (see [LLR.PLAT.PBT.BOOTTIME.001]).",
    "LLR.PLAT.PBT.BOOTTIME.001": "The platform  shall  take no more than TBD milliseconds to start the application\n              from when the processor comes out of reset.\n            Note: \n              The boot duration given by the psc_decode_reset()\n              function is only an estimate, and should not be used to\n              test this requirement.",
    "LLR.PLAT.PCFG.M250.007": "During initialisation, the platform  shall  configure A32, A33 and A34 as PWM type with a\n              current trip level of 5A.\n            Note: \n              These default settings may be overridden by the application if the application invokes\n              the interface during application initialisation.",
    "LLR.PLAT.PCFG.M250.001": "The platform shall provide a C interface function named\n                pcfg_setup_m250() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcfgf_output_type_a32\n          in\n        PIO_CFG_OUTPUT_TYPE_T\nPIO_CFG_OUTPUT_TYPE_INJ to set A32 channel as an injector output, PIO_CFG_OUTPUT_TYPE_PWM to set A32 channel as a PWM output or digital output.pcfgf_current_trip_level_a32\n          in\n        PIO_CFG_CURRENT_TRIP_T\nPIO_CFG_CURRENT_TRIP_5A to set current trip level for pin A32 to ~5A; PIO_CFG_CURRENT_TRIP_2A to set current trip level for pin A32 to ~2A. Valid only if pcfgf_output_type_a32 is set to PIO_CFG_OUTPUT_TYPE_PWM.pcfgf_output_type_a33\n          in\n        PIO_CFG_OUTPUT_TYPE_T\nPIO_CFG_OUTPUT_TYPE_INJ to set A33 channel as an injector output, PIO_CFG_OUTPUT_TYPE_PWM to set A33 channel as a PWM output or digital output.pcfgf_current_trip_level_a33\n          in\n        PIO_CFG_CURRENT_TRIP_T\nPIO_CFG_CURRENT_TRIP_5A to set current trip level for pin A33 to ~5A; PIO_CFG_CURRENT_TRIP_2A to set current trip level for pin A33 to ~2A. Valid only if pcfgf_output_type_a33 is set to PIO_CFG_OUTPUT_TYPE_PWM.pcfgf_output_type_a34\n          in\n        PIO_CFG_OUTPUT_TYPE_T\nPIO_CFG_OUTPUT_TYPE_INJ to set A34 channel as an injector output, PIO_CFG_OUTPUT_TYPE_PWM to set A34 channel as a PWM output or digital output.pcfgf_current_trip_level_a34\n          in\n        PIO_CFG_CURRENT_TRIP_T\nPIO_CFG_CURRENT_TRIP_5A to set current trip level for pin A34 to ~5A; PIO_CFG_CURRENT_TRIP_2A to set current trip level for pin A34 to ~2A. Valid only if pcfgf_output_type_a34 is set to PIO_CFG_OUTPUT_TYPE_PWM.\n                The function returns a value of type\n                PCFG_RC_T\n                with a value of:\n              PCFG_RC_OK - if successful actionPCFG_RC_BAD_ARGS_TYPE - if configuration error on pin type parameterPCFG_RC_BAD_ARGS_INJ_CT - if configuration error on current trip parameter",
    "LLR.PLAT.PCFG.M250.002": "The function return value  shall  be one of:\n            PCFG_RC_OK              - if successful action\nPCFG_RC_BAD_ARGS_TYPE   - if configuration error on pin type parameter\nPCFG_RC_BAD_ARGS_INJ_CT - if configuration error on current trip parameter",
    "LLR.PLAT.PCFG.M250.003": "The function  shall  check that all pcfgf_output_type_* parameters are\n                either PIO_CFG_OUTPUT_TYPE_INJ or\n                PIO_CFG_OUTPUT_TYPE_PWM and return a not OK return code otherwise.",
    "LLR.PLAT.PCFG.M250.004": "The function  shall  check that all pcfgf_current_trip_level_*\n                parameters are either PIO_CFG_CURRENT_TRIP_5A or\n                PIO_CFG_CURRENT_TRIP_2A and return a not OK return code otherwise.",
    "LLR.APP.PCFG.M250.001": "The application  will  call this interface if the default settings are not as desired.",
    "LLR.PLAT.PCFG.M250.005": "If all parameter checks pass, the platform  shall  configure the hardware accordingly.\n              Note: \n                Due to the hardware design, channels configured as PWMs will have a recirculation diode\n                switched in permanently, and channels configured as injectors will have a recirculation\n                diode switched in during the high current (peak) portion of the signal.",
    "LLR.PLAT.PCFG.M250.006": "If all parameter checks pass, the platform  shall  configure the current level of PWM\n                channels accordingly.",
    "LLR.PLAT.PCFG.M250.IMU.001": "The platform  shall  provide an internal C function named\n              pimu_device_present() which takes in\n              no parameters.\n            \n              The function returns a value of type PIMU_RC_T with a value\n              of:\n            PIMU_RC_OK                   -if an IMU device is present\nPIMU_RC_DEVICE_NOT_PRESENT   -if an IMU device is not present",
    "LLR.PLAT.PCFG.M250.IMU.002": "The platform  shall  configure the acceleromter to a\n              range of 0 to 2g's.",
    "LLR.PLAT.PCFG.M250.IMU.003": "By default the platform  shall  configure the sample rate of the\n              accelerometer to a data-rate of 40Hz.\n            Note: \n              This default setting may be overridden by the application if the application invokes\n              the interface during application initialisation.",
    "LLR.PLAT.PCFG.M250.IMU.004": "The platform  shall  configure the gyroscopes\n              to a range scaling of +\/- 320deg\/sec.",
    "LLR.PLAT.PCFG.M250.IMU.005": "By default the platform  shall  configure\n              the sample rates of the gyroscope to be 2048Hz.\n            Note: \n              This default setting may be overridden by the application if the application invokes\n              the interface during application initialisation.",
    "LLR.PLAT.PCFG.M250.IMU.006": "The platform shall provide a C interface function named\n                pcfg_imu_rate() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcfgf_chan\n          in\n        PIO_CFG_SAMPLE_RATE_CHAN_T\nThe IMU channel needed to configure the sampling rate. This generally will include an accelerometer and a gyroscope. Use the macros included by pio.h defined in the in the enum PIO_CFG_SAMPLE_RATE_CHAN_T.pcfgf_sample_rate\n          in\n        U16\nThe sample rate to be set for the accelerometer or the gyroscope on the M250. Note that the default sample rate on the accelerometer is 40Hz and the default sample rate on the gyroscope is 2048 samples per second.\n Range (accelerometer): The accelerometer only has four options for the sample rate: 40Hz, 160Hz, 640Hz, 2560Hz\n Range (gyroscope): [4 256] or 2048 Samples Per Second\n\n                The function returns a value of type\n                PCFG_RC_T\n                with a value of:\n              PCFG_RC_OK - successful actionPCFG_RC_INVALID_CHAN - channel not supportedPCFG_RC_SAMPLE_RATE_TOO_HIGH - sample rate is too highPCFG_RC_SAMPLE_RATE_TOO_LOW - sample rate is too low",
    "LLR.PLAT.PCFG.M250.IMU.007": "The function return value  shall  be one of:\n            PCFG_RC_OK                      - if successful action\nPCFG_RC_INVALID_CHAN            - if the channel is not supported\nPCFG_RC_SAMPLE_RATE_TOO_LOW     - if the desired sample rate is too low\nPCFG_RC_SAMPLE_RATE_TOO_HIGH    - if the desired sample rate is too high",
    "LLR.PLAT.PCFG.M250.IMU.008": "The function  shall  check the range of the pcfgf_sample_rate\n                parameter and clip it and return a not OK if it is not within range.",
    "LLR.PLAT.PCFG.M250.IMU.009": "The function  shall  check the pcfgf_chan parameter and\n                return PCFG_RC_INVALID_CHAN if the channel is not supported or return PCFG_RC_OK\n                otherwise.",
    "LLR.APP.PCFG.M250.IMU.010": "The application  will  call this interface if the default sample\n                rate settings are not as desired.",
    "LLR.PLAT.PCFG.M250.IMU.011": "If all parameter checks pass, the platform  shall  configure\n                the hardware accordingly.",
    "LLR.PLAT.PCFG.M250.IMU.012": "The platform shall provide a Simulink interface block named\n                pcfg_Config_IMU_M250 that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionIMU ChannelParamList\n        \n          The device on the IMU to select for sample rate configuration (accelerometer\n          or gyroscopes).\n        \n      \n                Calibratable: no.\n              Sample RateParamReal\n        \n          The sample rate to be configured on the IMU (accelerometer or\n          gyroscope). It is important to note that the accelerometer and\n          gyroscopes each have their own separate ranges of sample rates that\n          are independent of each other.\n        \n        \n         Range, accelerometer: 40Hz, 160Hz, 640Hz, or 2560Hz.\n        \n        \n         Range, gyroscopes: [4 256] Hz or 2048Hz.\n        \n        \n         Note that for the accelerometer, there are only four choices for the\n         sample rate. If one of these four choices is not entered, the block\n         will automatically use the closest sample rate to the desired sample rate.\n         Additionally, for the gyroscopes, the block will use the closest sample\n         rate to the desired sample rate.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.",
    "LLR.PLAT.PCFG.M250.IMU.112": "The block pcfg_Config_IMU_M250 shall support the targets:\n            M250-000.",
    "LLR.PLAT.PCFG.M250.IMU.212": "The block pcfg_Config_IMU_M250 shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCFG.M250.IMU.013": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PCFG.M250.IMU.014": "If the parameter Sample Rate is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCFG.M250.IMU.015": "The block  shall  run once at startup.",
    "LLR.PLAT.PCFG.M250.IMU.016": "The block  shall  update the sample rate according to the mask parameter\n                Sample Rate.",
    "LLR.PLAT.PCFG.M670.001": "During initialisation, the platform  shall  configure all eMIOS channels to have a timebase of 4.125Mhz.\n            Note: \n              These default settings may be overridden by the application if the application invokes\n              the interface during application initialisation.",
    "LLR.PLAT.PCFG.M670.002": "The platform shall provide a C interface function named\n                pcfg_setup_pwm_clock_m670() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcfgf_pwm_chan\n          in\n        PDX_LCHAN_T\nThe channel to be configured with a particular clock selection. Only eMIOS-based channels are configurable.pcfgf_clock_select\n          in\n        PIO_CFG_MIOS_CLOCK_SELECT_T\nPIO_CFG_MIOS_CLOCK_SELECT_SLOW to set channel to use the slow clock PIO_CFG_MIOS_CLOCK_SELECT_MED to set channel to use the medium clock PIO_CFG_MIOS_CLOCK_SELECT_FAST to set channel to use the fast clock\n                The function returns a value of type\n                PCFG_RC_T\n                with a value of:\n              PCFG_RC_OK - if successful actionPCFG_RC_INVALID_CHAN - if configuration error on pin selectionPCFG_RC_BAD_ARGS_PWM_CLK - if configuration error on clock speed parameter",
    "LLR.PLAT.PCFG.M670.003": "The function pcfg_setup_pwm_clock_m670() shall support the targets:\n                      M670-000.",
    "LLR.PLAT.PCFG.M670.004": "The function pcfg_setup_pwm_clock_m670() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCFG.M670.005": "The function  shall  check that the pcfgf_pwm_chan parameter is a\n                valid eMIOS channel and the pcfgf_clock_select is a valid value\n                and return a not PCFG_RC_OK return code otherwise.",
    "LLR.PLAT.PCFG.M670.006": "If all parameter checks pass, the platform  shall  configure timebase of the channel\n                accordingly:\n              \n                  If pcfgf_clock_select is set to\n                  PIO_CFG_MIOS_CLOCK_SELECT_SLOW then the selected\n                  pcfgf_pwm_chan will  have its timebase set to 4.125Mhz.\n                \n                  If pcfgf_clock_select is set to\n                  PIO_CFG_MIOS_CLOCK_SELECT_MED then the selected\n                  pcfgf_pwm_chan will  have its timebase set to 8.25Mhz.\n                \n                  If pcfgf_clock_select is set to\n                  PIO_CFG_MIOS_CLOCK_SELECT_FAST then the selected\n                  pcfgf_pwm_chan will  have its timebase set to 16.5Mhz.",
    "LLR.PLAT.PCFG.M670.007": "The platform shall provide a Simulink interface block named\n                pcfg_Config_M670 that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionClock select: DIN (pin Y20)ParamList\n        \n          The clock speed for input pin Y20.\n        \n      \n                Calibratable: no.\n              Clock select: DIN (pin Y21)ParamList\n        \n          The clock speed for input pin Y21.\n        \n      \n                Calibratable: no.\n              Clock select: DIN (pin Y43)ParamList\n        \n          The clock speed for input pin Y43.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCFG.M670.008": "The block pcfg_Config_M670 shall support the targets:\n            M670-000.",
    "LLR.PLAT.PCFG.M670.009": "The block pcfg_Config_M670 shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCFG.M670.010": "The block  shall  update the channel time base for output Y20 according to the mask parameter\n              Clock select: DIN (pin Y20).",
    "LLR.PLAT.PCFG.M670.011": "The block  shall  update the channel time base for output Y21 according to the mask parameter\n              Clock select: DIN (pin Y21).",
    "LLR.PLAT.PCFG.M670.012": "The block  shall  update the channel time base for output Y43 according to the mask parameter\n              Clock select: DIN (pin Y43).",
    "LLR.PLAT.PCJ125.CONTROL.001": "The platform shall provide a C interface function named\n                pcj125_control() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcj125f_channel\n          in\n        PCJ125_LCHAN_T\nThe CJ125 channel to control. Use the macros included by the pio.h file, of the form PIO_CJ125_[NAME].pcj125f_ref_current\n          in\n        PIO_CJ125_REF_CURRENT_T\nEnumeration of the desired reference current used by the device.pcj125f_ip_amplification\n          in\n        PIO_CJ125_IP_AMP_T\nEnumeration of the desired amplification.pcj125f_calibration_mode\n          in\n        BOOL\nTRUE to configure the device for calibration mode. FALSE otherwise.pcj125f_workspace\n          in\/out\n        PCJ125_WORKSPACE_T *\nReference to a memory structure used to store information between function Calls. There should be one such structure allocated and passed to this function for each CJ125 in use.pcj125f_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PCJ125_RC_T\n                with a value of:\n              PCJ125_RC_OK - successful actionPCJ125_RC_HW_ERROR - error communicating on channelPCJ125_RC_BAD_ARGS - configuration error",
    "LLR.PLAT.PCJ125.CONTROL.002": "The function pcj125_control() shall support the targets:\n                      M670-000.",
    "LLR.PLAT.PCJ125.CONTROL.003": "The function pcj125_control() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCJ125.CONTROL.004": "If the pcj125f_channel parameter is an invalid channel, or if the pcj125f_workspace\n                parameter is NULL, the function  shall  return the error code: PCJ125_RC_BAD_ARGS.",
    "LLR.PLAT.PCJ125.CONTROL.005": "The interface function  shall  write the following values to all the CJ125's internal\n                register fields using values passed to the function parameters:\n              Register FieldValueNotesPA0\n                        \n                          \n                            Pump Current Active.\n                          \n                        \n                      RApcj125f_calibration_mode\n                        \n                          \n                            Put the resistance measurement in reference mode whenever calibration\n                            mode is requested by the application.\n                          \n                        \n                      RE1\n                        \n                          \n                            Enable resistance measurement required to read temperature.\n                          \n                        \n                      LApcj125f_calibration_mode\n                        \n                          \n                            Put the lambda measurement in references mode whenever calibration mode\n                            is requested by the application.\n                          \n                        \n                      VLpcj125f_ip_amplification\n                        \n                          \n                            Specify IP amplification gain according to enumeration value passed from\n                            the application.\n                          \n                        \n                      ENSCUN1\n                        \n                          \n                            Enable diagnostics.\n                          \n                        \n                      PRpcj125f_ref_current\n                        \n                          \n                            Specify reference current according to enumeration value passed from\n                            the application.",
    "LLR.PLAT.PCJ125.CONTROL.006": "After writing the values to the CJ125, the function  shall  store the written values\n                in memory allocated by the pcj125f_workspace parameter.",
    "LLR.PLAT.PCJ125.CONTROL.007": "If the value of pcj125f_init is FALSE, then\n                prior to writing the new configuration values to the CJ125, the function  shall  read\n                back the previous values written to the CJ125.",
    "LLR.PLAT.PCJ125.CONTROL.008": "The function  shall  compare the values read back from the CJ125 to the corresponding\n                values saved in the pcj125f_workspace object.  If any do not\n                match, then the function  shall  increment the SPI fault counter for that CJ125\n                device and return error code PCJ125_HW_ERROR.",
    "LLR.PLAT.PCJ125.CONTROL.009": "The platform shall provide a Simulink interface block named\n                pcj125_Control that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncalibration_modeInportInteger\n        \n          Set to 0 to put the CJ125 device in normal operation mode.  Set to 1 to put the device in\n          calibration mode.  This will cause the UR and UA analogue inputs for the CJ125 to be set to\n          their calibration values.\n        \n        \n          When calibration mode is enabled, UR, being the input indicating the temperature of the\n          UEGO sensor, will indicate the UR measurement corresponding to the optimal UEGO sensor\n          temperature.  UA, being the input indicating the UEGO pump cell current, will be set to\n          the value corresponding to a Lambda measurement of 1 when calibration mode enabled.  See\n          the ECU's technical specification for more details.\n        \n        \n          Range: [0, 1]\n        \n      reference_currentInportInteger\n        \n          Set to the enumeration of the desired reference current used by the device.\n        \n        \n          Range: [0, 15] respectively for the enumeration values: 0 uA, 10 uA, 20 uA, 30 uA, 40 uA,\n          50 uA, 60 uA, 70 uA, 80 uA, 90 uA, 100 uA, 110 uA, 120 uA, 130 uA, 140 uA, 150 uA\n        \n      Ip_amplificationInportInteger\n        \n          Set to the enumeration value corresponding to the desired amplification of the pump\n          current (Ip). Ip is calculated from the UA\n          input and its value is dependent on the specified gain setting.  See the ECU's technical\n          specification for more details.\n        \n        \n          Range: [0, 1] respectively for the enumeration values: Gain 8, Gain 17\n        \n      ChannelParamList\n        \n          Which CJ125 device to control.\n        \n      \n                Calibratable: no.\n              Initial Reference CurrentParamList\n        \n          Initial value of the Reference Current.\n        \n      \n                Calibratable: no.\n              Update during Runtime? (a)ParamBoolean\n        \n          If selected then inport reference_current is made available.\n          Otherwise the Initial Reference Current value is used during runtime.\n        \n      \n                Calibratable: no.\n              Initial Ip AmplificationParamList\n        \n          Initial value of Ip Amplification.\n        \n      \n                Calibratable: no.\n              Update during Runtime? (b)ParamBoolean\n        \n          If selected then inport Ip_amplification is made available.\n          Otherwise the Initial Ip Amplification value is used during runtime.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCJ125.CONTROL.010": "The block pcj125_Control shall support the targets:\n            M670-000.",
    "LLR.PLAT.PCJ125.CONTROL.011": "The block pcj125_Control shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCJ125.CONTROL.012": "The block  shall  generate an instance of a PCJ125_WORKSPACE_T to be\n                passed to corresponding calls to the pcj125_control() function.",
    "LLR.PLAT.PCJ125.CONTROL.013": "The block  shall  generate a single call to the pcj125_control()\n                function in the psc_initialise_app()  passing the corresponding\n                values from the block's parameters to the function's parameters and passing \n                TRUE for pcj125f_init.",
    "LLR.PLAT.PCJ125.CONTROL.014": "The block  shall  generate a single call to the pcj125_control()\n                function in the corresponding task rate's task passing the corresponding\n                values from the block's inports to the function's parameters and passing \n                FALSE for pcj125f_init.",
    "LLR.PLAT.PCJ125.DIAG.001": "The platform  shall  provide 9 digital input channels per CJ125 device supported corresponding to:\n            External Heater - Short circuit to groundExternal Heater - Open LoadExternal Heater - Short circuit to VbattIA \/ IP - Short circuit to groundIA \/ IP - Short circuit to VbattUN - Short circuit to groundUN - Short circuit to VbattVM - Short circuit to groundVM - Short circuit to Vbatt",
    "LLR.PLAT.PCJ125.DIAG.002": "When the application reads one of the digital input channels, the feature  shall :\n            Retrieve the value of the diagnostic input from the corresponding location in the internal buffer.Clear the corresponding location in the internal buffer.Trigger the corresponding SPI channel at the calling task rate.Return the read value to the application.",
    "LLR.PLAT.PCJ125.DIAG.003": "The feature  shall  attach a callback function to the corresponding CJ125 diagnostics\n              SPI queue such that for each 2-bit fault pattern in the queue,\n            \n                  If the value is 0b00, the buffer location of the corresponding \"Short to ground\"\n                  channel is set to 1 and the buffer locations of the corresponding \"open load\" and\n                  \"Short to Vbatt\" channels are set to 0.\n                \n                  If the value is 0b01, the buffer location of the corresponding \"Open load\" channel\n                  is set to 1 and the buffer locations of the corresponding \"Short to ground\" and\n                  \"Short to Vbatt\" channels are set to 0.\n                \n                  If the value is 0b10, the buffer location of the corresponding \"Short to Vbatt\" channel\n                  is set to 1 and the buffer locations of the corresponding \"Short to ground\" and\n                  \"Open load\" channels are set to 0.\n                Note: \n              Note that nothing is done for the case 0b11.  The last error will persist until it is cleared and read.",
    "LLR.PLAT.PCOMP.COMP.001": "The platform shall provide a Simulink interface block named\n                pcomp_CompileOptions that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionModeParamList\n        \n          Whether to use the default\n          compiler options, whether to add compiler options to the default options,\n          or whether to replace the default options altogether.\n        \n      \n                Calibratable: no.\n              Compiler optionsParamString\n        \n          The options to add to the\n          default compiler options, or to replace the default options, as selected by\n          parameter Mode.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCOMP.COMP.101": "The block pcomp_CompileOptions shall support the targets:\n            All targets.",
    "LLR.PLAT.PCOMP.COMP.201": "The block pcomp_CompileOptions shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCOMP.COMP.002": "If multiple instances of the block exist in the model, then the block  shall  raise an error.",
    "LLR.PLAT.PCOMP.COMP.003": "When the mask parameter Mode is set to \"Use default options\"\n                then the OpenECU default compiler options  shall  be used.",
    "LLR.PLAT.PCOMP.COMP.004": "When the mask Mode is set to 'Add to options' then the\n                text in the mask Compiler options  shall  be appended to\n                the OpenECU default compiler options.",
    "LLR.PLAT.PCOMP.COMP.005": "When the mask parameter Mode is set to \"Replace options\"\n                then the OpenECU default compiler options  shall \n                be replaced with the text in the mask Compiler options.",
    "LLR.PLAT.PCOMP.LINK.001": "The platform shall provide a Simulink interface block named\n                pcomp_LinkOptions that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionModeParamList\n        \n          Whether to use the default\n          linker options, whether to add linker options to the default options,\n          or whether to replace the default options altogether.\n        \n      \n                Calibratable: no.\n              Linker optionsParamString\n        \n          The options to add to the\n          default linker options, or to replace the default options, as selected by\n          parameter Mode.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCOMP.LINK.101": "The block pcomp_LinkOptions shall support the targets:\n            All targets.",
    "LLR.PLAT.PCOMP.LINK.201": "The block pcomp_LinkOptions shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCOMP.LINK.002": "If multiple instances of the block exist in the model, then the block  shall  raise an error.",
    "LLR.PLAT.PCOMP.LINK.003": "When the mask Mode is set to 'Use default options' then the\n                OpenECU default linker options  shall  be used.",
    "LLR.PLAT.PCOMP.LINK.004": "When the mask Mode is set to 'Add to options' then the\n                text in the mask Linker options  shall  be appended to\n                the OpenECU default linker options.",
    "LLR.PLAT.PCOMP.LINK.005": "When the mask Mode is set to 'Replace options' then the\n                OpenECU default linker options  shall  be replaced with the text\n                in the mask Linker options.",
    "LLR.PLAT.PCP.INHIBIT.001": "The platform  shall  default to re-programming enabled.",
    "LLR.PLAT.PCP.INHIBIT.005": "When CCP reprogramming is inhibited, whilst in application mode, the ECU  will  respond to the clear\n              or program memory commands with \"access denied\" messages.",
    "LLR.PLAT.PCP.INHIBIT.006": "When CCP reprogramming is not inhibited, whilst in application mode, when the ECU receives the clear\n              or program memory commands, the platform  shall  enter reprogramming mode and act upon the CCP commands in the normal\n              fashion.",
    "LLR.PLAT.PCP.INHIBIT.002": "The platform shall provide a C interface function named\n                pcp_inhibit_reprogramming() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcpf_inhibit\n          in\n        U8\nTrue if reprogramming should be inhibited, false otherwise.\n                The function returns void.",
    "LLR.PLAT.PCP.INHIBIT.102": "The function pcp_inhibit_reprogramming() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCP.INHIBIT.202": "The function pcp_inhibit_reprogramming() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCP.INHIBIT.003": "The platform  shall  inhibit reprogramming if the pcpf_inhibit\n                parameter is true and enable reprogramming otherwise.",
    "LLR.PLAT.PCP.INHIBIT.007": "The platform shall provide a Simulink interface block named\n                pcp_CCPInhibitReprogramming that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninhibitInportBoolean\n        \n          Set to 0 to allow reprogramming,\n          set to 1 to disallow reprogramming.",
    "LLR.PLAT.PCP.INHIBIT.107": "The block pcp_CCPInhibitReprogramming shall support the targets:\n            All targets.",
    "LLR.PLAT.PCP.INHIBIT.207": "The block pcp_CCPInhibitReprogramming shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCP.INHIBIT.008": "The block  shall  schedule itself to run on target at the rate\n                  specified by the subsystem that the block is within.",
    "LLR.PLAT.PCP.INHIBIT.009": "The block  shall  inhibit CCP reprogramming when the inport parameter\n                  inhibit is set to 1\n                  and enable CCP reprogramming when set to 0.",
    "LLR.PLAT.PCP.CONFIG.001": "The platform  shall  configure the defined CAN channel with a specific CAN message ID\n              and station ID.",
    "LLR.PLAT.PCP.CONFIG.002": "The platform  shall  act on CCP messages transmitted on a defined CAN channel with a specific CAN message ID\n              and station ID.",
    "LLR.PLAT.PCP.CONFIG.003": "The platform  shall  respond to CCP messages using the defined CAN message ID.",
    "LLR.PLAT.PCP.CONFIG.018": "The platform  shall  ignore CCP messages if CCP messaging is disabled.",
    "LLR.PLAT.PCP.CONFIG.030": "When reprogramming mode has been entered by negative FEPS, or there is a hardware\n              error reading the FEPS inputs, or if the application is invalid, or if\n              any of the application settings have implausible values, CCP  shall  use\n              the default settings defined by the reprogramming software, which may be\n              one of the following:\n            CRO=1785 (11-bit ID)\nDTO=1784 (11-bit ID)\nstation-address=0\ncan-bus=0\ncan-speed=500 kBpsCRO=1785 (11-bit ID)\nDTO=1784 (11-bit ID)\nstation-address=0\ncan-bus=0\ncan-speed=250 kBpsRationale: \n              The reasoning for two default settings, is to support the two most common baud rates\n              for current OpenECU customers, as well as customers using the J1939 bus.  This is\n              selectable by reprogramming software version, so that the system integrator can ensure\n              that if the application image becomes corrupted, the ECU does not negatively affect\n              the communications bus, by defaulting to the wrong baud rate.",
    "LLR.PLAT.PCP.CONFIG.031": "When reprogramming mode has been entered with positive FEPS, CCP  shall  use the settings\n              defined by the application.\n            Rationale: \n              This facilitates development, so that the same vehicle communication bus\n              can be used for both reprogramming, and calibrating without having to\n              remove the ECU from the bus.",
    "LLR.PLAT.PCP.CONFIG.032": "When reprogramming mode has been entered with FEPS grounded, CCP  shall  use the settings\n              defined by the application.\n            Rationale: \n              The enables the ECU to enter reprogramming mode without FEPS (i.e., FEPSless).",
    "LLR.PLAT.PCP.CONFIG.019": "The capi file  shall  be used to specify CCP settings in the following format:\n                \nccp-messaging\n{\n  cro = 1784;\n  cro-ext-id = false;\n  dto = 1785;\n  dto-ext-id = false;\n  station-address = 0;\n  can-bus = 0;\n  enabled-during-application-mode = true;\n  security-dev-mode = false;\n\n  security\n  {\n    privilege-level = calibration, data-acquisition, programming;\n    security-required = true;\n    ecu-seed-generation-function = \"app_seed_request_function\";\n    ecu-key-validation-function = \"app_key_validation_function\";\n    asap-dll-file = \"seedkey1.dll\";\n    asap-key-generation-function = \"ASAP1A_CCP_ComputeKeyFromSeed\";\n  }\n}",
    "LLR.PLAT.PCP.CONFIG.020": "The interface  shall  use the cro value to configure the Receive\n                message identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.051": "The interface  shall  use the cro-ext-id value to configure the\n                message id length of receive message identifiers for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.021": "The interface  shall  use the dto value to configure the Transmit\n                message identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.052": "The interface  shall  use the dto-ext-id value to configure the\n                message id length of transmit message identifiers for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.022": "The interface  shall  use the station-address value to configure\n                the Station address identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.023": "The interface  shall  use the can-bus value to configure the CAN\n                bus identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.024": "If the enabled-during-application-mode is set true the\n                interface  shall  enable CCP sessions, otherwise they shall be disabled.",
    "LLR.PLAT.PCP.CONFIG.033": "If security-required is set true for a CCP privilege level (calibration, data-acquisition or programming), the\n                the platform  shall  be configured to call the ecu-key-generation-function function specified\n                to validate CCP seed\/key security for the privilege level.",
    "LLR.PLAT.PCP.CONFIG.034": "If security is not specified for a CCP privilege level (calibration, data-acquisition or programming,\n              or if security-required is set false for a CCP privilege level,\n              the platform  shall  be configured to permit the use of this privilege level without requiring security.\n            Rationale: \n              This ensures backwards compatibility for older applications which did not provide CCP security.",
    "LLR.PLAT.PCP.CONFIG.050": "If security-dev-mode is set true, then the interface  shall  disable CCP security when reprogramming\n              mode is entered with FEPS applied.\n            Rationale: \n              This provides a mode of operation for customers developing their security routines to be able to recover\n              from a flawed security routine.",
    "LLR.PLAT.PCP.CONFIG.047": "The interface  shall  report an error for a security{} statement where the security-required statement is omitted, or\n              a security{} statement where security-required is specified as true but the ecu-key-validation-function\n              statement is omitted.",
    "LLR.PLAT.PCP.CONFIG.035": "If security-required is set true for a CCP privilege level and ecu-seed-generation-function is specified,\n              the platform  shall  be configured to call this function to calculate a seed value\n              when a CCP seed is requested.",
    "LLR.PLAT.PCP.CONFIG.048": "If security-required is set true for a CCP privilege level and ecu-seed-generation-function is omitted,\n              the platform  shall  be configured to return a randomly-generated seed value\n              when a CCP seed is requested.",
    "LLR.PLAT.PCP.CONFIG.049": "If more than one security{} statement exists for a CCP privilege level, the interface  shall  report an error.",
    "LLR.PLAT.PCP.CONFIG.036": "If the interface is required (via command-line option) to generate A2L files to configure cal tools,\n              security-required is set true for a\n              CCP privilege level, and asap-dll-file is specified for that CCP privilege level, then\n              the generated A2L files  shall  specify this seed\/key DLL to be used by a cal tool when establishing\n              CCP security for this CCP privilege level.",
    "LLR.PLAT.PCP.CONFIG.037": "If the interface is required (via command-line option) to generate A2L files to configure cal tools,\n              security-required is set true for a\n              CCP privilege level, asap-dll-file is specified for that CCP privilege level, and asap-key-generation-function\n              is also specified for the privilege level, then\n              the generated A2L files  shall  specify this function to be called from the specified DLL by a cal tool when\n              establishing CCP security for this CCP privilege level.  If this is not specified then the default ASAP1A function\n              ASAP1A_CCP_ComputeKeyFromSeed() shall be used.  Note that not all cal tools support the specification of\n              a separate DLL function; currently only ATI supports this.",
    "LLR.PLAT.PCP.CONFIG.045": "Where functions are specified for the ECU to calculate seed and key values, the platform  shall  copy these\n              functions to NVM.  On entry to reprogramming mode, these functions shall be retrieved from NVM and copied to RAM.\n              These functions shall then be invoked for CCP seed\/key security in reprogramming mode.\n            Rationale: \n              This provides the method by which [HLR.PLAT.CCPSecurity.002] is met for the bootloader.\n            \n              Note that this places a restriction on these functions that they must be relocatable.  In other words, they must\n              not access global or static data, and must not call any functions.  Their outputs must be solely determined by\n              their input parameters.  This is not a requirement on the OpenECU platform, but is a limitation that must be observed by\n              users of OpenECU.  As such, it is appropriately documented in the user guide.",
    "LLR.PLAT.PCP.CONFIG.046": "If key validation and any optional seed generation functions stored in NVM do not exist, or if one or more\n              of this set of functions is corrupted,\n              reprogramming mode  shall  not require CCP seed\/key security for any CCP privilege levels.\n            Rationale: \n              This provides the method by which [HLR.PLAT.CCPSecurity.003] and [HLR.PLAT.CCPSecurity.005] are met\n              for the bootloader.\n            \n              This ensures backwards compatibility for older applications which did not provide CCP security, and ensures\n              that we fail \"open\" (and hence do not leave the ECU inaccessible) in the event of NVM failure.",
    "LLR.PLAT.PCP.CONFIG.025": "If the ccp-messaging section is omitted from the capi file then the following default configuration  shall  be used:\n                \n                    CRO  shall  be set to 1785 (6F9hex).\n                  \n                    CRO-Ext-ID  shall  be set to false.\n                  \n                    DTO  shall  be set to 1784 (6F8hex).\n                  \n                    DTO-Ext-ID  shall  be set to false.\n                  \n                    station-address  shall  be set to zero.\n                  \n                    can-bus  shall  be set to zero.\n                  \n                    enabled-during-application-mode  shall  be set false.\n                  \n                    security for all CCP privilege levels  shall  be disabled.",
    "LLR.PLAT.PCP.CONFIG.006": "The platform shall provide a Simulink interface block named\n                pcp_CCPConfiguration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionReceive message identifierParamInteger\n        \n          A unique CAN message identifier for CCP CRO messages.\n        \n        \n          Range: [0, 2047] or [0, 536870911] when\n          Use CRO extended ID? (29 bit) is selected.\n        \n      \n                Calibratable: no.\n              Transmit message identifierParamInteger\n        \n          A unique CAN message identifier for CCP DTO messages.\n        \n        \n          Range: [0, 2047] or [0, 536870911] when\n          Use DTO extended ID? (29 bit) is selected.\n        \n      \n                Calibratable: no.\n              Station addressParamInteger\n        \n          The station address\n          for CCP sessions. OpenECU will only communicate using CCP if a session is opened\n          using this station address. This feature is often used for connecting multiple\n          CCP devices to the same CAN bus using the same CRO and DTO identifiers.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              CAN bus identifierParamList\n        \n          Which can bus CCP communications will occur on.\n        \n      \n                Calibratable: no.\n              Enable CCP during model execution?ParamBoolean\n        \n          If\n          checked, then CCP communications is enabled while the model is running. If\n          unchecked, CCP communications is disabled while the model is running. In either\n          case, CCP communications is enabled when reprogramming OpenECU.\n        \n        Warning\n            By not checking this option, reprogramming mode can only be entered with FEPS\n            applied.  The ECU will not be able to be re-flashed without FEPS.\n          \n      \n                Calibratable: no.\n              Use CRO extended ID? (29 bit)ParamBoolean\n        \n          If checked, then 29 bit CAN identifiers for CCP receive messages will be supported the\n          range being [0, 536870911]. If unchecked, then CCP will support 11 bit CAN identifiers\n          the range being [0, 2047].\n        \n      \n                Calibratable: no.\n              Use DTO extended ID? (29 bit)ParamBoolean\n        \n          If checked, then 29 bit CAN identifiers for CCP transmit messages will be supported the\n          range being [0, 536870911]. If unchecked, then CCP will support 11 bit CAN identifiers\n          the range being [0, 2047].\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCP.CONFIG.106": "The block pcp_CCPConfiguration shall support the targets:\n            All targets.",
    "LLR.PLAT.PCP.CONFIG.206": "The block pcp_CCPConfiguration shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCP.CONFIG.007": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.008": "If the parameter Receive message identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.009": "If the parameter Transmit message identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.010": "The block  shall  raise an error if Transmit message identifier\n                and Receive message identifier have been given the same ID.",
    "LLR.PLAT.PCP.CONFIG.011": "If the parameter Station address is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.012": "The block  shall  use the mask parameter Receive message identifier\n                as the Receive message identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.013": "The block  shall  use the mask parameter Transmit message identifier\n                as the Transmit message identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.014": "The block  shall  use the mask parameter Station address\n                as the ECU station address for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.015": "The block  shall  use the mask parameter CAN bus identifier\n                as the CAN bus identifier for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.016": "If the mask parameter\n                Enable CCP during model execution?\n                is true, then CCP sessions  shall  be permitted, otherwise CCP sessions shall be disabled.",
    "LLR.PLAT.PCP.CONFIG.053": "If the mask parameter\n                Use CRO extended ID? (29 bit)\n                is true, then 29 bit message identifiers  shall  be used for the Receive\n                message identifiers for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.054": "If the mask parameter\n                Use DTO extended ID? (29 bit)\n                is true, then 29 bit message identifiers  shall  be used for the Transmit\n                message identifiers for CCP sessions.",
    "LLR.PLAT.PCP.CONFIG.017": "If the pcp_CCPConfiguration block is omitted from the model\n                then the following default configuration  shall  be used:\n                Receive message identifier\n                    (CRO)  shall  be set to 1784 (6F8hex).\n                  Transmit message identifier\n                    (DTO)  shall  be set to 1785 (6F9hex).\n                  Station address shall  be set to zero.\n                  CAN bus identifier shall  be set to the first CAN bus.\n                  Enable CCP during model execution? shall  be disabled.\n                  Use CRO extended ID? (29 bit) shall  be disabled.\n                  Use DTO extended ID? (29 bit) shall  be disabled.",
    "LLR.PLAT.PCP.CONFIG.038": "The platform shall provide a Simulink interface block named\n                pcp_CCPSecurity that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionCAN bus identifierParamList\n        \n          The CAN bus for which CCP security will be implemented.  A pcp_CCPConfiguration block must\n          also exist in the design which configures CCP for this CAN bus.  If this does not exist, an error\n          will be reported.\n        \n      \n                Calibratable: no.\n              Security requiredParamBoolean\n        \n          Whether CCP seed\/key security is required for this CCP privilege level.\n        \n      \n                Calibratable: no.\n              ECU seed generator function (optional)ParamString\n        \n          If required, the name of the C function which generates the seed value.\n          If this is not specified, a random 4-byte value will be generated by the OpenECU\n          platform and used as a seed instead.\n        \n      \n                Calibratable: no.\n              ECU key validator functionParamString\n        \n          The name of the C function which validates the key value transmitted by the calibration tool.\n          If this is not specified, an error will be reported.\n        \n      \n                Calibratable: no.\n              ASAP security DLL (optional)ParamString\n        \n          If required, the name of the DLL supplying the key generation algorithm for the calibration tool.\n          This will typically only be required if the RTW build is required to generate ASAP2 (A2L) files\n          to configure the calibration tool.  If this is not specified, security will not be configured in the A2L\n          files, although typically the user will still be able to configure security manually from within the\n          calibration tool.\n        \n      \n                Calibratable: no.\n              ASAP security DLL function (optional)ParamString\n        \n          If required, the name of the function within the DLL supplying the key generation algorithm.  If\n          unspecified, this will default to using the ASAP1A\/ASAP2 standard function name ASAP1A_CCP_ComputeKeyFromSeed.\n          Note that some calibration tools do not permit the function name to be specified; see the relevant section\n          for the calibration tool to be used for further details.\n        \n      \n                Calibratable: no.\n              Algorithm development mode (unsecure)ParamBoolean\n        \n          Whether the ECU should ignore security algorithms when reprogramming mode is entered as a result of the module powering up\n          with FEPS applied.\n        \n        \n          This option allows a security algorithm to be tested without the risk of putting the ECU in a state\n          where it cannot be reprogrammed.  Otherwise, an error in the security algorithm will necessitate returning\n          the ECU to Pi for servicing.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCP.CONFIG.138": "The block pcp_CCPSecurity shall support the targets:\n            All targets.",
    "LLR.PLAT.PCP.CONFIG.238": "The block pcp_CCPSecurity shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCP.CONFIG.039": "If the parameter CAN bus identifier does not match the CAN bus specified for pcp_CCPConfig, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.040": "If two pcp_CCPSecurity blocks exist for the same CAN bus identifier, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.041": "If security is specified as required for a CCP privilege level but the ECU key validator function is not specified, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.042": "If security is specified as required for a CCP privilege level and the\n                ECU seed generator function is selected but is not specified, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.043": "If security is specified as required for a CCP privilege level and the\n                ASAP security DLL is selected but is not specified, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CONFIG.044": "If security is specified as required for a CCP privilege level, the ASAP security DLL is specified, and the\n                ASAP security DLL function is selected but is not specified, then the block  shall  raise an error.",
    "LLR.PLAT.PCP.CALBASE.001": "The platform  shall  support the CCP commands (from version 2.1 of the CCP protocol as\n              described in\n              Tools, File Formats and Communication Protocols, \u201cCCP (ASAP1b) protocol\u201d)\n              given in the following table for reprogramming (PRG) and application (APP) modes.\n            Table\u00a03.1.\u00a0Required CCP commandsCCP commandCommand valueOptionalSupported PRG modeSupported APP modeCONNECT01 (0x01)\u00a0yesyesSET_MTA02 (0x02)\u00a0yesyesDNLOAD03 (0x03)\u00a0yesyesUPLOAD04 (0x04)\u00a0yesyesTEST05 (0x05)yesyesyesSTART_STOP06 (0x06)yes\u00a0yesDISCONNECT07 (0x07)\u00a0yesyesSTART_STOP_ALL08 (0x08)yes\u00a0yesSET_S_STATUS12 (0x0C)yesyesyesGET_S_STATUS13 (0x0D)yesyesyesBUILD_CHKSUM14 (0x0E)yesyesyesSHORT_UP15 (0x0F)yesyesyesCLEAR_MEMORY16 (0x10)yesyes\u00a0GET_SEED18 (0x12)yesyes\u00a0UNLOCK19 (0x13)yesyes\u00a0GET_DAQ_SIZE20 (0x14)yes\u00a0yesSET_DAQ_PTR21 (0x15)yes\u00a0yesWRITE_DAQ22 (0x16)yes\u00a0yesEXCHANGE_ID23 (0x17)\u00a0yesyesPROGRAM24 (0x18)yesyes\u00a0GET_CCP_VERSION27 (0x1B)\u00a0yesyesPROGRAM_634 (0x22)yesyes\u00a0DNLOAD_635 (0x23)yesyesyes",
    "LLR.PLAT.PCP.CALBASE.003": "When the EXCHANGE_ID selection value is set to 0 or greater than 2, the platform\n               shall  set the MTA0 to the address of a null terminated ASCII string of the ECU family name. The ECU family\n              name matches the template \"OpenECU-[target-name]\", here target-name is M220, M250, etc.",
    "LLR.PLAT.PCP.CALBASE.004": "When the EXCHANGE_ID selection value is set to 1, if manufacturing data\n              and the manufacturing data key field is valid for an ECU,then the platform  shall  set\n              the MTA0 to point to the value of the key retrieved from the registry.",
    "LLR.PLAT.PCP.CALBASE.005": "When the EXCHANGE_ID selection value is set to 1, if manufacturing data\n              or the manufacturing data key field is not valid for an ECU, then the MTA0\n              will remain unmodified and the platform  shall  raise an error.",
    "LLR.PLAT.PCP.CALBASE.006": "In application mode when the EXCHANGE_ID selection value is set to 2, then MTA0\n               shall  point to null terminated ASCII string defined by C-API application name.",
    "LLR.PLAT.PCP.CALBASE.007": "In reprogramming mode when the EXCHANGE_ID selection value is set to 2, then the\n              platform  shall  set MTA0  to point to null terminated ASCII string of the ECU family name.",
    "LLR.PLAT.PCP.CAL.002": "On MPC5534 implementation, the reprogramming software  shall  accept DNLOAD, and\n              DNLOAD_6 commands in the following address ranges:\n            internal_ram:           origin = 0x40000000, length = 0x00f500",
    "LLR.PLAT.PCP.CAL.003": "On MPC5534 implementation, the application software  shall  accept DNLOAD, and\n              DNLOAD_6 commands in the following address ranges:\n            internal_ram:           origin = 0x40000000, length = 0x00f500",
    "LLR.PLAT.PCP.CAL.005": "On MPC5565 implementation, the address map is extended, and both the application and reprogramming software  shall  accept DNLOAD, and\n              DNLOAD_6 commands in the following address ranges:\n            data_ram:               origin = 0x40000000, length = 0x030000\nexternal_ram_1:         origin = 0x20020000, length = 0x020000\n              (Note that the data_ram area is actually composed of a mixture\n              of internal MPC5565 RAM and external SRAM mapped to continue where that leaves off,\n              but the whole range is valid for application data, and for CCP purposes.)",
    "LLR.PLAT.PCP.CAL.004": "On MPC5534 and MPC5565 implementations, if calibration ram is available in hardware, the application software  shall  accept DNLOAD, and\n              DNLOAD_6 commands in the following address ranges:\n            cal_ram:                origin = 0x40000, length = 0x40000",
    "LLR.PLAT.PCP.DISP.003": "On MPC5534 implementation, the application software  shall  accept\n              SET_MTA,\n              SHORT_UP,\n              UPLOAD,\n              BUILD_CHKSUM, and\n              WRITE_DAQ commands in the following address ranges,\n              and reject them in all other address ranges.\n            internal_ram:           origin = 0x40000000, length = 0x00f500\n\ninternal_flash:         origin = 0x00000000, length = 0x0FFFC0\n\n  \/* Note that the last section doesn't range up to the end of full\n   * internal Flash size due to errata note 1651 (don't use the last\n   * 64 bytes of internal Flash).\n   *\/",
    "LLR.PLAT.PCP.DISP.004": "On MPC5534 implementation, the reprogramming software  shall  accept\n              SET_MTA,\n              SHORT_UP,\n              UPLOAD, and\n              BUILD_CHKSUM commands in the following address ranges,\n              and reject them in all other address ranges.\n            internal_ram:           origin = 0x40000000, length = 0x00f500\n\ninternal_flash:         origin = 0x00000000, length = 0x0FFFC0\n\n  \/* Note that the last section doesn't range up to the end of full\n   * internal Flash size due to errata note 1651 (don't use the last\n   * 64 bytes of internal Flash).\n   *\/\n\npfl_shadow_flash:       origin = 0x00fffc00, length = 0x000400",
    "LLR.PLAT.PCP.DISP.006": "On MPC5565 implementation, the address map is extended, and both\n              application and reprogramming software  shall  accept\n              SET_MTA,\n              SHORT_UP,\n              UPLOAD, and\n              BUILD_CHKSUM commands in the following address ranges,\n              and reject them in all other address ranges.\n            data_ram:               origin = 0x40000000, length = 0x030000\n\nexternal_ram_1:         origin = 0x20020000, length = 0x020000\n\ninternal_flash:         origin = 0x00000000, length = 0x200000\n\npfl_shadow_flash:       origin = 0x00fffc00, length = 0x000400",
    "LLR.PLAT.PCP.DISP.005": "The platform  shall  send all DAQ periodic messages using the DTO CAN identifier.\n            Rationale: \n              This is where ATI, CANape and INCA expect DAQ reporting. Some tools\n              require a different address but we propose not to support\n              those.",
    "LLR.PLAT.CAL.FLT.001": "The platform  shall  provide displayable variables for all internal faults:\n\nmpl_flp_overflow\nmpl_flp_underflow\nmpl_flp_div_by_zero\nmpl_flp_inexact\nmpl_flp_invalid\nmpl_ecc_ram_address\nmpl_ecc_flash_address\n\n              These variables are zero at reset and become one if the\n              corresponding error have occurred.\n            Rationale: \n              Application developers need to know as much as possible\n              about application reset cause to be able to debug the\n              application.",
    "LLR.PLAT.PCP.RXCOUNT.001": "The platform  shall  initialize the number of CCP messages received\n              to 0 at initialization following a reset.",
    "LLR.PLAT.PCP.RXCOUNT.002": "The platform  shall  increment the count of received CCP messages each time\n              a CCP message is received.",
    "LLR.PLAT.PCP.RXCOUNT.003": "The platform shall provide a C interface function named\n                pcp_get_rx_count() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U32\n                with a value of:\n              A count of CCP CRO messages received since the last reset. The counter wraps modulo 4294967295.\n Range: [0, 4294967295] messages",
    "LLR.PLAT.PCP.RXCOUNT.004": "If the pcp_ccpenabled variable is nonzero the platform  shall \n                return the number of received CCP messages since reset.",
    "LLR.PLAT.PCP.RXCOUNT.005": "If the pcp_ccpenabled variable is zero the platform  shall \n                return a count of zero.",
    "LLR.PLAT.PCP.RXCOUNT.006": "",
    "LLR.PLAT.PCP.RXCOUNT.007": "The block  shall  run at the task rate specified by the Sample Rate parameter.",
    "LLR.PLAT.PCX.CONF.011": "The platform  shall  be configured to use the specified CAN bus at the specified speed.",
    "LLR.PLAT.PCX.CONF.012": "The configuration set during initialisation  shall  remain active.",
    "LLR.PLAT.PCX.CONF.001": "The platform shall provide a C interface function named\n                pcx_config() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_bus_id\n          in\n        PCX_LCHAN_T\nWhich CAN bus the message is communicated on. Use the macros included by the pio.h file, of the form PIO_CAN_[NAME].pcxf_bit_rate_kbit_s\n          in\n        PIO_CAN_BAUD_RATE_T\nRequested baud rate of CAN bus. Use the macros included by the pio.h file, of the form PIO_CBAUD_[RATE]_KBPS.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if configuration was accepted, false otherwise.",
    "LLR.PLAT.PCX.CONF.101": "The function pcx_config() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.CONF.201": "The function pcx_config() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.CONF.002": "The function  shall  return true if initialisation was successful.",
    "LLR.PLAT.PCX.CONF.003": "The function  shall  check the pcxf_bus_id is valid in\n                [0..PCX_NUM_CAN_DEVICES) and reject otherwise by returning false and\n                raising recoverable error PSY_PCX\/PCX_ERR_BUS_ID_IN_CONFIG.",
    "LLR.PLAT.PCX.CONF.004": "The function  shall  check that the baud rate is a valid baud-rate (i.e. present in the\n                enumeration) and reject otherwise by return false and raising recoverable error\n                PSY_PCX\/PCX_ERR_UNSUPPORTED_BIT_RATE.",
    "LLR.APP.PCX.CONF.001": "The application  shall  call this interface to set-up the speed of every CAN bus it uses\n                during the initialisation phase.",
    "LLR.PLAT.PCX.CONF.005": "Assuming all parameters checks pass, if the function is called for the first time, the\n                function  shall  set the baud rate to the desired rate.",
    "LLR.PLAT.PCX.CONF.006": "Assuming all parameters checks pass, if the function has already been called, the\n                function  shall  check that the new rate is equal to the old rate by returning false and\n                raising recoverable error otherwise.\n                PSY_PCX\/PCX_ERR_BIT_RATE_IN_CONFIG_DIFFERS.",
    "LLR.PLAT.PCX.CONF.007": "The platform shall provide a Simulink interface block named\n                pcx_CANConfiguration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionBit RateParamReal\n        \n          The bit rate (or baud rate) of the can bus.\n        \n        \n          Range: 33.333, 50, 62.5, 83.333, 100, 125, 250, 500 or 1000 kBps\n        \n      \n                Calibratable: no.\n              CAN Bus IdentifierParamInteger\n        \n          Which can bus the configuration applies to.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.CONF.107": "The block pcx_CANConfiguration shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.CONF.207": "The block pcx_CANConfiguration shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.CONF.008": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.CONF.009": "The block  shall  run once at initialisation on the target.",
    "LLR.PLAT.PCX.CONF.010": "The block  shall  configure the CAN bus specified by the mask\n                CAN Bus Identifier for the baud rate given by the mask\n                Bit Rate.",
    "LLR.PLAT.PCX.DECL.001": "The platform shall provide a C interface function named\n                pcx_declare_message() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_direction\n          in\n        PCX_MSG_DIR_T\nSet to PCX_TX_MSG if the message to declare is a transmit message, set to PCX_RX_MSG if its a receive message.pcxf_bus_id\n          in\n        PCX_LCHAN_T\nWhich CAN bus the message is communicated on.\n Use the macros included by the pio.h file, of the form PIO_CAN_[NAME].pcxf_use_extended_id\n          in\n        U8\nSet to PCX_EXTENDED_ID if pcxf_msg_id is an extended identifier, set to PCX_STANDARD_ID if pcxf_msg_id is a standard identifier.pcxf_msg_length\n          in\n        U8\nThe length of the CAN message data. For receive messages only, PCX_ANY_MSG_LENGTH may be specified to accept any message length.\n Range: [0, 8] or PCX_ANY_MSG_LENGTH pcxf_msg_id\n          in\n        U32\nThe CAN message identifier.\n Range: [0, 2047] if standard identifier\n Range: [0, 536870911] if extended identifier\n Or: PCX_ANY_CAN_ID if declaring the CAN bus can receive or transmit a CAN message with any message identifier. \n                The function returns a value of type\n                PCX_HANDLE_T\n                with a value of:\n              An integer handle if the message was accepted or PCX_CONFIG_ERROR if the message was rejected. If rejected, the CAN message will not be transmitted or received for the specified bus (pcxf_bus_id).\n\n The message is rejected if any of the following conditions arises:\npcxf_bus_id is outside its valid rangepcxf_msg_length is outside its valid rangeif the message ID is standard but outside its valid rangeif the message ID is extended but outside its valid rangetoo many transmit messages have been declaredtoo many receive messages have been declared",
    "LLR.PLAT.PCX.DECL.101": "The function pcx_declare_message() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.DECL.201": "The function pcx_declare_message() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.DECL.002": "The function return  shall  be PCX_CONFIG_ERROR if any error condition\n              is detected, and the handle for the message otherwise.",
    "LLR.PLAT.PCX.DECL.003": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_BUS_ID_OUT_OF_RANGE if the specified\n              pcx_bus_id is not supported.",
    "LLR.PLAT.PCX.DECL.004": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_DATA_LENGTH_OUT_OF_RANGE if the specified\n              pcxf_msg_length is more than 8.",
    "LLR.PLAT.PCX.DECL.005": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_STD_ID_OUT_OF_RANGE if the specified\n              pcxf_msg_id is more the 2^11-1 and\n              pcxf_use_extended_id is false.",
    "LLR.PLAT.PCX.DECL.006": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_EXT_ID_OUT_OF_RANGE if the specified\n              pcxf_msg_id is more the 2^29-1 and\n              pcxf_use_extended_id is true.",
    "LLR.PLAT.PCX.DECL.007": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_SAME_TX_MSG_DIFFERING_ATTRIBS if the same transmit\n              message is specified more than once. The declaration  shall  be updated to allow for the\n              longest message length. This is not considered an error and the handle of the previous\n              declaration is returned.",
    "LLR.PLAT.PCX.DECL.008": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_TOO_MANY_TX_MSGS if too many transmit messages have\n              been declared. This limit is the number allowed in the capi\n              configuration file.",
    "LLR.PLAT.PCX.DECL.010": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_DUPLICATE_RX_MSG if the same receive message is\n              specified more than once.",
    "LLR.PLAT.PCX.DECL.011": "The function  shall  raise the recoverable error\n              PSY_PCX\/PCX_ERR_TOO_MANY_RX_MSGS if too many receive messages have\n              been declared. This limit is the number allowed in the capi\n              configuration file.",
    "LLR.APP.PCX.DECL.001": "The application  shall  call this platform function to obtain the handle of each message\n              prior to use with pcx_transmit or pcx_receive.\n            Rationale: \n              Hardware must be configured to allow transmission or reception of messages on the CAN\n              bus.",
    "LLR.PLAT.PCX.DECL.012": "The platform  shall  configure the underlying hardware to allow transmission and reception\n              with the given CAN Id on the specified bus.",
    "LLR.PLAT.PCX.BUSAVAIL.005": "The platform  shall  detect if the specified bus is unavailable.",
    "LLR.PLAT.PCX.BUSAVAIL.001": "The platform shall provide a C interface function named\n                pcx_is_bus_unavailable() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_bus_id\n          in\n        PCX_LCHAN_T\nThe CAN bus to inspect. \n Use the macros included by the pio.h file, of the form PIO_CAN_[NAME].\n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if the CAN bus is in an error condition (bus off), false otherwise.",
    "LLR.PLAT.PCX.BUSAVAIL.101": "The function pcx_is_bus_unavailable() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.BUSAVAIL.201": "The function pcx_is_bus_unavailable() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.BUSAVAIL.002": "The function  shall  return true if the specified bus is unavailable or false otherwise.",
    "LLR.PLAT.PCX.BUSAVAIL.003": "The function  shall  return true if the bus does not exist.",
    "LLR.PLAT.PCX.BUSAVAIL.004": "If the parameters pass then the function  shall  return true if the bus is unavailable.",
    "LLR.PLAT.PCX.BUSAVAIL.006": "The platform shall provide a Simulink interface block named\n                pcx_CANStatus that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_can0_bus_offInportBoolean\n        \n          Only used during\n          simulation. Set to 1 to simulate a CAN bus off state for CAN bus 0, zero\n          otherwise. Only available if the mask parameter Provide simulation input\n          is checked.\n        \n      sim_can1_bus_offInportBoolean\n        \n          Only used during\n          simulation. Set to 1 to simulate a CAN bus off state for CAN bus 1, zero\n          otherwise. Only available if the mask parameter Provide simulation input\n          is checked.\n        \n      can0_bus_offOutportBoolean\n        \n          Set to 1 if can bus 0 is\n          currently bus off, 0 otherwise.\n        \n      can1_bus_offOutportBoolean\n        \n          Set to 1 if can bus 1 is\n          currently bus off, 0 otherwise.\n        \n      Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inputParamBoolean\n        \n          If selected then simulation inputs for each of the can bus off\n          outports are provided by the block.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.BUSAVAIL.106": "The block pcx_CANStatus shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.BUSAVAIL.206": "The block pcx_CANStatus shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.BUSAVAIL.007": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PCX.BUSAVAIL.008": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PCX.BUSAVAIL.009": "If the parameter Provide simulation input is selected, then the block\n                 shall  provide inports for each available CAN bus to simulate bus off conditions, otherwise no inports shall\n                appear on the block.",
    "LLR.PLAT.PCX.BUSAVAIL.010": "The block  shall  write the simulated bus off value to the corresponding CAN bus, bus off outport.",
    "LLR.PLAT.PCX.BUSAVAIL.011": "The block  shall  write the value indicating bus off condition of each CAN bus to the outports\n                can0_bus_off and\n                can1_bus_off.",
    "LLR.PLAT.PCX.BUSSTATE.001": "The platform when requested  shall  return PCX_BUS_ERROR_ACTIVE if the CAN controller is in\n              an error-active state.\n            Note: \n              The enumerations represent the states provided in the CAN specification\n              (see section 7 of https:\/\/apple.ps.local\/svn\/OpenECU\/ref\/communications\/can_specification\/can2spec.pdf).\n              ERROR-ACTIVE means the CAN node is participating in error detection but has not yet found enough errors to move to the ERROR-PASSIVE or BUS-OFF states.",
    "LLR.PLAT.PCX.BUSSTATE.002": "The platform when requested  shall  return PCX_BUS_ERROR_PASSIVE if the CAN controller is in\n              an error-passive state.",
    "LLR.PLAT.PCX.BUSSTATE.003": "The platform when requested  shall  return PCX_BUS_OFF if the CAN controller is in\n              a bus-off state, or if the feature is delaying further transmissions\n              to avoid over stressing the CAN bus with error events.",
    "LLR.PLAT.PCX.BUSSTATE.004": "The platform shall provide a C interface function named\n                pcx_get_bus_state() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_bus_id\n          in\n        PCX_LCHAN_T\nThe CAN bus to inspect. \n Use the macros included by the pio.h file, of the form PIO_CAN_[NAME].\n                The function returns a value of type\n                PCX_BUS_STATE_T\n                with a value of:\n              One of the PCX_BUS_STATE_T enumerations.",
    "LLR.PLAT.PCX.BUSSTATE.104": "The function pcx_get_bus_state() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.BUSSTATE.204": "The function pcx_get_bus_state() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.BUSSTATE.005": "The function  shall  return PCX_BUS_INVALID if the pcxf_bus_id\n                parameter does not map to any of busses available.",
    "LLR.PLAT.PCX.BUSSTATE.006": "The platform  shall  use the parameter pcxf_bus_id as the ID of the bus who's status should be\n                reported.",
    "LLR.PLAT.PCX.BUSSTATE.007": "The platform  shall  return the error state of type PCX_BUS_STATE_T.",
    "LLR.PLAT.PCX.BUSSTATE.008": "The platform shall provide a Simulink interface block named\n                pcx_BusStatus that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_bus_stateInportInteger\n        \n          A dummy input for simulation purposes only. Set to zero to simulate an\n          error-active state, set to 1 to simulate an error-passive state, and set\n          to 2 to simulate a bus-off state. Only available if the mask parameter\n          Provide simulation inputs is checked.\n        \n      bus_stateOutportInteger\n        \n          Set to zero if the CAN bus selected through mask parameter\n          CAN Bus Identifier is in the error-active\n          state, set to 1 if in the error-passive state, and set\n          to 2 if in the bus-off state.\n        \n        \n          Range: [0, 2]\n        \n      CAN Bus IdentifierParamList\n        \n          Which CAN bus to provide error state information about.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inputsParamBoolean\n        \n          If selected then simulation inport sim_bus_state\n          is made available.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.BUSSTATE.108": "The block pcx_BusStatus shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.BUSSTATE.208": "The block pcx_BusStatus shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.BUSSTATE.009": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PCX.BUSSTATE.013": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PCX.BUSSTATE.010": "The value of inport sim_bus_state  shall  be written to outport\n                bus_state.",
    "LLR.PLAT.PCX.BUSSTATE.011": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PCX.BUSSTATE.012": "The block  shall  update the outport bus_state with\n                the status of the CAN bus specified by the mask parameter CAN Bus Identifier.",
    "LLR.APP.PCX.PACK.001": "The application  shall  pass the data to be packed and data describing data position, size,\n              sign and original type.",
    "LLR.PLAT.PCX.PACK.006": "When parameter checks have passed, the function  shall  write the input values aligned with the\n              specified field positions and lengths.\n            \n              The start position defines the position of the field as follows:\n              \n                    For fields with lengths ranging from 1 to 15 bits, the start address defines where\n                    the message's least significant bit is stored.\n                  \n                    For fields with lengths more than or equal to 16 bits, the start address defines\n                    where the message's most significant bit is stored.",
    "LLR.PLAT.PCX.PACK.061": "The data type is F32 and signed, the platform  shall  clip the data between the minimum and maximum value that can be\n              represented with a signed 32 bit number.",
    "LLR.PLAT.PCX.PACK.062": "The data type is F32 and unsigned, the platform  shall  clip the data between zero and maximum value that can be represented\n              with an unsigned 32 bit number.",
    "LLR.PLAT.PCX.PACK.050": "Once the data has been successfully packed, the platform  shall  transmit the data on the specified CAN bus.\n            Note: \n              See the section, pcx_transmit for details.",
    "LLR.PLAT.PCX.PACK.046": "The platform  shall  set the error flag to 1 if a transmit error is detected and 0 otherwise.",
    "LLR.PLAT.PCX.PACK.047": "The platform  shall  update the request count each time the application requests that a message be transmitted.",
    "LLR.PLAT.PCX.PACK.048": "The platform  shall  update the overwrite count each time the application requests that a message be transmitted and has not\n              transmitted the previous message.",
    "LLR.PLAT.PCX.PACK.049": "The platform  shall  update the acknowledge count each time the application transmits a message and gets an acknowledge back.",
    "LLR.PLAT.PCX.TX.001": "The platform shall provide a C interface function named\n                pcx_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_msg_handle\n          in\n        PCX_HANDLE_T\nHandle to message to queue (as returned by calling pcx_declare_message()).\n Range: [0, length(pcx_tx_msg) - 1]pcxf_msg_data\n          in\n        const U8 *\nPointer to location of CAN message transmit data. \n Cannot be NULL.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if no error in transmission, false otherwise.",
    "LLR.PLAT.PCX.TX.101": "The function pcx_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.TX.201": "The function pcx_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.TX.003": "The function  shall  check that the handle pcxf_msg_handle is valid\n              (previously returned by pcx_declare_message as transmit) and return\n              false otherwise.",
    "LLR.PLAT.PCX.TX.004": "The function  shall  check that the pointer to the message in\n              pcxf_msg_data is not NULL and return false\n              otherwise.",
    "LLR.PLAT.PCX.TX.030": "During initialisation, the platform  shall  clear the 'tx-requests',\n              'tx-overwrites' and 'tx-acks' counters to zero.",
    "LLR.PLAT.PCX.TX.031": "When the application requests a message is transmitted, the platform  shall \n              increment counter 'tx-requests' by 1, modulo 65536.",
    "LLR.PLAT.PCX.TX.032": "When the application requests a message is transmitted but the message cannot\n              immediately be accepted by the CAN controller, the platform  shall \n              increment counter 'tx-overwrites' by 1, modulo 65536.",
    "LLR.PLAT.PCX.TX.033": "When the application requests a message is transmitted and the message is\n              eventually transmitted and then acknowledged by at least one other CAN node\n              on the CAN bus, the platform  shall  increment counter 'tx-acks' by 1, modulo 65536.",
    "LLR.APP.PCX.TX.001": "The application  shall  declare a message and obtain a handle for that message before using\n              this function.",
    "LLR.PLAT.PCX.TX.005": "If the queue isn't full, the function  shall  queue the message and transmit the message when\n              bus is available in priority order and return true.",
    "LLR.PLAT.PCX.TX.006": "If a message is queued with the same CAN Id to one currently queued, the platform  shall \n              only send the last value and return false.",
    "LLR.PLAT.PCX.TX.007": "The return value  shall  be false if the bus is currently in bus-off condition.",
    "LLR.PLAT.PCX.PACK.001": "The platform shall provide a C interface function named\n                pcx_pack_msg() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_msg_data\n          out\n        U8 *\nPointer to an array of data bytes to be set (the array must be 8 bytes in length, if it is too small, this function will write off the end of the array). Unspecified fields are set to zero. \n Cannot be NULL.pcxf_item_ptr\n          in\n        const void *const *\nPointer to array of pointers to data to be packed, the type of the final pointed to data is defined by the array pcxf_type_code. \n Cannot be NULL.pcxf_field_start\n          in\n        const U8 *\nPointer to array of field start bit numbers. For each item to pack into pcxf_msg_data, the function determines where to place the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 0 of the message and 63 to the most significant bit of data byte 7 of the message, assuming these exist. For items whose bit length entry exceeds 7, the bit length must be one of: 0, 8, 16, 24, 32, 40, 48, 56. \n For fields with lengths ranging from 1 to 15 bits, the start address defines where the message's least significant bit is stored. \n For fields with lengths more than or equal to 16 bits, the start address defines where the message's most significant bit is stored. \n Cannot be NULL.pcxf_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to pack into pcxf_msg_data, the function determines how many bits to place into the array using the corresponding element from this array. The following values are allowed: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24 and 32. Items of 8 bits or fewer may not be defined so as to straddle CAN byte boundaries. \n Cannot be NULL.pcxf_is_signed\n          in\n        const U8 *\nPointer to array of sign flags (flag set true if signed, false otherwise). For each item to pack into pcxf_msg_data, the function determines whether to use the MSB of the packed data as a sign bit or not. If the item is negative but specified in this array as unsigned, the item is clipped to zero. \n Cannot be NULL.pcxf_type_code\n          in\n        const U8 *\nPointer to array of data type codes. Each element determines the data type of each element in pcxf_item_ptr. The type of each element is one of: PCX_TYPECODE_F32, PCX_TYPECODE_BOOL, PCX_TYPECODE_S8, PCX_TYPECODE_U8, PCX_TYPECODE_S16, PCX_TYPECODE_U16, PCX_TYPECODE_S32, PCX_TYPECODE_U32. The data storage for a boolean type depends on the pcxf_use_bool_type argument. \n Cannot be NULL.pcxf_use_bool_type\n          in\n        const U8\nTrue if boolean types are stored as 8-bit integers, false clear if boolean types are stored as 32-bit floating point.pcxf_num_fields\n          in\n        const U8\nNumber of fields in each of pcxf_item_ptr, pcxf_field_start, pcxf_field_width, pcxf_is_signed, and pcxf_type_code. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument. \n Range: [1, 255] fields\n                The function returns void.",
    "LLR.PLAT.PCX.PACK.101": "The function pcx_pack_msg() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.PACK.201": "The function pcx_pack_msg() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.PACK.002": "The function  shall  reject calls with an NULL pointer is any of the following parameters\n                pcxf_msg_data, pcxf_item_ptr,\n                pcxf_field_start, pcxf_field_width,\n                pcxf_is_signed or pcxf_type_code by raising a\n                recoverable error PSY_PCX\/PCX_ERR_PACK_MSG_INVALID_PARAM.",
    "LLR.PLAT.PCX.PACK.003": "The function  shall  reject calls with an invalid type-code in the\n                pcxf_type_code parameter array by raising a recoverable error\n                PSY_PCX\/PCX_ERR_PACK_MSG_FIELD_PARAM.\n              \n                The data type must be one of the following to ensure correct operation:\n              \n                Bool, S8, U8, S16, U16, S32, U32, F32",
    "LLR.PLAT.PCX.PACK.004": "The function  shall  reject calls with an invalid field width in\n                pcx_msg_field_width by raising a recoverable error\n                PSY_PCX\/PCX_ERR_PACK_MSG_FIELD_PARAM.",
    "LLR.PLAT.PCX.PACK.005": "The function  shall  skip an item and raise a recoverable error\n                PSY_PCX\/PCX_ERR_PACK_MSG_FIELD_PARAM, when the item width is 8 bits\n                or less and the data straddles a CAN boundary.",
    "LLR.PLAT.PCX.PACK.060": "The platform  shall  clip the input data to the range defined by pcxf_eng_min\n                and pcxf_eng_max when pcxf_clip_scaled is true.",
    "LLR.PLAT.PCX.PACK.043": "The platform shall provide a C interface function named\n                pcx_get_transmit_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_msg_handle\n          in\n        PCX_HANDLE_T\nThe message handle that refers to the transmit CAN message (as returned from calling pcx_declare_message()).\n Range: [0, length(pcx_rx_msg) - 1]pcxf_tx_requests\n          out\n        U16 *\nPointer to storage written with the count of transmission requests made by the application for this message.\n The counter wraps modulo 65536 and does not saturate.\n Cannot be NULL.\n Range: [0, 65535] eventspcxf_tx_overwrites\n          out\n        U16 *\nPointer to storage written with the count of transmission requests which were queued by the software for later transmission because the CAN controller could not immediately accept the message for transmission.\n The counter wraps modulo 65536 and does not saturate.\n Cannot be NULL.\n Range: [0, 65535] eventspcxf_tx_acks\n          out\n        U16 *\nPointer to storage written with the count of message transmissions successfully made by the CAN controller (i.e., those transmit messages which were acknowledged by at least one CAN node on the bus, not including the transmitting node).\n The counter wraps modulo 65536 and does not saturate.\n Cannot be NULL.\n Range: [0, 65535] events\n                The function returns a value of type\n                PCX_RC_T\n                with a value of:\n              PCX_RC_OK - if the status information could be retrievedPCX_RC_BAD_ARGS - if one of the parameters was invalid",
    "LLR.PLAT.PCX.PACK.143": "The function pcx_get_transmit_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.PACK.243": "The function pcx_get_transmit_status() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.PACK.044": "The function  shall  reject calls with an NULL pointer is any of the following parameters\n                pcxf_tx_requests, pcxf_tx_overwrites,\n                or pcxf_tx_acks by returning PCX_RC_BAD_ARGS.",
    "LLR.PLAT.PCX.PACK.045": "The function  shall  reject calls with apcxf_msg_handle is set to PCX_CONFIG_ERROR\n                or is not less than pcxl_tot_decl_msg_tx by returning PCX_RC_BAD_ARGS.",
    "LLR.PLAT.PCX.PACK.070": "If the interface parameter checks pass then the function  shall  write through\n                pcxf_tx_requests the counter 'tx-requests'",
    "LLR.PLAT.PCX.PACK.071": "If the interface parameter checks pass then the function  shall  write through\n                pcxf_tx_overwrites the counter 'tx-overwrites'",
    "LLR.PLAT.PCX.PACK.072": "If the interface parameter checks pass then the function  shall  write through\n                pcxf_tx_acks the counter 'tx-acks'",
    "LLR.PLAT.PCX.PACK.007": "The platform shall provide a Simulink interface block named\n                pcx_CANTransmitMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          error_flag in simulation.\n        \n      sim_request_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          request_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      sim_overwrite_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          overwrite_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      sim_ack_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          ack_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if some error has\n          occurred which prevents CAN transmission, otherwise set to 0.\n        \n        TypeConditions setting outport error_flag to 1run timethe message has been queued waiting for a transmit buffer to become availablerun timethe bus is in bus off stateconfigurationthe bus has not been configuredconfigurationmessage not configured, because too many transmit messages\n      request_countOutportInteger\n        \n          A free running count of the application requests to transmit a message.\n          The counter wraps to zero at its maximum.\n          Only available if the mask parameter Provide Transmission Status\n          is selected.\n        \n      overwrite_countOutportInteger\n        \n          A free running count of\n          transmission requests which were queued by the software for later transmission\n          because the CAN controller could not immediately accept the message for transmission.\n          A queued message can be overwritten by subsequent attempts to transmit the same\n          message (for instance, if the CAN bus is heavily loaded and the transmission rate\n          high, the CAN controller may not be able to transmit the message before the application\n          requests it is sent again, possibly with different data control from the previous\n          request). Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      ack_countOutportInteger\n        \n          A free running count of message\n          transmissions successfully made by the CAN controller (i.e., those transmit messages\n          which were acknowledged by at least one CAN node on the bus, not including the\n          transmitting node). Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      Message IdentifierParamInteger\n        \n          The unique can\n          identifier of the message to be transmitted.\n        \n        \n          Range: [0, 2047] if standard identifier\n        \n        \n          Range: [0, 536870911] if extended identifier\n        \n      \n                Calibratable: no.\n              Message LengthParamInteger\n        \n          The number of data bytes to be transmitted.\n        \n        \n          Range: [0, 8] bytes\n        \n      \n                Calibratable: no.\n              Field Start Bit PositionsParamInteger\n        \n          A vector of\n          bit numbers indicating the position at which each input Item begins in the CAN\n          message. 0 corresponds to the least significant bit of data byte 0 of the message\n          and 63 to the most significant byte of data byte 7 of the message, assuming these\n          exist. For items whose bit length entry exceeds 7, the bit length must be one of:\n          0, 8, 16, 24, 32, 40, 48, 56.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: [0, 8], 16, 24, 32, 40, 48, 56 bit positions\n        \n      \n                Calibratable: no.\n              Field WidthsParamInteger\n        \n          A vector of bit lengths\n          indicating the number of bits used to transmit each input Item. The following\n          values are allowed: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24 and\n          32. Items of 8 bits or fewer may not be defined so as to straddle CAN byte boundaries.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: [1, 16], 24 or 32 bit width\n        \n      \n                Calibratable: no.\n              Field SignsParamInteger\n        \n          A vector of 1 or 0\n          values. Corresponding data items for which this is set 1 are transmitted as\n          twos-complement signed numbers, or unsigned numbers otherwise.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Type CodesParamInteger\n        \n          This block provides one data\n          field input for each element in Field Start Positions, as given in\n          Table\u00a03.4, \u201cCAN block type codes\u201d.\n        \n      \n                Calibratable: no.\n              Field MnemonicsParamString\n        \n          A string containing a\n          comma-separated list of names with which to label the simulation input and CAN\n          data output ports.\n        \n      \n                Calibratable: no.\n              CAN Bus IdentifierParamList\n        \n          Which can bus the\n          message will be transmitted on.\n        \n      \n                Calibratable: no.\n              Use Extended Message Identifier?ParamBoolean\n        \n          If box\n          is checked the 29 bit identifier is to be used, otherwise the 11 bit standard\n          identifier is to be used.\n        \n      \n                Calibratable: no.\n              Provide Transmission StatusParamBoolean\n        \n          If selected then outports request_count, overwrite_count and\n          ack_count, and their corresponding simulation inports, are made available.\n        \n      \n                Calibratable: no.\n              Provide Simulation Output?ParamBoolean\n        \n          If selected then dummy outputs for each of the inport can\n          message signals, such as sim_signal_name, are provided by\n          the block.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.PACK.107": "The block pcx_CANTransmitMessage shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.PACK.207": "The block pcx_CANTransmitMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.PACK.009": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.010": "If Use Extended Message Identifier? is selected then the\n                block  shall  check that the Message Identifier\n                lies in the extended range. If it is not then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.011": "If Use Extended Message Identifier? is un-selected then the\n                interface  shall  check that the Message Identifier\n                lies in the normal range. If it is not then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.012": "If the parameter Message Length is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.013": "If any of the elements in the Field Start Bit Positions array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.014": "If any of the elements in the Field Widths array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.015": "If any of the elements in the Field Signs array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.016": "If any of the elements in the Type Codes array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.017": "If overlapping fields are found, the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.018": "If the size of the packed data exceeds Message Length,\n                the block  shall  raise an error.",
    "LLR.PLAT.PCX.PACK.040": "If any of the following arrays are not integers then the block  shall  raise an error:\n                Field Start Bit PositionsField WidthsField SignsType Codes",
    "LLR.PLAT.PCX.PACK.041": "If any of the following arrays differ in length then the block  shall  raise an error:\n                Field Start Bit PositionsField WidthsField SignsType Codes",
    "LLR.PLAT.PCX.PACK.019": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PCX.PACK.020": "If parameter Provide simulation output?\n                is true then the signals specified by the\n                mask array, Field Mnemonics  shall  appear on inports and\n                outports otherwise these outports shall not exist (the inports would still exist though).",
    "LLR.PLAT.PCX.PACK.025": "If parameter Provide simulation output?\n                is true then the inports specified by the\n                mask array, Field Mnemonics  shall  be written to\n                the corresponding outports.",
    "LLR.PLAT.PCX.PACK.021": "The inport, sim_error_flag  shall  be used to drive the outport,\n                error_flag.",
    "LLR.PLAT.PCX.PACK.030": "The inport, sim_request_count  shall  be used to drive the outport,\n                request_count.",
    "LLR.PLAT.PCX.PACK.031": "The inport, sim_overwrite_count  shall  be used to drive the outport,\n                overwrite_count.",
    "LLR.PLAT.PCX.PACK.032": "The inport, sim_ack_count  shall  be used to drive the outport,\n                ack_count.",
    "LLR.PLAT.PCX.PACK.042": "During initialisation the block  shall  acquire a handle for the transmit message, using the mask parameters\n                CAN Bus Identifier,\n                Use Extended Message Identifier?,\n                Message Length and\n                Message Identifier to specify the CAN bus,\n                standard\/extended ID flag, message length and message ID respectively.",
    "LLR.PLAT.PCX.PACK.022": "The block  shall  pack the data present on the inports defined by\n                Field Mnemonics prior to transmission.",
    "LLR.PLAT.PCX.PACK.023": "The block  shall  use the mask parameters\n                Field Start Bit Positions,\n                Field Widths,\n                Field Signs and\n                Type Codes for the parameters specifying the\n                field start position, width, signs and type codes when packing the data into a CAN message. In addition the\n                block also uses the number of fields calculated when packing the data.",
    "LLR.PLAT.PCX.PACK.026": "The block  shall  transmit the packed inport data values using the handle acquired for that message at\n                initialisation.",
    "LLR.PLAT.PCX.PACK.024": "The block  shall  set the outport, error_flag to 1\n                if the message is not successfully transmitted and set to 0 otherwise.",
    "LLR.PLAT.PCX.PACK.027": "The block  shall  set the outport, request_count to\n                the request count reported by the platform.",
    "LLR.PLAT.PCX.PACK.028": "The block  shall  set the outport, overwrite_count to\n                the overwrite count reported by the platform.",
    "LLR.PLAT.PCX.PACK.029": "The block  shall  set the outport, ack_count to\n                the acknowledge count reported by the platform.",
    "LLR.APP.PCX.VDB_PACK.001": "The application  shall  pass the data to be packed and parameters describing data\n              position, size, minimum and maximum range, scaling parameters (offset and scaling\n              factor), flag indicating whether range check should be performed and the data type\n              of the packed value.",
    "LLR.PLAT.PCX.VDB_PACK.011": "The platform  shall  provide means of limiting the input data to a defined range.",
    "LLR.PLAT.PCX.VDB_PACK.012": "The platform  shall  provide means of scaling the input data.",
    "LLR.PLAT.PCX.VDB_PACK.005": "The platform  shall  set integer input data items to 0 when the input scaling factor is 0.",
    "LLR.PLAT.PCX.VDB_PACK.013": "The platform  shall  pack the input data MS or LS bit first depending on the specified\n              packing order.",
    "LLR.PLAT.PCX.VDB_PACK.009": "The platform  shall  clip the packed data item to its specified bit width.",
    "LLR.PLAT.PCX.VDB_PACK.025": "The platform  shall  acquire CAN data using pcx_transmit() - see requirements in section \"CAN Message Pack - Pi Format and Transmit\".",
    "LLR.PLAT.PCX.VDB_PACK.001": "The platform shall provide a C interface function named\n                pcx_vdb_pack_msg() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_item_ptr\n          in\n        const F32 *const *\nPointer to array of pointers to data to be packed. Each data item is stored as a 32-bit float. \n Cannot be NULL.pcxf_msg_data\n          out\n        U8 *\nPointer to an array of data bytes to be set (the array must be 8 bytes in length, if it is too small, this function will write off the end of the array). All unwritten fields are set to zero. \n Cannot be NULL.pcxf_field_start\n          in\n        const U8 *\nPointer to array of field start bit numbers. For each item to pack into pcxf_msg_data, the function determines where to place the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 0 of the message and 63 to the most significant bit of data byte 7 of the message, assuming these exist. \n Cannot be NULL.pcxf_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to pack into pcxf_msg_data, the function determines how many bits to place into the array using the corresponding element from this array. \n Cannot be NULL. \n Element range: [1, 32] bitspcxf_is_signed\n          in\n        const U8 *\nUnused. Set to NULL.pcxf_valtype\n          in\n        const U8 *\nPointer to array of data type codes. Each element can be one of: PCX_VAL_INT, and PCX_VAL_FLOAT32. \n Cannot be NULL.pcxf_order\n          in\n        const U8 *\nPointer to array of data type byte storage order. Each element can be one of: PCX_MSB_ORDER, and PCX_LSB_ORDER. \n Cannot be NULL.pcxf_eng_min\n          in\n        const F32 *\nPointer to array of engineering minimum values. For each item to pack into pcxf_msg_data, the function clips the item to the corresponding minimum element from this array if pcxf_clip_scaled is true. \n Cannot be NULL.pcxf_eng_max\n          in\n        const F32 *\nPointer to array of engineering maximum values. For each item to pack into pcxf_msg_data, the function clips the item to the corresponding maximum element from this array if pcxf_clip_scaled is true. \n Cannot be NULL.pcxf_scale\n          in\n        const F32 *\nPointer to array of divisors. For each integer item to pack into pcxf_msg_data, the function subtracts an offset specified by pcxf_offset and scales the item by the corresponding divisor in this array. \n Cannot be NULL.pcxf_offset\n          in\n        const F32 *\nPointer to array of adders. For each integer item to pack into pcxf_msg_data, the function subtracts the offset specified by this array and scales the item by the corresponding divisor in pcxf_scale. \n Cannot be NULL.pcxf_clip_scaled\n          in\n        const U8\nTrue if each data item should be clipped to the minimum and maximum specified by pcxf_eng_min and pcxf_eng_max, otherwise false if no clipping is to be performed.pcxf_use_bool_type\n          in\n        const U8\nUnused. Set to false.pcxf_num_fields\n          in\n        const U8\nNumber of fields in each of pcxf_item_ptr, pcxf_field_start, pcxf_field_width, pcxf_is_signed, pcxf_valtype, pcxf_order, pcxf_eng_min, pcxf_eng_max, pcxf_scale and pcxf_offset. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument.\n                The function returns void.",
    "LLR.PLAT.PCX.VDB_PACK.101": "The function pcx_vdb_pack_msg() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.VDB_PACK.201": "The function pcx_vdb_pack_msg() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.VDB_PACK.002": "The function  shall  reject calls with a NULL pointer in any of the following parameters\n                pcxf_item_ptr, pcxf_msg_data,\n                pcxf_field_start, pcxf_field_width,\n                pcxf_valtype, pcxf_order,\n                pcxf_eng_min, pcxf_eng_max,\n                pcxf_scale or pcxf_offset by raising the\n                recoverable error PSY_PCX\/PCX_ERR_PACK_VDB_MSG_INVALID_PARAM.",
    "LLR.PLAT.PCX.VDB_PACK.003": "The platform  shall  clip the input data to the range defined by pcxf_eng_min\n                and pcxf_eng_max when pcxf_clip_scaled is true.",
    "LLR.PLAT.PCX.VDB_PACK.004": "The platform  shall  scale items specified as integer types (by the pcxf_valtype\n                parameter) according to the pcxf_offset and pcxf_scale\n                values.",
    "LLR.PLAT.PCX.VDB_PACK.006": "The platform  shall  clip positive integer data to the maximum value represented by\n                an unsigned 32 bit integer.",
    "LLR.PLAT.PCX.VDB_PACK.007": "The platform  shall  clip negative integer data to the minimum value represented by\n                a signed 32 bit integer.",
    "LLR.PLAT.PCX.VDB_PACK.008": "The platform  shall  pack data LS bit first if pcxf_order is set to\n                PCX_LSB_ORDER and MS bit first otherwise.",
    "LLR.PLAT.PCX.VDB_PACK.010": "When all parameter checks pass, the function  shall  write in pcxf_msg_data\n                the input values aligned with the specified field positions and lengths.",
    "LLR.PLAT.PCX.VDB_PACK.014": "The platform shall provide a Simulink interface block named\n                pcx_CANdb_TransmitMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          error_flag in simulation.\n        \n      sim_request_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          request_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      sim_overwrite_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          overwrite_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      sim_ack_countInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          ack_count in simulation. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if some error has\n          occurred which prevents CAN transmission, otherwise set to 0.\n        \n        TypeConditions setting outport error_flag to 1run timethe message has been queued waiting for a transmit buffer to become availablerun timethe bus is in bus off stateconfigurationthe bus has not been configuredconfigurationmessage not configured, because too many transmit messages\n      request_countOutportInteger\n        \n          A free running count of the application requests to transmit a message.\n          The counter wraps to zero at its maximum. Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      overwrite_countOutport-\n        \n          A free running count of\n          transmission requests which were queued by the software for later transmission\n          because the CAN controller could not immediately accept the message for transmission.\n          A queued message can be overwritten by subsequent attempts to transmit the same\n          message (for instance, if the CAN bus is heavily loaded and the transmission rate\n          high, the CAN controller may not be able to transmit the message before the application\n          requests it is sent again, possibly with different data control from the previous\n          request). Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            ack_countOutportInteger\n        \n          A free running count of message\n          transmissions successfully made by the CAN controller (i.e., those transmit messages\n          which were acknowledged by at least one CAN node on the bus, not including the\n          transmitting node). Only available if the mask\n          parameter Provide Transmission Status is selected.\n        \n      CANdb fileParamString\n        \n          The name of the candb file;\n          can be relative to the model directory (i.e., the current workspace directory) or\n          absolute. Only textual CANdb files are accepted (see restrictions in the notes\n          section below).\n        \n      \n                Calibratable: no.\n              Message NameParamString\n        \n          The name of the message to\n          transmit. The name must be specified in the CANdb file and must match case (e.g.,\n          message name EngineRPM is different from message name\n          enginerpm).\n        \n      \n                Calibratable: no.\n              Signal NamesParamString\n        \n          A comma separated list of\n          signal names to pack into the message (e.g., \"name1,name2\" without the\n          quotes). An empty list of names is supported, in which case the block\n          shows no additional outports.\n        \n      \n                Calibratable: no.\n              Input All Message Signals?ParamBoolean\n        \n          If selected\n          then all signals from the message are created as inports (similarly simulation\n          outports if required), if unselected then only those signals in the signal names\n          field are created as inports.\n        \n        \n          If this field is ticked and the dialog closed, next time this field is unticked,\n          the signal names field will contain the complete list of signals. This mechanism is\n          useful when filling in the dialog for the first time but you are unsure of the field\n          names (e.g., open block, fill in CANdb file name, message name and CAN bus, then\n          tick this field, close the dialog, then select the block again, untick this field,\n          then edit the list of required signals).\n        \n      \n                Calibratable: no.\n              Clip Signals To Engineering Limits?ParamBoolean\n        \n          If selected then each signal shall be clipped to their engineering limits.\n        \n      \n                Calibratable: no.\n              Display Signal Units?ParamBoolean\n        \n          If selected then each of the can message inport signals (and simulation\n          outport signals) show their engineering units, if the CANdb file defines those\n          units.\n        \n      \n                Calibratable: no.\n              CAN Bus IdentifierParamList\n        \n          Which can bus the\n          message will be transmitted on.\n        \n      \n                Calibratable: no.\n              Provide Transmission StatusParamBoolean\n        \n          If selected then outports request_count, overwrite_count and\n          ack_count, and their corresponding simulation inports, are made available.\n        \n      \n                Calibratable: no.\n              Checksum typeParamList\n        \n          A drop-down selection\n          of the type of checksum to apply to the last\n          raw byte in the message, computed over all of the\n          preceding raw bytes in the message (even if they\n          are not used by any signals). The default is None,\n          and the other currently supported option is the\n          8-bit CRC defined by SAE-J1850.\n        \n      \n                Calibratable: no.\n              Provide Simulation Output?ParamBoolean\n        \n          If selected then dummy outports for each of the outport can\n          message signals are provided by the block.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.VDB_PACK.114": "The block pcx_CANdb_TransmitMessage shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.VDB_PACK.214": "The block pcx_CANdb_TransmitMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.VDB_PACK.015": "The Signal Names field must be a comma separated list of\n                 signal names to pack into the message or be empty otherwise the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_PACK.016": "CANdb file is checked by the interface, if it is not on\n                the path, the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_PACK.017": "Message Name is checked by the interface, if it is not\n                found in the CANdb file, the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_PACK.018": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PCX.VDB_PACK.050": "If parameter Provide simulation output?\n                is true then the signals specified by the\n                mask array, Message Name  shall  appear on inports and\n                outports otherwise these outports shall not exist (the inports would still exist though).",
    "LLR.PLAT.PCX.VDB_PACK.030": "If parameter Provide simulation output?\n                is true then the inport values specified by the\n                mask array, Message Name  shall  be written to\n                the corresponding outports.",
    "LLR.PLAT.PCX.VDB_PACK.020": "If parameter Provide simulation output? is true\n                the inport value sim_error_flag  shall  be written to the\n                outport error_flag otherwise the outport  shall  be set to zero.",
    "LLR.PLAT.PCX.VDB_PACK.041": "During initialisation the block  shall  acquire a handle for the transmit message, using the mask specified\n                CAN Bus Identifier and\n                Message Name, with message length, message ID and\n                extended ID extracted from the CANdb file to specify\n                the CAN bus, message length, message ID and extended ID flag respectively.",
    "LLR.PLAT.PCX.VDB_PACK.040": "If Clip Signals To Engineering Limits? is true\n                the block  shall  clip the input data to the range defined in the\n                CANdb file.",
    "LLR.PLAT.PCX.VDB_PACK.042": "The block  shall  pack the inport data using the following items that are derived from the DB file:\n                field_width, is_signed, valtype, order, eng_min, eng_max, scale, offset, clip_scaled, bool_type,\n                num_fields. The Vector CANtech Inc. website defines the standard for the database file.",
    "LLR.PLAT.PCX.VDB_PACK.026": "The block  shall  transmit the packed inport data values using the handle acquired for that message at\n                initialisation.",
    "LLR.PLAT.PCX.VDB_PACK.022": "The outport, error_flag  shall  be set to 1 if the\n                message is not successfully transmitted and set to 0 otherwise.",
    "LLR.APP.PCX.UNPACK.010": "During initialisation, the platform  shall  set all bytes in the receive buffer to zero.",
    "LLR.APP.PCX.UNPACK.011": "During initialisation, the platform  shall  set time stamp for the receive buffer to zero.",
    "LLR.APP.PCX.UNPACK.007": "The application  shall  pass the message to be unpacked and data describing data position,\n              size, sign and original type.",
    "LLR.PLAT.PCX.UNPACK.006": "When parameter checks have passed, the function  shall  read from\n              pcx_msg_data and output the fields values as specified.\n            \n              The start position defines the position of the field as follows:\n            \n                  For fields with lengths ranging from 1 to 15 bits, the start address defines where\n                  the message's least significant bit is stored.\n                \n                  For fields with lengths more than or equal to 16 bits, the start address defines\n                  where the message's most significant bit is stored.",
    "LLR.APP.PCX.UNPACK.012": "On successful reception of a new CAN message the platform  shall  set the time stamp set to the message reception time.",
    "LLR.APP.PCX.UNPACK.013": "If the platform detects a message overrun, then the receive buffer  shall  be set to the contents of the last received message\n              and the time stamp set to the last received message reception time and the overrun flag is set.",
    "LLR.PLAT.PCX.RX.001": "The platform shall provide a C interface function named\n                pcx_receive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_msg_handle\n          in\n        PCX_HANDLE_T\nThe message handle that refers to the CAN message to be received (as returned from calling pcx_declare_message()).\n Range: [0, length(pcx_rx_msg) - 1]pcxf_msg_data\n          out\n        U8 *\nPointer to array of data bytes to be filled from the most recently received CAN message. The array pointed to must be PCX_MAX_MSG_LENGTH bytes in length. \n Cannot be NULL. The message data is always filled with the data from the most recent received message, even if the return value indicates PCX_RX_ERROR pcxf_msg_timestamp\n          out\n        U32 *\nPointer to variable to be written with the low accuracy time stamp of the message reception. \n Cannot be NULL.\n Range: [0, 4294967295] microseconds\n                The function returns a value of type\n                U8\n                with a value of:\n              Returns a bitmap of status information:\nPCX_RX_DATA - set if a message has been received since the last callPCX_RX_OVERRUN - set if multiple messages has been received since the last callPCX_RX_ERROR - set if the most recently received message differs in length from the declared length, or it was declared with PCX_ANY_MSG_LENGTH (use pcx_receive_with_len() instead to receive such messages)",
    "LLR.PLAT.PCX.RX.101": "The function pcx_receive() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.RX.201": "The function pcx_receive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.RX.003": "The function  shall  check that the\n                handle pcxf_msg_handle is valid\n                (previously returned\n                by pcx_declare_message as receive) and\n                return 0 otherwise.",
    "LLR.PLAT.PCX.RX.004": "The function  shall  check that the handle pcxf_msg_data is not NULL\n                and return 0 otherwise.",
    "LLR.PLAT.PCX.RX.008": "The function  shall  check that the handle pcxf_msg_timestamp is\n                not NULL and return 0 otherwise.",
    "LLR.APP.PCX.RX.001": "The application  shall  read CAN received data using this API.",
    "LLR.PLAT.PCX.RX.005": "If the interface checks pass and if data was received, then the function  shall \n                copy the received data to the pcxf_msg_data buffer and return\n                PCX_RX_DATA.",
    "LLR.PLAT.PCX.RX.006": "If an overrun has occurred, the function  shall  return PCX_RX_OVERRUN.",
    "LLR.PLAT.PCX.RX.007": "If the length of the received message does not match the length declared for that\n                message (with pcx_declare_message()), the function  shall  return\n                PCX_RX_ERROR.",
    "LLR.PLAT.PCX.RX.009": "If the interface parameter checks pass and if data was\n                received, then the function  shall  write through pcxf_msg_timestamp\n                the time stamp of the received message.",
    "LLR.PLAT.PCX.RX.010": "If the message has never been received, then the caller's buffer is set with zeros\n                and the time stamp set to zero.",
    "LLR.PLAT.PCX.RX.011": "If the message has been received, but a new message has not been received since the last\n                time pcx_receive() was called (message overrun), then the caller's buffer\n                is set to the contents of the last received message and the time stamp set to the last\n                received message reception time.",
    "LLR.PLAT.PCX.UNPACK.001": "The platform shall provide a C interface function named\n                pcx_unpack_msg() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_item_ptr\n          in\n        void *const *\nPointer to array of pointers to data to be unpacked, the type of the final pointed to data is defined by the array pcxf_type_code. \n Cannot be NULL.pcxf_msg_data\n          in\n        const U8 *\nPointer to an array of data bytes to be read from (the array must be large enough to bound the unpacking, if it is too small, this function will read off the end of the array). \n Cannot be NULL.pcxf_field_start\n          in\n        const U8 *\nPointer to array of field start bit numbers. For each item to unpack from pcxf_msg_data, the function determines where to retrieve the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 0 of the message and 63 to the most significant bit of data byte 7 of the message, assuming these exist. For items whose bit length entry exceeds 7, the bit length must be one of: 0, 8, 16, 24, 32, 40, 48, 56. \n For fields with lengths ranging from 1 to 15 bits, the start address defines where the message's least significant bit is stored. \n For fields with lengths more than or equal to 16 bits, the start address defines where the message's most significant bit is stored. \n Cannot be NULL.pcxf_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from pcxf_msg_data, the function determines how many bits to retrieve from the array using the corresponding element from this array. The following values are allowed: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24 and 32. Items of 8 bits or fewer may not be defined so as to straddle CAN byte boundaries. \n Cannot be NULL.pcxf_is_signed\n          in\n        const U8 *\nPointer to array of sign flags (flag set true if signed, false otherwise). For each item to unpack from pcxf_msg_data, the function determines whether to use the MSB of the packed data as a sign bit or not. If the item is negative but specified in this array as unsigned, the item is clipped to zero. \n Cannot be NULL.pcxf_type_code\n          in\n        const U8 *\nPointer to array of data type codes. Each element determines the data type of each element in pcxf_item_ptr. The type of each element is one of: PCX_TYPECODE_F32, PCX_TYPECODE_BOOL, PCX_TYPECODE_S8, PCX_TYPECODE_U8, PCX_TYPECODE_S16, PCX_TYPECODE_U16, PCX_TYPECODE_S32, PCX_TYPECODE_U32. The data storage for a boolean type depends on the pcxf_use_bool_type argument. \n Cannot be NULL.pcxf_use_bool_type\n          in\n        const U8\nTrue if boolean types are stored as 8-bit integers, false if boolean types are stored as 32-bit floating point.pcxf_num_fields\n          in\n        const U8\nNumber of fields in each of pcxf_item_ptr, pcxf_field_start, pcxf_field_width, pcxf_is_signed, and pcxf_type_code. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument.\n                The function returns void.",
    "LLR.PLAT.PCX.UNPACK.101": "The function pcx_unpack_msg() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.UNPACK.201": "The function pcx_unpack_msg() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.UNPACK.002": "The function  shall  reject calls with an NULL pointer is\n                any of the following parameters pcxf_msg_data,\n                pcxf_item_ptr,\n                pcxf_field_start,\n                pcxf_field_width,\n                pcxf_is_signed\n                or pcxf_type_code by raising a\n                recoverable\n                error PSY_PCX\/PCX_ERR_UNPACK_MSG_INVALID_PARAM.",
    "LLR.PLAT.PCX.UNPACK.003": "The function  shall  skip an item with a type-code parameter\n                pcxf_type_code other than values defined in\n                PCX_DATATYPES_T, and raise a recoverable error\n                PSY_PCX\/PCX_ERR_UNPACK_MSG_FIELD_PARAM.",
    "LLR.PLAT.PCX.UNPACK.004": "The function  shall  skip an item with an invalid field width in\n                pcx_msg_field_width, and raise a recoverable error\n                PSY_PCX\/PCX_ERR_UNPACK_MSG_FIELD_PARAM.",
    "LLR.PLAT.PCX.UNPACK.005": "The function  shall  skip an item and raise a recoverable error\n                PSY_PCX\/PCX_ERR_UNPACK_MSG_FIELD_PARAM, when the item width is 8 bits\n                or less and the data straddles a CAN boundary.",
    "LLR.PLAT.PCX.UNPACK.008": "The platform shall provide a Simulink interface block named\n                pcx_CANReceiveMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          error_flag in simulation.\n        \n      sim_rx_trig_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          rx_trig_flag in simulation.\n        \n      sim_overrun_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          overrun_flag in simulation.\n        \n      sim_timestampInportInteger\n        \n          A  dummy input for simulation\n          purposes only; may be grounded if not required. The value of the output\n          timestamp in simulation. Only available if the mask\n          parameter Provide Timestamp is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if some error has\n          occurred which prevents CAN reception, or 0 otherwise.\n        \n        TypeConditions setting outport error_flag to 1run timethe bus is in bus off staterun timethe size of the most recently received message differs from the one used in configurationconfigurationthe bus has not been configuredconfigurationmessage not configured, because too many receive messages\n      rx_trig_flagOutportBoolean\n        \n          Set to 1 if message data\n          has been received at this iteration without any error, or 0 otherwise.\n        \n      overrun_flagOutportBoolean\n        \n          Set to 1 if more than one\n          message with the same CAN message identifier has been received in one model\n          iteration, or 0 otherwise. If more than one message has been received, the data\n          from the latest message is used.\n        \n      timestampOutportInteger\n        \n          A low accuracy time stamp of when\n          the message was last received, or zero if the message has never been received. The\n          time stamp is a free running microsecond timer, which wraps to zero at its maximum\n          (rather than saturating). Only available if the mask parameter\n          Provide Timestamp is selected.\n        \n      Message IdentifierParamInteger\n        \n          The unique can\n          identifier of the message to be received.\n        \n        \n          Range: [0, 2047] if standard identifier\n        \n        \n          Range: [0, 536870911] if extended identifier\n        \n      \n                Calibratable: no.\n              Message LengthParamInteger\n        \n          The number of data bytes to be received.\n        \n        \n          Range: [0, 8] bytes\n        \n      \n                Calibratable: no.\n              Field Start Bit PositionsParamInteger\n        \n          A vector of\n          bit numbers indicating the position at which each input Item begins in the CAN\n          message. 0 corresponds to the least significant bit of data byte 0 of the message\n          and 63 to the most significant byte of data byte 7 of the message, assuming these\n          exist. For items whose bit length entry exceeds 7, the bit length must be one of:\n          0, 8, 16, 24, 32, 40, 48, 56.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: [0, 8], 16, 24, 32, 40, 48, 56 bit positions\n        \n      \n                Calibratable: no.\n              Field WidthsParamInteger\n        \n          A vector of bit lengths\n          indicating the number of bits used to transmit each input Item. The following\n          values are allowed: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 24 and\n          32. Items of 8 bits or fewer may not be defined so as to straddle CAN byte boundaries.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: [1, 16], 24 or 32 bit width\n        \n      \n                Calibratable: no.\n              Field SignsParamInteger\n        \n          A vector of 1 or 0\n          values. Corresponding data items for which this is set 1 are received as\n          twos-complement signed numbers, or unsigned numbers otherwise.\n        \n        \n          Size: [1, 64] elements\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Type CodesParamInteger\n        \n          This block provides one data\n          field input for each element in Field Start Positions, as follows:\n        \n        Table\u00a03.4.\u00a0CAN block type codesType codeSimulink data type0real_T (single floating point type)1default boolean (boolean or real_T depending on current setting of\n                Simulink Boolean logic signals setting)2signed 8 bit integer (int8_T)3unsigned 8 bit integer (uint8_T)4signed 16 bit integer (int16_T)5unsigned 16 bit integer (uint16_T)6signed 32 bit integer (int32_T)7unsigned 32 bit integer (uint32_T)\n      \n                Calibratable: no.\n              Field MnemonicsParamString\n        \n          A string containing a\n          comma-separated list of names with which to label the simulation input and CAN\n          data output ports.\n        \n      \n                Calibratable: no.\n              CAN Bus IdentifierParamInteger\n        \n          Which can bus the message will be received on.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Use Extended Message Identifier?ParamBoolean\n        \n          If box\n          is checked the 29 bit identifier is to be used, otherwise the 11 bit standard\n          identifier is to be used.\n        \n      \n                Calibratable: no.\n              Provide TimestampParamBoolean\n        \n          If selected then inport sim_timestamp and outport\n          timestamp are made available.\n        \n      \n                Calibratable: no.\n              Provide Simulation Input?ParamBoolean\n        \n          If selected then dummy inputs for each of the outport can\n          message signals, such as sim_signal_name, are provided by\n          the block.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.UNPACK.108": "The block pcx_CANReceiveMessage shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.UNPACK.208": "The block pcx_CANReceiveMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.UNPACK.009": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.010": "If Use Extended Message Identifier? is selected then the\n                block  shall  check that the Message Identifier lies in the\n                extended range. If it is not then the interface  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.011": "If Use Extended Message Identifier? is un-selected then the\n                block  shall  check that the Message Identifier lies in the\n                normal range. If it is not then the interface  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.012": "If the size of the packed data exceeds Message Length,\n                the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.013": "If the following mask arrays are not all the same length then the block  shall  raise an error:\n                Field Start Bit PositionsField WidthsField SignsType Codes",
    "LLR.PLAT.PCX.UNPACK.014": "If the following mask arrays are not all integers then the block  shall  raise an error:\n                Field Start Bit PositionsField WidthsField SignsType Codes",
    "LLR.PLAT.PCX.UNPACK.015": "If any of the elements in the Field Start Bit Positions array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.016": "If any of the elements in the Field Widths array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.017": "If any of the elements in the Field Signs array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.018": "If any of the elements in the Type Codes array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.019": "If overlapping fields are found, the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.021": "The mask arrays Type Codes,\n                Field Signs and\n                Field Widths are checked by the interface to see if the data\n                type can be supported without clipping, if it cannot then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.022": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.024": "If any of Field Widths are 7 bits or less\n                and cross a byte boundary then the block  shall  raise an error.",
    "LLR.PLAT.PCX.UNPACK.041": "The mask arrays Field Start Bit Positions and\n                Field Widths are checked by the interface.\n                If the number of bits used is greater than the message length the interface  shall  raise an\n                error.",
    "LLR.PLAT.PCX.UNPACK.025": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PCX.UNPACK.026": "If parameter Provide simulation input?\n                is true then the block  shall  have inports for the signals specified by the\n                mask Field Mnemonics during simulation.\n                Additional inports appear on the block with these signal names, otherwise no additional inports  shall \n                appear on the block.",
    "LLR.PLAT.PCX.UNPACK.033": "If parameter Provide simulation input?\n                is true then inport values  shall  be copied to the corresponding outports otherwise the outports shall be written\n                with the value zero.",
    "LLR.PLAT.PCX.UNPACK.027": "If parameter Provide simulation input?\n                is false then the signals specified by the\n                mask Field Mnemonics  shall  all have zero on their respective\n                outports.",
    "LLR.PLAT.PCX.UNPACK.028": "The inports, sim_error_flag,\n                sim_rx_trig_flag and\n                sim_overrun_flag  shall  be used to drive the outports,\n                error_flag,\n                rx_trig_flag and\n                overrun_flag.",
    "LLR.PLAT.PCX.UNPACK.040": "During initialisation the block  shall  acquire a handle for the receive message, using the mask parameters\n                CAN Bus Identifier,\n                Use Extended Message Identifier?,\n                Message Length and\n                Message Identifier to specify the CAN bus,\n                standard\/extended ID flag, message length and message ID respectively.",
    "LLR.PLAT.PCX.UNPACK.042": "The block  shall  receive the declared CAN message using the handle acquired during initialisation.",
    "LLR.PLAT.PCX.UNPACK.034": "The block  shall  unpack the received CAN data for the fields specified in\n                Field Mnemonics\n                with the field positions, widths, signs and type specified by\n                Field Start Bit Positions,\n                Field Widths,\n                Field Signs,\n                and\n                Type Codes.",
    "LLR.PLAT.PCX.UNPACK.029": "The block  shall  write the unpacked data to the corresponding outports specified by the mask\n                Field Mnemonics.",
    "LLR.PLAT.PCX.UNPACK.030": "The block  shall  set the error_flag to 1 if an error occurred\n                during configuration or reception of the message.",
    "LLR.PLAT.PCX.UNPACK.031": "The block  shall  set the outport rx_trig_flag\n                to 1 if new data has been received or 0 otherwise.",
    "LLR.PLAT.PCX.UNPACK.032": "The block  shall  set the outport overrun_flag\n                to 1 if an overrun has occurred or 0 otherwise.",
    "LLR.APP.PCX.VDB_UNPACK.001": "The application  shall  pass the message to be unpacked and data describing data position,\n              size, sign, original type, packing order, scaling parameters (offset and scaling factor),\n              engineering range and a flag indicating if clipping to engineering range should occur.",
    "LLR.PLAT.PCX.VDB_UNPACK.008": "The platform  shall  unpack the CAN data MS or LS bit first depending on the specified\n              packing order.",
    "LLR.PLAT.PCX.VDB_UNPACK.009": "The platform  shall  provide means of limiting the CAN data items to a defined range.",
    "LLR.PLAT.PCX.VDB_UNPACK.010": "The platform  shall  provide means of scaling the CAN data items.",
    "LLR.PLAT.PCX.VDB_UNPACK.025": "The platform  shall  acquire CAN data using pcx_receive() - see requirements in section \"CAN Message Receive and Unpack - Pi Format\".",
    "LLR.PLAT.PCX.VDB_UNPACK.001": "The platform shall provide a C interface function named\n                pcx_vdb_unpack_msg() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpcxf_item_ptr\n          in\n        F32 *const *\nPointer to array of pointers to data to be unpacked. Each data item is stored as a 32-bit float. \n Cannot be NULL.pcxf_item_raw_ptr\n          in\n        U32 *const *\nPointer to array of pointers to data to be unpacked. Each data item is stored as a 32-bit integer, taken from the CAN message without clipping and scaling. \n If the pointer is NULL, raw data items are not written.pcxf_msg_data\n          out\n        const U8 *\nPointer to an array of data bytes to be read (the array must be large enough to bound the unpacking, if it is too small, this function will read off the end of the array). \n Cannot be NULL.pcxf_field_start\n          in\n        const U8 *\nPointer to array of field start bit numbers. For each item to unpack from pcxf_item_ptr, the function determines where to read the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 0 of the message and 63 to the most significant bit of data byte 7 of the message, assuming these exist. \n Cannot be NULL.pcxf_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from pcxf_msg_data, the function determines how many bits to read into the array using the corresponding element from this array. \n Cannot be NULL. \n Element range: [1, 32] bitspcxf_is_signed\n          in\n        const U8 *\nPointer to array of sign flags (flag set true if signed, false otherwise). For each item to unpack into pcxf_msg_data, the function determines whether to use the MSB of the packed data as a sign bit or not. \n Cannot be NULL.pcxf_valtype\n          in\n        const U8 *\nPointer to array of data type codes. Each element can be one of: PCX_VAL_INT, and PCX_VAL_FLOAT32. \n Cannot be NULL.pcxf_order\n          in\n        const U8 *\nPointer to array of data type byte storage order. Each element can be one of: PCX_MSB_ORDER, and PCX_LSB_ORDER. \n Cannot be NULL.pcxf_eng_min\n          in\n        const F32 *\nPointer to array of engineering minimum values. For each item to unpack from pcxf_msg_data, the function clips the item to the corresponding minimum element from this array if pcxf_clip_scaled is true. \n Cannot be NULL.pcxf_eng_max\n          in\n        const F32 *\nPointer to array of engineering maximum values. For each item to unpack from pcxf_msg_data, the function clips the item to the corresponding maximum element from this array if pcxf_clip_scaled is true. \n Cannot be NULL.pcxf_scale\n          in\n        const F32 *\nPointer to array of multipliers. For each integer item to unpack from pcxf_msg_data, the function scales the item by the corresponding multiplier in this array and adds an offset specified by pcxf_offset. \n Cannot be NULL.pcxf_offset\n          in\n        const F32 *\nPointer to array of adders. For each integer item to unpack from pcxf_msg_data, the function scales the item by the corresponding multiplier in pcxf_scale and adds the offset specified by this array. \n Cannot be NULL.pcxf_clip_scaled\n          in\n        const U8\nTrue if each data item should be clipped to the minimum and maximum specified by pcxf_eng_min and pcxf_eng_max, otherwise false if no clipping is to be performed.pcxf_use_bool_type\n          in\n        const U8\nUnused. Set to false.pcxf_num_fields\n          in\n        const U8\nNumber of fields in each of pcxf_item_ptr, pcxf_field_start, pcxf_field_width, pcxf_is_signed, pcxf_valtype, pcxf_order, pcxf_eng_min, pcxf_eng_max, pcxf_scale and pcxf_offset (and for pcxf_item_raw_ptr if it is not NULL). The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument.\n                The function returns void.",
    "LLR.PLAT.PCX.VDB_UNPACK.101": "The function pcx_vdb_unpack_msg() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PCX.VDB_UNPACK.201": "The function pcx_vdb_unpack_msg() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PCX.VDB_UNPACK.002": "The function  shall  reject calls with a NULL pointer in\n                any of the following parameters pcxf_item_ptr,\n                pcxf_msg_data, pcxf_field_start,\n                pcxf_field_width, pcxf_is_signed,\n                pcxf_valtype, pcxf_order,\n                pcxf_eng_min, pcxf_eng_max,\n                pcxf_scale or pcxf_offset by raising\n                a recoverable error PSY_PCX\/PCX_ERR_UNPACK_VDB_MSG_INVALID_PARAM.",
    "LLR.PLAT.PCX.VDB_UNPACK.003": "The platform  shall  unpack data MS bit first if pcxf_order is set to\n                PCX_MSB_ORDER and LS bit first otherwise.",
    "LLR.PLAT.PCX.VDB_UNPACK.004": "The platform  shall  scale the data according to the pcxf_offset\n                and pcxf_scale values.",
    "LLR.PLAT.PCX.VDB_UNPACK.005": "The platform  shall  clip the data to the range defined by pcxf_eng_min\n                and pcxf_eng_max when pcxf_clip_scaled is true.",
    "LLR.PLAT.PCX.VDB_UNPACK.006": "When parameter checks pass, the function  shall  read from pcx_msg_data\n                and output the fields value as specified into pcxf_item_ptr.",
    "LLR.PLAT.PCX.VDB_UNPACK.007": "When parameter checks pass, if pcxf_item_raw_ptr is not\n                NULL, the function  shall  read from pcx_msg_data\n                and output the extracted raw bitstream data into pcxf_item_raw_ptr.",
    "LLR.PLAT.PCX.VDB_UNPACK.011": "The platform shall provide a Simulink interface block named\n                pcx_CANdb_ReceiveMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          error_flag in simulation.\n        \n      sim_rx_trig_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          rx_trig_flag in simulation.\n        \n      sim_overrun_flagInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          overrun_flag in simulation.\n        \n      sim_timestampInportInteger\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          timestamp in simulation. Only available if the mask parameter\n          Provide Timestamp is selected.\n        \n      sim_checksum_errInportBoolean\n        \n          A dummy input for\n          simulation purposes only; may be grounded if not required. The value of outport\n          checksum_err in simulation. Only available if the mask parameter\n          Checksum Type is not None.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if some error has\n          occurred which prevents CAN reception, or 0 otherwise.\n        \n        TypeConditions setting outport error_flag to 1run timethe bus is in bus off staterun timethe size of the most recently received message differs from the one used in configurationconfigurationthe bus has not been configuredconfigurationmessage not configured, because too many receive messages\n      rx_trig_flagOutportBoolean\n        \n          Set to 1 if message data\n          has been received at this iteration without any error, or 0 otherwise.\n        \n      overrun_flagOutportBoolean\n        \n          Set to 1 if more than one\n          message with the same CAN message identifier has been received in one model\n          iteration, or 0 otherwise. If more than one message has been received, the data\n          from the latest message is used.\n        \n      timestampOutportInteger\n        \n          A  low accuracy time stamp\n          of when the message was last received, or zero if the message has never been\n          received. The time stamp is a free running microsecond timer, which wraps to\n          zero at its maximum (rather than saturating). Only available if the mask parameter\n          Provide Timestamp is selected.\n        \n      checksum_errOutportBoolean\n        \n          Set TRUE if the most recently received message failed checksum validation\n          or FALSE otherwise. Only available if the mask parameter\n          Checksum Type is not None.\n        \n      CANdb fileParamString\n        \n          The name of the candb file;\n          can be relative to the model directory (i.e., the current workspace directory) or\n          absolute. Only textual CANdb files are accepted (see restrictions in the notes\n          section below).\n        \n      \n                Calibratable: no.\n              Message NameParamString\n        \n          The name of the message to\n          receive. The name must be specified in the CANdb file and must match case (e.g.,\n          message name EngineRPM is different from message name\n          enginerpm).\n        \n      \n                Calibratable: no.\n              Signal NamesParamString\n        \n          A comma separated list of\n          signal names to unpack from the message (e.g., \"name1,name2\" without the\n          quotes). An empty list of names to unpack is supported, in which case the block\n          shows no additional outports. This mode can be used to detect the presence of a\n          message on the CAN bus without decoding any of the CAN message contents.\n        \n      \n                Calibratable: no.\n              Output All Message SignalsParamBoolean\n        \n          If selected\n          then all signals from the message are created as outports (similarly simulation\n          inports if required), if unselected then only those signals in the signal names\n          field are created as outports.\n        \n        \n          If this field is ticked and the dialog closed, next time this field is unticked,\n          the signal names field will contain the complete list of signals. This mechanism\n          is useful when filling in the dialog for the first time but you are unsure of the\n          field names (e.g., open block, fill in CANdb file name, message name, CAN bus and\n          sample time, then tick this field, close the dialog, then select the block again,\n          untick this field, then edit the list of required signals).\n        \n      \n                Calibratable: no.\n              Output Raw Signal Values?ParamBoolean\n        \n          If selected, a second set of outports are created for the message\n          signals, each set to the raw integer value extracted from the CAN\n          message prior to being scaled into engineering units.\n        \n      \n                Calibratable: no.\n              Clip Signals To Engineering Limits?ParamBoolean\n        \n          If selected, each outport (except for the raw signal outports) is clipped\n          to the limits for that signal defined by the CANdb file.\n        \n      \n                Calibratable: no.\n              Display Signal Units?ParamBoolean\n        \n          If selected then each of the can message outport signals (and simulation\n          inport signals) show their engineering units, if the CANdb file defines those\n          units.\n        \n      \n                Calibratable: no.\n              CAN Bus IdentifierParamInteger\n        \n          Which can bus\n          the message will be received on.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide TimestampParamBoolean\n        \n          If selected then inport sim_timestamp and outport\n          timestamp are made available.\n        \n      \n                Calibratable: no.\n              Checksum TypeParamList\n        \n          A drop-down selection of the type of checksum to expect in the last raw\n          message byte, computed over all of the\n          preceding raw bytes in the message (even if they\n          are not used by any signals). The default is None,\n          and the other currently supported option is the\n          8-bit CRC defined by SAE-J1850.\n          If used, the outport\n           checksum_err is filled accordingly.\n          In simulation, the value from\n          inport sim_checksum_err is passed through.\n        \n      \n                Calibratable: no.\n              Provide Simulation Input?ParamBoolean\n        \n          If selected then dummy inputs for each of the outport can\n          message signals, such as sim_signal_name, are provided by the block.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PCX.VDB_UNPACK.111": "The block pcx_CANdb_ReceiveMessage shall support the targets:\n            All targets.",
    "LLR.PLAT.PCX.VDB_UNPACK.211": "The block pcx_CANdb_ReceiveMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PCX.VDB_UNPACK.012": "If the file path CANdb file is invalid,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_UNPACK.013": "If the Message Name parameter found in the\n                CANdb file is invalid, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_UNPACK.014": "If the parameter Signal Names is not\n                a comma separated list, then the block  shall  raise an error.",
    "LLR.PLAT.PCX.VDB_UNPACK.016": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PCX.VDB_UNPACK.017": "If parameter Provide simulation input?\n                is true then the signals specified by the\n                mask array, Message Name  shall  appear on inports and\n                outports otherwise these inports shall not exist (the outports would still exist though).",
    "LLR.PLAT.PCX.VDB_UNPACK.040": "If parameter Provide simulation input?\n                is true then the inport values specified by the\n                mask array, Message Name  shall  be written to\n                the corresponding outports.",
    "LLR.PLAT.PCX.VDB_UNPACK.018": "If parameter Provide simulation input?\n                is false then the signals specified by the\n                mask Message Name found in the CANdb file  shall  all have\n                zero on their respective outports.",
    "LLR.PLAT.PCX.VDB_UNPACK.019": "The inports, sim_error_flag,\n                sim_rx_trig_flag and\n                sim_overrun_flag shall  be used to drive the outports,\n                error_flag,\n                rx_trig_flag and\n                overrun_flag.",
    "LLR.PLAT.PCX.VDB_UNPACK.046": "If parameter Display Signal Units?\n                is false then only the signal names  shall  appear on the block next to the appropriate outports.\n                Otherwise both signal names and units shall appear on the block next to the appropriate outports.",
    "LLR.PLAT.PCX.VDB_UNPACK.020": "During initialisation the block  shall  acquire a handle for the receive message, using the mask specified\n                CAN Bus Identifier and\n                Message Name, with message length, message ID and\n                extended ID extracted from the CANdb file to specify\n                the CAN bus, message length, message ID and extended ID flag respectively.",
    "LLR.PLAT.PCX.VDB_UNPACK.042": "The block  shall  receive the declared CAN message using the handle acquired during initialisation.",
    "LLR.PLAT.PCX.VDB_UNPACK.043": "The block  shall  unpack the CAN message using the following items that are derived from the DB file:\n                field_width, is_signed, valtype, order, eng_min, eng_max, scale, offset, clip_scaled, bool_type,\n                num_fields. The Vector CANtech Inc. website defines the standard for the database file.",
    "LLR.PLAT.PCX.VDB_UNPACK.041": "If Clip Signals To Engineering Limits? is true\n                the block  shall  clip the input data to the range defined in the\n                CANdb file.",
    "LLR.PLAT.PCX.VDB_UNPACK.044": "If parameter Output All Message Signals\n                is false then only the signals specified by the\n                mask Message Name found in the CANdb file  shall  be unpacked.\n                Otherwise all signals for the specified message shall be unpacked.",
    "LLR.PLAT.PCX.VDB_UNPACK.024": "The block  shall  write the unpacked data to their respective outports specified by\n                Signal Names.",
    "LLR.PLAT.PCX.VDB_UNPACK.045": "If parameter Output Raw Signal Values?\n                is false then only the engineering values  shall  be unpacked and supplied to the appropriate outports.\n                Otherwise both raw and engineering values shall be unpacked and supplied to the appropriate outports.",
    "LLR.PLAT.PCX.VDB_UNPACK.021": "The block  shall  set the outport error_flag\n                to 1 if an error occurred during configuration or reception of the message.",
    "LLR.PLAT.PCX.VDB_UNPACK.022": "The block  shall  set the outport rx_trig_flag\n                to 1 if new data has been received or 0 otherwise.",
    "LLR.PLAT.PCX.VDB_UNPACK.023": "The block  shall  set the outport overrun_flag\n                to 1 if an overrun has occurred or 0 otherwise.",
    "LLR.APP.PDD.DDIN.001": "The application  will  invoke this interface during application initialisation for each\n              logical digital data input channel that will be read during run time.",
    "LLR.PLAT.PDD.DDIN.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to read logical digital data input channels declared by the\n              application.",
    "LLR.PLAT.PDD.DDIN.002": "During application run time, the platform  shall  read the digital data input channels\n              and make their states available to the application upon request.",
    "LLR.PLAT.PDD.DDIN.003": "The platform shall provide a C interface function named\n                pdd_data_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpddf_lchan\n          in\n        PDD_LCHAN_T\nThe digital channel to use as a digital data input. Use the macros included by the pio.h file, of the form PIO_DIN_DATA_[NAME].pddf_data\n          out\n        S32 *\nThe value of the digital data is written through this pointer.\n Cannot be NULL. \n Range: [-2147483648, 2147483647] (the actual range may vary depending on the value read)pddf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDD_RC_T\n                with a value of:\n              PDD_RC_OK - if successful actionPDD_RC_SW_ERROR - if channel not supportedPDD_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PDD.DDIN.004": "The function pdd_data_input() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PDD.DDIN.005": "The function pdd_data_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDD.DDIN.006": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                low level input by returning PDD_RC_BAD_ARGS.\n              Note: \n                A \u201cpotential low level input\u201d as something the processor can read, a\n                physical or virtual quantity, in any variant of the hardware.",
    "LLR.PLAT.PDD.DDIN.007": "During application run time, the function  shall  return PDD_RC_BAD_ARGS when pddf_data\n                is NULL.",
    "LLR.PLAT.PDD.DDIN.008": "If the interface checks pass then the function  shall  write the acquired\n                digital data value for the logical channel through pddf_data.\n              Note: \n                If the logical channel number does not match a connected channel, then the\n                acquired value is undefined.\n              Note: \n                The C interface does not account for any input signal conditioning circuits that may\n                effectively result in an inversion between the ECU and CPU pins. Therefore it is up to\n                the application code to get the high\/low sense right for the particular ECU and\n                application.",
    "LLR.PLAT.PDD.DDIN.009": "The platform shall provide a Simulink interface block named\n                pdd_DataInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_valueInportInteger\n        \n          Only used under simulation when the parameter Provide simulation input? is ticked.\n          The outport value is written using the value of this inport.\n        \n        \n          Range: [-2147483648, 2147483647].\n        \n      valueOutportInteger\n        \n          The value of the digital data read from the specified channel.\n        \n        \n          Range: [-2147483648, 2147483647].\n        \n      ChannelParamList\n        \n          The channel for this input.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          Tick to enable inport sim_value.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDD.DDIN.010": "The block pdd_DataInput shall support the targets:\n            All targets.",
    "LLR.PLAT.PDD.DDIN.011": "The block pdd_DataInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDD.DDIN.012": "If the same parameter for the mask Channel is used\n                in another block within the model, then the block  shall  raise an error.",
    "LLR.PLAT.PDD.DDIN.013": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PDD.DDIN.014": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDD.DDIN.015": "If parameter Provide simulation input?\n                is true then the sim_value inport  shall  be available on the block\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PDD.DDIN.016": "The block  shall  update the outport value\n                with the value of the inport sim_value.",
    "LLR.PLAT.PDD.DDIN.017": "The block  shall  initialise the channel defined by the mask Channel.",
    "LLR.PLAT.PDD.DDIN.018": "The block  shall  read the input value of the channel defined by the mask parameter, Channel.",
    "LLR.PLAT.PDD.DDIN.019": "The block  shall  update the outport value\n                with the value of the input channel defined by the mask\n                Channel.",
    "LLR.PLAT.PDG.UDS.001": "For all the UDS service requests that support the sub-function parameter\n              the platform  shall  consider the bit-7 of the first byte of the sub-function parameter as\n              the suppressPosRspMsgIndicationBit. A positive response for the service\n               shall  be sent only if this bit is FALSE.\n            Rationale: \n              Note: bit 7 is described as suppressPosRspMsgIndicationBit\n              and only affects positive responses. The ECU always sends a negative response,\n              if appropriate.",
    "LLR.PLAT.PDG.UDS.002": "Upon receipt of a J1979 request, if the platform is in extendedDiagnosticSession, it  will \n              change back to Default session.\n            Rationale: \n              To satisfy requirement in the ISO14229-1 specification in section\n              \u201cMultiple concurrent request messages with physical and functional addressing\u201d that says -\n              \u201cIf a server supports one or more legislated diagnostic requests and one of these requests is received\n               while a non-legislated service (e.g., enhanced diagnostics) is active, then the active service shall be\n               aborted, the default session shall be started and the legislated diagnostic service shall be processed. This\n               requirement does not apply if the programming session is active.\u201d",
    "LLR.PLAT.PDG.INTERF.001": "The platform  shall  provide a method for an application to specify whether diagnostics are\n              enabled at initialisation. If they are required then the initialisation required for\n              supporting ISO diagnostics will occur.\n            Note\n                The ISO diagnostic support is considered to be needed by default; however, this parameter\n                is still added to have the ability to disable diagnostics when requested by the application\n                (like for example during a shutdown request when all CAN communication need to be switched off).\n                So, the periodic tasks of the ISO diagnostics can check this flag. If this flag is not set,\n                then the diagnostic support is disabled by the platform software.",
    "LLR.PLAT.PDG.INTERF.002": "The platform software  shall  provide the parameter Maximum Transmit\n              message size and initialise it to the value provided by the application.\n              This is the number of bytes for the largest transmit message which the platform\n              uses to customise the size of the transmit message buffer.",
    "LLR.PLAT.PDG.INTERF.003": "The platform software  shall  provide the parameter CAN transmit ID\n              and initialise it to the value provided by the application. This is the CAN\n              ID for transmission.",
    "LLR.PLAT.PDG.INTERF.004": "The platform software  shall  provide the parameter Extended CAN\n              transmit ID flag and initialise it to the value provided by the\n              application. This is the flag that indicates whether Extended ID is to be\n              used for CAN transmission. This should be initialised to FALSE for Standard\n              ID and to TRUE for Extended ID.",
    "LLR.PLAT.PDG.INTERF.005": "The platform software  shall  provide the parameter CAN receive\n              ID and initialise it to the value provided by the application.\n              This is the CAN ID for reception.",
    "LLR.PLAT.PDG.INTERF.006": "The platform software  shall  provide the parameter Extended CAN\n              receive ID flag and initialise it to the value provided by the\n              application. This flag indicates whether Extended ID is to be used for CAN\n              reception. This should be initialised to FALSE for Standard ID and to TRUE\n              for Extended ID.",
    "LLR.PLAT.PDG.INTERF.007": "The platform software  shall  provide the parameter CAN receive ID for\n              functional addressing and initialise it to the value provided by the\n              application.",
    "LLR.PLAT.PDG.INTERF.008": "The platform software  shall  provide the parameter CAN bus\n              IDand initialise it to the value provided by the application.",
    "LLR.PLAT.PDG.INTERF.010": "The platform  shall  provide an interface parameter called\n              pdgc_emissions_report_min_sev to allow the application to define\n              the minimum severity level for a J1979 DTC to have an effect on emission.\n              Any DTC that has a severity level greater than or equal to that defined by the above\n              parameter  will  be considered to be a emission-related DTC for use with DM32 only.",
    "LLR.PLAT.PDG.INTERF.011": "The platform software  shall  provide the parameter Maximum Receive\n              message size and initialise it to the value provided by the application.\n              This is the number of bytes for the largest receive message, which the platform\n              uses to customise the size of the receive message buffer.",
    "LLR.PLAT.PDG.INTERF.014": "The platform  shall  provide an interface parameter called\n              pdgc_override_service_03 to allow the application to override the\n              standard response to J1979 service $03.",
    "LLR.PLAT.PDG.INTERF.015": "The platform  shall  provide an interface parameter called\n              pdgc_override_service_07 to allow the application to override the\n              standard response to J1979 service $07.",
    "LLR.PLAT.PDG.INTERF.016": "The platform  shall  provide an interface parameter called\n              pdgc_override_service_0a to allow the application to override the\n              standard response to J1979 service $0A.",
    "LLR.PLAT.PDG.INTERF.012": "The platform  shall  support the following logical CAN channels for the CAN bus ID.\n            Note\n                This is what is currently supported by the PCX feature in existing\n                platform code (same note holds true for all the interface parameters listed below).\n                This parameter  will  be used to obtain the bus addresses required for declaring\n                the handles to the receive and transmit messages.\n              \n              Table\u00a03.5.\u00a0Can channel mapping by targetTargetFirst CAN bus IDSecond CAN bus IDM220PIO_CAN_A28_A43PIO_CAN_A23_A24M250PIO_CAN_A28_A43PIO_CAN_A29_A44M460PIO_CAN_A37_A36PIO_CAN_C37_C36M461PIO_CAN_A37_A36PIO_CAN_C37_C36",
    ".PLAT.PDG.INTERF.013": "The platform  shall  provide an interface parameter called pdg_enabled\n              to allow the application to enable ISO diagnostics support, settable at build time.",
    "LLR.PLAT.PDG.FBKNEGRESP.001": "When the requested service ID is not supported and the request\n              uses a physically addressed ISO-15765 message, the platform\n               shall  respond with a negative response reporting an\n              error code of 0x11 (service not supported).",
    "LLR.PLAT.PDG.$01.004": "In response to a J1979 \"Request Current Powertrain Diagnostic Data\"\n              (0x01) request by the test tool, the platform  shall \n              ignore all but the first six PIDs in the request message.\n            Rationale: \n              The J1979 SEP2010 standard states that the request message may contain up to six PIDs.\n              It does not say what to do if more than six are requested, but the above seems reasonable.",
    "LLR.PLAT.PDG.$01.005": "In response to a PSP, if no PIDs are included in its or any subsequent range,\n              then the platform  shall  ignore the PSP.\n            Rationale: \n              Section 8.1.2.2 J1979 SEP2010 says \"The ECU shall not respond to unsupported PID ranges\n              unless subsequent ranges have a support PID(s)\".",
    "LLR.PLAT.PDG.$01.006": "In response to a PSP, if any PIDs are included in its range, then the platform  shall \n              respond to the PSP with bits representing those included PIDs set to one, and bits\n              representing PIDs in range but not included set to zero, using the PID ID-to-bit\n              mapping set out in the table below.\n            Table\u00a03.7.\u00a0PIDs-supported PIDs bitfield mapping\n                      PID ID modulo 32\n                    \n                      Bit Number\n                    \n                      Bit Significance\n                    \n                      Byte\n                    17MSBFirst Byte26\u00a0First Byte....\u00a0..80LSBFirst Byte97MSBSecond Byte....\u00a0..311\u00a0Fourth Byte\n              Note: the least significant bit of the fourth byte is set according to\n              [LLR.PLAT.PDG.$01.007] below.\n            Rationale: \n              See SAE J1979 SEP2010 Appendix A Table A1 for mapping and Section 6.3.9.1 for bit position\n              convention.",
    "LLR.PLAT.PDG.$01.007": "In response to an PSP, if any PIDs are included in any subsequent range,\n              then the platform  shall  respond to the PSP and set the least significant bit\n              of the fourth byte to one.\n            Note: \n              For PSP $E0, this can never be the case.",
    "LLR.PLAT.PDG.$01.008": "In response to a PSP, if some PIDs are included in range but no PIDs are\n              included in any subsequent range, then the platform  shall  respond to the PSP\n              and set the least significant bit of the fourth byte to zero.",
    "LLR.PLAT.PDG.$01.003": "The platform  shall  automatically respond to J1979 0x01 requests for PID 0x02 with\n            the DTC that caused the first freeze frame currently logged in the ECU or 0x0000\n            if no freeze frames have been logged.\n          Rationale: \n            PID 0x02 represents the DTC that caused the first freeze frame to be captured.\n            Since freeze frames are handled by the platform, it makes sense for the platform\n            to handle this PID directly rather than passing this information up to the application\n            only for the application to pass it back down to the platform again ready to send.",
    "LLR.PLAT.PDG.$01.009": "In response to a DVP, if that DVP is specified for the currently executing application\n              then the platform  shall  respond with the latest data available for that DVP.",
    "LLR.PLAT.PDG.$01.010": "If any PIDs in the $01 request require a response then the platform  shall  send a positive\n              response message with appropriate data for each such PID within 50 ms.\n            Note: \n              The J1979 SEP2010 standard states that the request message may not contain a mixture of PSPs\n              and DVPs, but if such a request is received, the platform does not take any special action,\n              i.e. it replies (potentially with a mixture of PSP and DVP data) for any of the PIDs that require it.",
    "LLR.PLAT.PDG.$01.011": "If the same PID is requested more than once in the same $01 request, the platform  shall  treat\n              each such PID request independently and respond to each if appropriate.\n            Rationale: \n              Specifically required by J1979 SEP2010 - see section 8.1.1",
    "LLR.PLAT.PDG.$02.016": "In response to a $02 request, FFN  shall  be interpreted as follows:\n            \n              FFN = 0 means the oldest freeze frame currently stored in non-volatile memory\n            \n              FFN = 1 means the second oldest freeze frame currently stored in non-volatile memory\n            \n              etc.\n            Rationale: \n              See SAE J1979 SEP2010 8.2.4.2 \"Case #3: Multiple Freeze Frames\" paragraph in bold where it\n              requires freeze frames to be numbered in order from 0 up with no gaps. Also, FFN = 0 must\n              be the first freeze frame to be captured as required by the legislation (when higher priority\n              freeze frames can be ignored). If the oldest frame is deleted, then the next oldest frame in\n              NVM becomes the new FFN = 0, and the only practical way of doing that is to number the frames\n              in age order.",
    "LLR.PLAT.PDG.$02.001": "In response to a $02 request, if the request message is not of length 3, 5 or 7 bytes,\n              the platform  shall  not respond.\n            Rationale: \n              The Negative Response Code $12 subFunctionNotSupported-InvalidFormat is only supported by ISO 14230-4\n              not by ISO 15765-4. See Table 16 of SAE J1979 SEP2010.",
    "LLR.PLAT.PDG.$02.002": "In response to a $02 request, if the first PID is a PSP then the platform  shall  ignore\n              any subsequent PIDs that are not also PSPs.\n            Rationale: \n              It is a requirement on the test tool not to mix PSPs and non-PSPs.\n              In the case where such a mixture does occur, the platform can reasonably use the first PID in the message\n              to determine which type of request it is, and then ignore any other PIDs that do not fit this assumption.",
    "LLR.PLAT.PDG.$02.003": "In response to a $02 request, if the first PID is not a PSP then the platform  shall  ignore\n              any subsequent PIDs that are PSPs.\n            Rationale: \n              Converse of LLR.PLAT.PDG.$02.002.",
    "LLR.PLAT.PDG.$02.004": "In response to a $02 request, for a given PFP, if FFN is not defined and the PID is 0x02,\n              then the platform  shall  respond with 0x0000 for the corresponding PID data.\n            Rationale: \n              See Table 11 e. 1) in the J1979 SEP2010 standard.",
    "LLR.PLAT.PDG.$02.005": "In response to a $02 request, for a given PFP, if FFN is not defined and the PID is 0x00,\n              then the platform  shall  respond with 0x40 0x00 0x00 0x00 (in message order) for the\n              corresponding PID data.\n            Rationale: \n              Although Table 11 in the J1979 SEP2010 standard indicates that the ECU should respond with PID-supported\n              PIDs for frame xx when no freeze frame is stored (see condition e., case 2), this is superseded by\n              section 8.2.4.2 Case #3 Multiple Freeze Frames where in describing the case of dynamic PID support data\n              it says \"requesting PID support data before a freeze frame is stored would indicate that only PID $02\n              is supported\". Only the latter makes sense for the reasons given in that section.",
    "LLR.PLAT.PDG.$02.006": "In response to a $02 request, for a given PFP, if FFN is not defined and the PID is anything other\n              than 0x00 or 0x02, then the platform  shall  ignore that PID.\n            Rationale: \n              See rationale for LLR.PLAT.PDG.$02.005.",
    "LLR.PLAT.PDG.$02.007": "In response to a $02 request, for any PFP, if the PID is a PSP and FFN is defined,\n              if no PIDs are included in that PSP's or any subsequent range,\n              then the platform  shall  ignore the PSP.\n            Rationale: \n              Section 8.2.2.2 in the J1979 SEP2010 standard says \"The ECU shall not respond to unsupported PID ranges\n              unless subsequent ranges have a supported PID(s)\".",
    "LLR.PLAT.PDG.$02.008": "In response to a $02 request, for any PFP that has not been excluded from consideration\n              by other requirements, if the PID is a PSP and FFN is defined, then the platform  shall \n              respond as defined in detail in LLR.PLAT.PDG.$01.006.",
    "LLR.PLAT.PDG.$02.009": "In response to a $02 request, for any PFP that has not been excluded from consideration\n              by other requirements, if the PID is a PSP and FFN is defined, if any PIDs are included\n              in any subsequent range, then the platform  shall  respond to the PSP and set the LS bit\n              of the fourth byte to one.",
    "LLR.PLAT.PDG.$02.015": "In response to a $02 request, for any PFP that has not been excluded from consideration\n              by other requirements, if the PID is a PSP and FFN is defined, if some PIDs are included\n              in that PSP's range but no PIDs are included in any subsequent range, then the platform\n               shall  respond to the PSP and set the least significant bit of the fourth byte to zero.",
    "LLR.PLAT.PDG.$02.010": "In response to a $02 request, for a given PFP that has not been excluded from\n              consideration by other requirements, if FFN is defined and the PID is 0x02, then the\n              platform  shall  respond with the corresponding PID data set to the identifier of the\n              DTC that caused the freeze frame to be captured.",
    "LLR.PLAT.PDG.$02.011": "In response to a $02 request, for a given PSP, if FFN is defined and the PID is\n              a DVP that is not included in the freeze frame, then the platform  shall  ignore\n              the requested PID.",
    "LLR.PLAT.PDG.$02.012": "In response to a $02 request, for a given PFP that has not been excluded from\n              consideration by other requirements, if FFN is defined and the PID is a DVP that\n              is included in the freeze frame, then the platform  shall  respond with the\n              corresponding PID data value captured in that freeze frame.",
    "LLR.PLAT.PDG.$02.013": "In response to a $02 request, if all PFPs are to be ignored by the platform\n              as specified by the other requirements related to this service, then the\n              platform  shall  not send any message in response.",
    "LLR.PLAT.PDG.$02.014": "In response to a $02 request, if at least one PFP requires a response,\n              then the platform  shall  send a message in response in the format described above\n              in the \"Request Powertrain Freeze Frame Data Response $42\" table, with one dataset\n              for each PFP for which a response is required, within 50 ms.",
    "LLR.PLAT.PDG.$02.017": "In response to a $02 request, the platform  shall  output the PID data with\n              the same scaling as used in J1979 service $01.",
    "LLR.PLAT.PDG.$03.001": "The platform  shall  receive and process valid J1979 ReadEmissionRelatedDTCs (0x03)\n              requests from the test tool, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.3.2.1.",
    "LLR.PLAT.PDG.$03.002": "In response to a valid J1979 service $03\n              request from the test tool, the platform  shall  transmit a positive response containing\n              information related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, and are in Active state,\n              with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.3.1, 8.3.2.2, 8.3.3.",
    "LLR.PLAT.PDG.$03.005": "If the interface parameter pdgc_override_service_03 indicates that both Active and Previously Active DTCs are to be\n              included in a J1979 service $03 response, the platform\n               shall , in addition to that defined in requirement LLR.PLAT.PDG.$03.002, supply the information\n              related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, and are in the Prevously Active state,\n              with format as defined by J1979.\n            Note: \n              The savanna project requires that the standard response to a J1979 service $03 request can be overridden.\n              Information for both Active and Previously Active DTCs is included in this case.",
    "LLR.PLAT.PDG.$03.004": "If the J1979 service $03 request contains additional bytes (i.e. length is greater than one byte),\n              the platform  shall  transmit a negative response with error code of subFunctionNotSupported (0x12)",
    "LLR.PLAT.PDG.$04.001": "The platform  shall  receive and process valid J1979 ClearEmissionRelatedDTCs (0x04)\n              requests from the test tool, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.2.1.",
    "LLR.PLAT.PDG.$04.003": "In response to a valid J1979 service $04 request from the test tool,\n              the platform  shall  transmit a positive response, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.2.2.",
    "LLR.PLAT.PDG.$04.004": "When a valid J1979 service $04 request is received from the test tool, the platform  shall  clear\n              all DTCs which have a minimum emission severity level defined by the application in LLR.PLAT.PDG.INTERF.010,\n              are selected for reporting over ISO-15765, and may be be cleared according to the constraints\n              specified in LLR.PLAT.DTC.CLEARCONDITIONS requirements.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.1.",
    "LLR.PLAT.PDG.$04.005": "When a valid J1979 service $04 request is received from the test tool, the platform  shall  clear any stored freeze-frame\n              data for emissions-related DTCs that have been cleared.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.1.",
    "LLR.PLAT.PDG.$04.006": "When a valid J1979 service $04 request is received from the test tool, the platform  shall  clear all on-board monitoring\n              test results for emissions-related components and systems as specified in LLR.PLAT.PPR.TEST.006.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.1.",
    "LLR.PLAT.PDG.$04.007": "When a valid J1979 service $04 request is received from the test tool, the platform  shall  notify the application that\n              this request has been received as specified in LLR.PLAT.DTC.TABLECLEARED.001.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.4.1.  All PIDs specified here must be provided by the application, so the\n              application must be notified that a clear request has been received.",
    "LLR.PLAT.PDG.$04.002": "If the J1979 service $04 request contains additional bytes (i.e. length is greater than one byte),\n              the platform  shall  transmit a negative response with error code of conditionsNotCorrect (0x22)",
    "LLR.PLAT.PDG.$06.001": "The platform  shall  receive and process valid J1979 requestOBDTestResults (0x06)\n              requests from the test tool, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.6.2.1, 8.6.2.3",
    "LLR.PLAT.PDG.$06.002": "When a valid J1979 service $06 request for range(s) of OBDMIDs supported is received from the test tool,\n              the platform  shall  return range(s) of OBDMIDs supported as defined by J1979, for DMEs which are selected for reporting over ISO-15765.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.6.1, 8.6.2.1, 8.6.2.2.\n            \n              DMEs that are marked as not-in-use will not be considered in the response.",
    "LLR.PLAT.PDG.$06.003": "When a valid J1979 service $06 request is received from the test tool,\n              and a DME exists which reports this OBDMID over ISO-15765,\n              the platform  shall  return test results as defined by J1979,\n              for all DTEs which belong to this DME and are selected for reporting over ISO-15765.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.6.1, 8.6.2.4, 8.6.3.6, 8.6.3.7, 8.6.3.8.\n            \n              DTEs that are marked as not-in-use will not be considered in the response.",
    "LLR.PLAT.PDG.$06.004": "If there is no DME supported for the specified OBDMID, or if there are no DTEs supported\n              for this DME, then the platform  shall  send no response.\n            Note: \n              Source: J1979 Revised SEP2010, section 6.2.4.3.7, Table 11.",
    "LLR.PLAT.PDG.$06.007": "If a J1979 service $06 request is received requesting one or more ranges of OBDMIDs supported as specified in LLR.PLAT.PDG.$04.002\n              and one or more OBDMIDs as specified in LLR.PLAT.PDG.$04.003, the platform  shall  only provide a response to the\n              ranges of OBDMIDs supported.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.6.1, states that the test equipment shall not request a combination of\n              ranges of OBDMIDs supported and OBDMIDs.\n              A design decision was taken to supply just the support status.",
    "LLR.PLAT.PDG.$06.006": "If a J1979 service $06 request is received requesting multiple OBDMIDs as specified in LLR.PLAT.PDG.$04.003,\n              the platform  shall  transmit a negative response with error code of subfunctionNotSupported (0x12)\n            Note: \n              Source: J1979 Revised SEP2010, section 8.6.1, states that the test equipment shall only request a single OBDMID.",
    "LLR.PLAT.PDG.$07.001": "The platform  shall  receive and process valid J1979 ReadEmissionDTCsPending (0x07)\n              requests from the test tool, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.7.2.1.",
    "LLR.PLAT.PDG.$07.002": "In response to a valid J1979 service $07\n              request from the test tool, the platform  shall  transmit a positive response containing\n              information related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, and are in Pending state,\n              with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.7.1, 8.7.2.2.",
    "LLR.PLAT.PDG.$07.005": "If the interface parameter pdgc_override_service_07 indicates that both Pending and Active DTCs are to be\n              included in a J1979 service $07 response, the platform\n               shall , in addition to that defined in requirement LLR.PLAT.PDG.$07.002, supply the information\n              related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, and are in the Active state,\n              with format as defined by J1979.\n            Note: \n              The savanna project requires that the standard response to a J1979 service $07 request can be overridden.\n              Information for both Pending and Active DTCs is included in this case.",
    "LLR.PLAT.PDG.$07.003": "If the J1979 service $07 request contains additional bytes (i.e. length is greater than one byte),\n              the platform  shall  transmit a negative response with error code of subFunctionNotSupported (0x12)",
    "LLR.PLAT.PDG.$09.001": "If a service $09 request is received requesting multiple Infotypes that are not ISI, then the platform  shall  ignore the request.\n            Rationale: \n              SAE J1979 SEP2010 8.9.1 says \"A request message including an InfoType which reports vehicle information\n              shall only contain one (1) InfoType.\"",
    "LLR.PLAT.PDG.$09.020": "In response to a $09 request, if the first Infotype is an ISI and the message length is not between\n              2 bytes and 7 bytes inclusive in length, then the platform  shall  ignore the request.\n            Rationale: \n              SAE J1979 SEP2010 8.9.1 says \"The request message including supported InfoTypes may contain up to\n              six (6) InfoTypes.\"",
    "LLR.PLAT.PDG.$09.002": "If a service $09 request is received requesting one or more ISIs and one or more Infotypes,\n              the platform  shall  ignore any InfoTypes that are not ISIs.\n            Rationale: \n              SAE J1979 SEP2010 8.9.1 forbids external tester tool from requesting a mix of ISIs and non-ISIs.",
    "LLR.PLAT.PDG.$09.003": "In response to a $09 request, for any requested ISI, if no InfoTypes are included\n              in its or any subsequent range, then the platform  shall  ignore the ISI.",
    "LLR.PLAT.PDG.$09.004": "In response to a $09 request, for every ISI, if any InfoTypes are included in its range,\n              then the platform  shall  respond to the ISI with bits set for supported InfoTypes and clear\n              otherwise following the bitmap definition in LLR.PLAT.PDG.$01.006.",
    "LLR.PLAT.PDG.$09.019": "In response to a $09 request InfoTypes supported, whenever the In-use Performance Tracking\n              (IPT) InfoType $0B is in the range of an ISI, the platform  shall  indicate that it is\n              supported.\n            Rationale: \n              This InfoType is handled by the platform and is currently always supported. That's not a\n              good long term arrangement. See W-CR8494.",
    "LLR.PLAT.PDG.$09.005": "In response to a $09 request, for every ISI, if any InfoTypes are included in any subsequent range,\n              then the platform  shall  respond to the ISI and set the least significant bit of the fourth byte to one.\n            \n          \n            Currently InfoTypes are only defined up to $0F, so there is no way of testing this.",
    "LLR.PLAT.PDG.$09.006": "In response to a $09 request, for every ISI, if some InfoTypes are included in range but no InfoTypes are\n              included in any subsequent range, then the platform  shall  respond to the ISI and set the least significant\n              bit of the fourth byte to zero.",
    "LLR.PLAT.PDG.$09.007": "In response to a $09 request of ISIs, if no ISIs require a response, then the ECU  shall  ignore\n              the request.",
    "LLR.PLAT.PDG.$09.008": "In response to a $09 request of ISIs, if at least one ISI requires a response, then the ECU  shall \n              respond within 50ms with data for each ISI that requires a response in the format shown in Table 186\n              of SAE J1979 SEP2010.",
    "LLR.PLAT.PDG.$09.009": "In response to a $09 request with a non-ISI, if that InfoType is not supported, then the platform\n               shall  ignore the request.",
    "LLR.APP.PDG.$09.001": "The application  will  provide a suitable default VIN until the actual VIN has been programmed.\n            Rationale: \n              J1979 SEP2010 Section 8.9.1 final para states that the ECU shall respond to VIN (if supported) even before\n              it has been programmed (and suggests $FF characters in that case). The platform simply responds with whatever\n              value it has been passed by the application, so it is an application responsibility to make suitable data\n              available in this case.",
    "LLR.PLAT.PDG.$09.010": "In response to a $09 request for the Calibration Verification Numbers (CVN) InfoType ID $06,\n              if that InfoType is supported and the CVN is available, then the platform  shall  respond\n              with the data in the format shown in Table 188 of SAE J1979 SEP2010, with the NODI byte\n              set to 1.\n            Rationale: \n              The platform only supports one CVN.",
    "LLR.PLAT.PDG.$09.011": "In response to a $09 request for the Calibration Verification Numbers (CVN) InfoType ID $06,\n              if that InfoType is supported and the CVN is being calculated for the first time since the\n              ECU was powered on, then the platform  shall  respond with a Negative Response Code $78.",
    "LLR.PLAT.PDG.$09.012": "In response to a $09 request for the Calibration Verification Numbers (CVN) InfoType ID $06,\n              if the platform has sent a $78 response and the CVN is still not available after 4500 ms, then\n              the platform  shall  send another $78 response.\n            Rationale: \n              The platform must keep sending \"Response pending\" messages with no more than 5 seconds between them\n              until a positive response is available. See SAE J1979 SEP2010 Table 11 row z. 4.5 seconds is just a\n              time internal that is close to but comfortably less than 5 seconds.",
    "LLR.PLAT.PDG.$09.013": "In response to a $09 request for the Calibration Verification Numbers (CVN) InfoType ID $06,\n              if the platform has sent a $78 response and the CVN becomes available, then the platform\n               shall  send a positive response containing the CVN in the format shown in Table 188 of SAE\n              J1979 SEP2010, with the NODI byte set to 1.",
    "LLR.PLAT.PDG.$09.014": "In response to a $09 request for the Calibration Identifications (CALID) InfoType ID $04,\n              and that InfoType is supported then the platform  shall  send a positive response in the\n              format shown in Table 188 of SAE J1979 SEP2010, with the NODI byte set to 1.\n            Rationale: \n              The platform only supports one Calibration Identification.",
    "LLR.PLAT.PDG.$09.015": "In response to a $09 request for the In-use Performance Tracking (IPT) InfoType $0B,\n              then the platform  shall  send a positive response in the format shown in Table 188 of\n              SAE J1979 SEP2010, with the NODI byte set to 18.\n            Rationale: \n              The platform only supports the 18 counter option on this InfoType. If the Fuel Monitor\n              bytes are not supported, the standard allows the values to be reported as $0000 (see\n              Table G11 of SAE J1979 SEP2010).",
    "LLR.PLAT.PDG.$09.016": "In response to a $09 request for any of the InfoTypes listed below, if that InfoType\n              is supported then the platform  shall  send a positive response in the format shown\n              in Table 188 of SAE J1979 SEP2010, with the NODI byte set to 1.\n            Table\u00a03.11.\u00a0Other InfoTypes supported\n                      Name\n                    \n                      Acronym\n                    \n                      Infotype\n                    Vehicle Identification NumberVIN$02ECUNAME-$0AEngine Serial NumberESN$0DExhaust Regulation Or Type ApprovalEROTAN$0FRationale: \n              The platform currently only supports a defined list of InfoTypes, any of which the\n              application can then choose to support.",
    "LLR.PLAT.PDG.$09.022": "When an initial response is required to a $09 request, the platform  shall  respond within 50 ms.",
    "LLR.PLAT.PDG.$0A.001": "The platform  shall  receive and process valid J1979 ReadEmissionDTCsPermanent (0x0A)\n              requests from the test tool, with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, section 8.7.2.1.",
    "LLR.PLAT.PDG.$0A.002": "In response to a valid J1979 service $0A\n              request from the test tool, the platform  shall  transmit a positive response containing\n              information related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, are in Active state,\n              and are configured as permanent DTCs,\n              with format as defined by J1979.\n            Note: \n              Source: J1979 Revised SEP2010, sections 8.7.1, 8.7.2.2.",
    "LLR.PLAT.PDG.$0A.004": "If the interface parameter pdgc_override_service_0a indicates that both Active and Previously Active DTCs are to be\n              included in a J1979 service $0A response, the platform\n               shall , in addition to that defined in requirement LLR.PLAT.PDG.$0A.002, supply the information\n              related to all the DTCs which have a minimum emission severity level as specified by\n              LLR.PLAT.PDG.INTERF.010, are selected for reporting over ISO-15765, and are in the Prevously Active state,\n              with format as defined by J1979.\n            Note: \n              The savanna project requires that the standard response to a J1979 service $0A request can be overridden.\n              Information for both Active and Previously Active DTCs is included in this case.",
    "LLR.PLAT.PDG.$0A.003": "If the J1979 service $0A request contains additional bytes (i.e. length is greater than one byte),\n              the platform  shall  transmit a negative response with error code of subFunctionNotSupported (0x12).",
    "LLR.PLAT.PDG.$10.001": "If an 0x10 request is received with any number of\n              parameter bytes not equal to 1, the platform  shall  respond with a negative\n              \u201csubfunction not supported\u201d response. Otherwise, the following\n              requirements apply.",
    "LLR.PLAT.PDG.$10.002": "If an 0x10 request is received with a session value of\n              0x02 or 0x82 (programmingSession\n              value from UDS) or 0x85 (programmingSession\n              value from KW2000-3), and reprogramming has not been disabled by the application,\n              and the ECU is not currently in a defaultSession,\n              the platform  shall  emit a positive response if required (see below) and then pass\n              control to the boot loader. (The boot loader is then responsible for executing the\n              programming process.)",
    "LLR.PLAT.PDG.$10.016": "The platform  shall  reject a request to enter programmingSession directly from defaultSession.\n            Rationale: \n              The HIS reprogramming specification shows the tester having to attain\n              extendedSession before programmingSession so we enforce that.",
    "LLR.PLAT.PDG.$10.003": "If the programmingSession entry is to proceed according to the\n              above, and the suppressPosRspMsgIndicationBit was not set in the\n              requested session value (as per requirement [LLR.PLAT.PDG.UDS.001]), then the platform,\n               shall  emit a positive response otherwise not.",
    "LLR.PLAT.PDG.$10.004": "If the tool requested a reprogramming session as in LLR.PLAT.PDG.$10.002 but the\n              application has disabled reprogramming, the platform  shall  respond with a\n              negative response of 'conditions not correct'.",
    "LLR.PLAT.PDG.$10.005": "If an 0x10 request is received with a session value of\n              0x01 (for UDS) or 0x81 (UDS with\n              suppressed response OR KW2000-3), i.e.\n              defaultSession,\n              the platform  shall  clear any active PID overrides, reset DTC control settings (if\n              changed in extendedDiagnosticSession via 0x85) and reset communications (if changed\n              in extendedDiagnosticSession via 0x28) and return a positive response.\n            \n              Note: in boot loader mode, the ECU  shall  attempt to return to normal application\n              mode (by causing a reset) after it has responded; however, these requirements do not\n              yet formally apply to boot mode. This transition from boot loader mode back to\n              application mode is shown in the HIS flash reprogramming specification.\n            Rationale: \n              Resetting of active PID overrides is not strictly required to support reprogramming,\n              but included for completeness for\n              this service. UDS specifies has the clearing of temporary settings.\n            \n              The issued KW2000-3 does not detail any session values, but the draft copy\n              lists 0x81 as \"defaultMode-StandardDiagnosticMode-OBDIIMode\". However, this has\n              bit 7 set, which in UDS means \"suppress response\". On the assumption that a KWP\n              tool is likely to object if we omit the response, while a UDS tool that did\n              not require a response is less likely to object to receiving one anyway, we\n              do emit a response for this value.",
    "LLR.PLAT.PDG.$10.015": "If no diagnostic communication is received for the S3 timeout period (5 sec),\n              the platform  shall  make a transition to defaultSession.\n            \n              Note: in boot loader mode, which these requirements to not formally cover,\n              returning to defaultSession involves doing a reset back to application mode\n              (if possible). That is done only if we were in reprogramming mode due to a\n              diagnostic command or if a diagnostic command was received while we were there.\n              Otherwise, we don't want to do a reset which would kill a CCP session for example.\n            Rationale: \n              See the description of S3server in ISO 15765-3.",
    "LLR.PLAT.PDG.$10.013": "The platform  shall  append session parameter value bytes to any positive response\n              sent for this service as required by the HIS reprogramming\n              specification (see HIS-UAK-FLK-172 in that document):\n            \n              Table\u00a03.12.\u00a0Service $10 Session Parameter ValuesByteValue0P2[Can_Server_max] high byte1P2[Can_Server_max] low byte0P2*[Can_Server_max] high byte1P2*[Can_Server_max] low byte\n            \n              Where P2[Can_Server_max] = 50 ms (normal response time) and P2*[Can_Server_max]\n              = 5000 ms (response time if a wait response has been sent; but in practice,\n              we cannot send anything during flash erase, which is the slow operation).\n              (The 5000 ms value comes from older versions of ISO 15031-5\/J1979.)",
    "LLR.PLAT.PDG.$10.006": "If an 0x10 request is received with any other session value, the\n              platform  shall  respond with a negative response of \u201csubfunction not supported\u201d.",
    "LLR.PLAT.PDG.$10.007": "Reprogramming functions  shall  not be supported for a request coming over\n              functional addressing.",
    "LLR.PLAT.PDG.$10.010": "If an 0x10 request is received with a session value of 0x03\n              (extendedDiagnosticSession value from UDS), the platform  shall  emit a\n              positive response if required (see below) and switch to extended\n              diagnostics mode.",
    "LLR.PLAT.PDG.$10.011": "If the extendedDiagnosticSession is to proceed according to the above,\n              and the suppressPosRspMsgIndicationBit was not set in the requested\n              session value (as per requirement [LLR.PLAT.PDG.UDS.001]), then the platform\n               shall  emit a positive response, otherwise not.",
    "LLR.PLAT.PDG.$10.012": "The platform  shall  support requests ControlDTCSetting (0x85) and\n              CommunicationControl (0x28) only when in extendedDiagnosticSession mode.\n            \n              \n                Note: for Torchwood, support for services ControlDTCSetting\n                 will  be added later.",
    "LLR.PLAT.PDG.$10.014": "If an 0x10 request is received such that the change in diagnostic session\n              is via an ECU reset, then a pending response  shall  be provided prior to the\n              ECU reset and the positive response shall be provided as soon as possible following\n              the ECU reset.\n            \n              This is to ensure the diagnostic tester does not provide additional diagnostic\n              requests while the ECU is in reset.",
    "LLR.PLAT.PDG.$14.001": "The platform  shall  receive and process valid KW2000-3 and UDS ClearDiagInfo (0x14)\n              requests from the test tool, with formats as defined by KW2000-3 and ISO 14229-1.\n            Note: \n              Source: KW2000-3 v1.5, section 8.5.2., ISO 14229-1 section 11.2",
    "LLR.PLAT.PDG.$14.002": "In response to a valid KW2000-3 or UDS service $14 request from the test tool,\n              the platform  shall  transmit a positive response, with format as defined by KW2000-3 or ISO 14229-1 respectively.\n            Note: \n              Source: KW2000-3 v1.5, section 8.5.2., ISO 14229-1 section 11.2",
    "LLR.PLAT.PDG.$14.003": "If the service $14 request specifies a \"group of diagnostic information\" which is not supported,\n              the platform  shall  transmit a negative response with error code of requestOutOfRange (0x31).",
    "LLR.PLAT.PDG.$14.004": "If the service $14 request contains incorrect number of bytes,\n              the platform  shall  transmit a negative response with an error code of incorrectMessageLength (0x13) if UDS errors is to be chosen\n              and error code of subfunctionNotSupported (0x12) otherwise.\n            Note: \n              The platform shall assume UDS error codes for now since no customers have any interest in preferring KW2000-3 currently.",
    "LLR.PLAT.PDG.$14.011": "The platform  shall  accept the following groupOfDTC values:\n              Table\u00a03.13.\u00a0Allowable groupOfDTC values - request 0x14KWPUDSDescription0000000000Powertrain (P0000-P3FFF)4000400000Chassis (C0000-C3FFF)8000800000Body (B0000-B3FFF)C000C00000Network (U0000-U3FFF)FF00FFFFFFAll DTCs\n                Source: KW2000-3 section 8.2.1.1.1 and ISO 14229-1 Annex D.1.",
    "LLR.PLAT.PDG.$14.006": "When a valid service $14 request is received from the test tool, the platform  shall  clear\n                all DTCs which are selected for reporting over ISO-15765 in the group specified,\n                and may be be cleared according to the constraints\n                specified in LLR.PLAT.DTC.CLEARCONDITIONS requirements.",
    "LLR.PLAT.PDG.$14.007": "When a valid service $14 request is received from the test tool, the platform  shall  clear any stored freeze-frame\n                data for DTCs that have been cleared.",
    "LLR.PLAT.PDG.$14.008": "When a valid service $14 request is received from the test tool, the platform  shall  clear all on-board monitoring\n                test results for components and systems as specified in LLR.PLAT.PPR.TEST.006.\n              Note\n                  This is done for all DTEs irrespective of the groupOfDTC, because the platform has no\n                  knowledge of how DTEs are linked to DTCs.",
    "LLR.PLAT.PDG.$14.009": "When a valid service $14 request is received from the test tool, the platform  shall  notify the application that\n                this request has been received as specified in LLR.PLAT.DTC.TABLECLEARED.001.\n              Note: \n                Source: J1979 Revised SEP2010, section 8.4.1.  Clearing DTCs via service $14 with group 0xFF00 will clear\n                DTCs that would be cleared by service $04.  As for service $04, the application must be notified\n                that a clear request has been received.\n              Note\n                \n                  Again this is done irrespective of the groupOfDTC selected, on the assumption that if\n                  the application must count engine hours (for example) \"since faults cleared\" this\n                  counts if any successful fault-clearing service has executed. The standards are\n                  silent in this regard.",
    "LLR.PLAT.PDG.$17.001": "The platform  shall  receive and process valid KW2000-3 ReadStatusOfDTC (0x17)\n              requests from the test tool, with format as defined by KW2000-3.\n            Note: \n              Source: KW2000-3 v1.5, section 8.3.2.",
    "LLR.PLAT.PDG.$17.002": "When a valid KW2000-3 service $17 request is received from the test tool specifying a group of diagnostic information according to SAE J2012,\n                and the ECU contains DTCs reported over ISO-15765 which match this group, the platform  shall  transmit a positive response containing the\n                status of each DTC as specified in table Status of DTC value in - responses for 0x17 & 0x18.\n            \n                Group values are:-\n                0x0000: Powertrain DTCs (requesting DTCs with IDs 0x0001 to 0x3999)0x4000: Chassis DTCs (requesting DTCs with IDs 0x4001 to 0x7999)0x8000: Body DTCs (requesting DTCs with IDs 0x8001 to 0xB999)0xC000: Network communication DTCs (requesting DTCs with IDs 0xC001 to 0xF999)0xFF00: All DTCs\n            Note: \n              Source: KW2000-3 v1.5, sections 8.3.1.1, 8.3.2.\n            \n              Note that the \"All DTCs\" group is not specified in section 8.3.1.1, but is specified in section 8.2.1.1.1.\n              As such, it is considered desirable to use it for this service too.",
    "LLR.PLAT.PDG.$17.003": "When a valid KW2000-3 service $17 request is received from the test tool specifying a single DTC, and the\n              ECU contains a DTC reported over ISO-15765 which matches this, the platform  shall  transmit a positive response containing the\n              status of this DTC as specified in table Status of DTC value in - responses for 0x17 & 0x18.\n              Any value which does not match a group from LLR.PLAT.PDG.$17.002 specifies a single DTC.\n            Note: \n              Source: KW2000-3 v1.5, sections 8.3.1.1, 8.3.2.\n            \n              Note that the \"All DTCs\" group is additional to the groups specified by KW2000-3.  This makes the services\n              compatible with services $14 and $18 though, and as such is considered desirable.",
    "LLR.PLAT.PDG.$17.004": "When a valid KW2000-3 service $17 request is received from the test tool specifying a single DTC which is not supported, or\n              a DTC group which has no supported DTCs, the platform  shall  transmit a positive response reporting \"no DTC stored\".\n            Note: \n              Source: KW2000-3 v1.5, sections 8.3.2, 8.3.3.",
    "LLR.PLAT.PDG.$17.005": "If the KW2000-3 service $17 request length is not equal to 3 bytes, the platform  shall  transmit\n              a negative response with error code of subFunctionNotSupported (error 0x12).",
    "LLR.PLAT.PDG.$18.001": "In response to a KW2000-3 ReadDTCByStatus (0x18) request\n              by the test tool for active DTCs (statusOfDTC parameter\n              value of 0x02), the platform  shall  transmit the information\n              related to the DTCs that are in Active or\n              Pending state.\n            Table\u00a03.16.\u00a0Read dtcs by status - positive response (0x02)Byte #Byte descriptionValues1Positive response0x582Number of DTCsNumber of DTCs in response3DTC#1 ID high byte\n                      (where DTC#1 is ISO DTC of the requested groupOfDTC in\n                      active or pending state)\n                      \n                        If group parameter is 0xFF00 or 0xFFFF,\n                        then DTCs of all\n                        groups  will  qualify for this response.\n                      \n                    4DTC#1 ID low byte\n                      (where DTC#1 is ISO DTC of the requested groupOfDTC in\n                      active or pending state)\n                      \n                        If group parameter is 0xFF00 or 0xFFFF, then\n                        DTCs of all\n                        groups  will  qualify for this response\n                      \n                    5DTC#1 stateSee LLR.PLAT.PDG.$18.007 ... Same as 3 to 5 for remaining DTCs that satisfy the group -",
    "LLR.PLAT.PDG.$18.002": "In response to a KW2000-3 ReadDTCByStatus (0x18) request\n              by the test tool for all DTCs (statusOfDTC parameter\n              value of 0x03), the platform  shall  transmit the information\n              related to all the DTCs independent of their state.\n            Table\u00a03.17.\u00a0Read dtcs by status - positive response (0x03)Byte #Byte descriptionValues1Positive response0x582Number of DTCsNumber of DTCs in response3DTC#1 ID high byte\n                      (where DTC#1 is an ISO DTC of the requested groupOfDTC)\n                      \n                        If group parameter is 0xFF00 or 0xFFFF,\n                        then DTCs of all groups qualify\n                        for this response\n                      \n                    4DTC#1 ID low byte\n                      (where DTC#1 is an ISO DTC of the requested groupOfDTC)\n                      \n                        If group parameter is 0xFF00 or 0xFFFF,\n                        then DTCs of all groups qualify\n                        for this response.\n                      \n                    5DTC#1 stateSee LLR.PLAT.PDG.$18.007 ... Same as 3 to 5 for remaining DTCs that satisfy the group",
    "LLR.PLAT.PDG.$18.003": "The data transmitted in response to the KW2000-3 ReadDTCByStatus\n              requests in [LLR.PLAT.PDG.$18.001] and [LLR.PLAT.PDG.$18.002]  shall  include\n              the DTC identifiers and their state information as defined in\n              LLR.PLAT.FUNCTIONALITY.009.",
    "LLR.PLAT.PDG.$18.004": "If there is a KW2000-3 ReadDTCByStatus request with\n              statusOfDTC parameter set to a value other than those mentioned in\n              LLR.PLAT.PDG.$18.002 and LLR.PLAT.PDG.$18.003, then the platform  shall \n              report the error subFunctionNotSupported (error 0x12).",
    "LLR.PLAT.PDG.$18.005": "If the  value for the groupOfDTC parameter of the KW2000-3\n              ReadDTCByStatus request is 0xFF00\n              or 0xFFFF, then OpenECU  shall  respond with information\n              for DTCs of all groups.\n            Rationale: \n              Special values of 0xFF00 and 0xFFFF correspond to ALL groups.",
    "LLR.PLAT.PDG.$18.006": "For all values other than 0xFF00 and 0xFFFF,\n              the platform  will  choose the qualifying DTCs as per the table\n              \"Table 8.3.1.1.1 - Definition of DTC within the parameter groupOfDTC\" in the draft KW2000-3 document.",
    "LLR.PLAT.PDG.$18.007": "The status information transmitted in response to a KW2000-3 ReadDTCByStatus (0x18)\n              request by the test tool,  shall  include the following information.\n            Table\u00a03.18.\u00a0Status transmitted in response to a KW2000-3 ReadDTCByStatusNameDescriptionDTC fault symptom\n                      \n                        A 4-bit code for the DTCs fault symptom. This is application calibratable.\n                      \n                      \n                          0x0 - NONE\n                        \n                          0x1 - ABOVE_MAX\n                        \n                          0x2 - BELOW_MIN\n                        \n                          0x4 - NO_SIGNAL\n                        \n                          0x8 - INVALID_SIGNAL\n                        \n                          0x(-) - Other values up to 0xF are application specific\n                        \n                    DTC Readiness flag\n                      \n                        One-bit indicating whether the tests for this DTC have been run\n                        since the last ClearDiagnostics.\n                      \n                      \n                          0x0 - testComplete\n                        \n                          0x1 - testNotComplete\n                        \n                    Storage state2-bits indicating the current DTC state:\n                      \n                          0x0 - Clear\n                        \n                          0x1 - Inactive\n                        \n                          0x2 - Pending\n                        \n                          0x3 - Active\n                        \n                    Warning Lamp Calibration Status\n                      \n                        One-bit indicating whether the WL is calibrated to be switched on\n                        when DTC is active.\n                      \n                      \n                          0x0 - Disabled\n                        \n                          0x1 - Enabled\n                        \n                    \n              Source: Table 'Definition of statusOfDTC values' in KW2000-3.doc",
    "LLR.PLAT.PDG.$18.008": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x12\n              when length of request is not equal to 4.\n            Table\u00a03.19.\u00a0Read dtcs by status - negative responseByte #Byte descriptionValues1Negative response0x7F2Service ID0x183Error code0x12",
    "LLR.PLAT.PDG.$19.001": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the number of DTCs satisfying the status (subFunction\n              parameter value of 0x01), the platform  shall  transmit\n              the number of ISO DTCs that in the state specified by Status mask\n              parameter.\n            Table\u00a03.21.\u00a0Read dtc info - positive response (0x01 - numOfDTCs)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x013DTCStatusAvailabilityMask0x0F (in accordance with [LLR.PLAT.PDG.$19.017])4Format ID0x00 = ISO15031-6DTCFormat5Number of DTCs \u2013 high byte\n                      High-byte of the number of DTCs that satisfy the criteria\n                      given by Status mask in request\n                    6Number of DTCs \u2013 low byte\n                      Low-byte of the number of DTCs that satisfy the criteria\n                      given by Status mask in request",
    "LLR.PLAT.PDG.$19.002": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the information related to DTCs satisfying the status\n              (subFunction parameter value of 0x02), the platform  shall \n              transmit the information related to the ISO DTCs that in the state specified\n              by Status mask parameter.\n            Table\u00a03.22.\u00a0Read dtc info - positive response (0x02 - DTCInfo)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x023DTCStatusAvailabilityMask0x0F (in accordance with [LLR.PLAT.PDG.$19.017])4DTC#1 ID \u2013 high byte\n                      Where DTC#1 satisfies the criteria given by Status mask\n                      in request.\n                    5DTC#1 ID \u2013 mid byte\n                      Where DTC#1 satisfies the criteria given by Status mask\n                      in request\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    6DTC#1 ID \u2013 low byte\n                      Where DTC#1 satisfies the criteria given by Status mask\n                      in request\n                      \n                        TODO: presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    7Status of DTC#1[0x00 to 0x0B] (in accordance with [LLR.PLAT.PDG.$19.018]) ... Same as 4 to 7 for remaining DTCs that satisfy the group",
    "LLR.PLAT.PDG.$19.014": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the information related to snapshots satisfying the\n              reportSnapshotIdentification (subFunction parameter value of\n              0x03), the platform  shall  transmit the identification\n              information related to stored snapshots.\n            Table\u00a03.23.\u00a0Read dtc info - positive response (0x03 - reportDTCSnapshotIdentification)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x033DTC#1 ID \u2013 high byte 4DTC#1 ID \u2013 mid byte\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    5DTC#1 ID \u2013 low byte\n                      \n                        Presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    6DTCSnapshotRecordNumber #n[0x00 to 0x01] ... Same as 3 to 6 for remaining snapshots",
    "LLR.PLAT.PDG.$19.015": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the information related to snapshots satisfying the\n              reportDTCSnapshotRecordByDTCNumber (subFunction parameter value of\n              0x04), the platform  shall  transmit the stored snapshot\n              data corresponding to the DTC specified in the DTCMaskRecord\n              and the record number specified in the DTCSnapshotRecordNumber.\n            Table\u00a03.24.\u00a0Read dtc info - positive response (0x04 - reportDTCSnapshotRecordByDTCNumber)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x043DTC ID \u2013 high byte 4DTC ID \u2013 mid byte\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    5DTC ID \u2013 low byte\n                      \n                        Presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    6Status of DTC[0x00 to 0x0B] (in accordance with [LLR.PLAT.PDG.$19.018])7DTCSnapshotRecordNumber #1[0x00 to 0x01]8DTCSnapshotRecordNumberOfIdentifiers #1[0x00 to 0xFF]9dataIdentifier #1 byte #1[0x00 to 0xFF]10dataIdentifier #1 byte #2[0x00 to 0xFF]11snapshotData #1 byte #1[0x00 to 0xFF]12...tSame as 11 for remaining snapshotData #1 bytes[0x00 to 0xFF]t+1...kSame as 9 to t for remaining DTCSnapshotRecordNumber #1 dataIdentifiers\u00a0...Same as 7 to k for remaining DTCSnapshotRecordsAll snapshot records stored for the DTC are reported when\n                      DTCSnapshotRecordNumber 0xFF is requested.",
    "LLR.PLAT.PDG.$19.016": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the information related to DTC extended data records\n              satisfying the reportDTCExtendedDataRecordByDTCNumber (subFunction parameter value of\n              0x06), the platform  shall  transmit the stored snapshot\n              data corresponding to the DTC specified in the DTCMaskRecord\n              and the DTC extended data record number specified in the\n              DTCExtendedDataRecordNumber.\n            Table\u00a03.25.\u00a0Read dtc info - positive response (0x06 - reportDTCExtendedDataRecordByDTCNumber)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x063DTC ID \u2013 high byte 4DTC ID \u2013 mid byte\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    5DTC ID \u2013 low byte\n                      \n                        Presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    6Status of DTC[0x00 to 0x0B] (in accordance with [LLR.PLAT.PDG.$19.018])7DTCExtendedDataRecordNumber #1[0x01 to 0xEF]8extendedData #1 byte #1[0x00 to 0xFF]9extendedData #1 byte #2 (Optional)[0x00 to 0xFF]...Same as 7 to 9 for remaining DTCExtendedDataRecordsAll configured extended records for the DTC are reported\n                      when DTCExtendedDataRecord 0xFF is requested.",
    "LLR.PLAT.PDG.$19.005": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportNumberOfDTCBySeverityMaskRecord\" (subFunction\n              parameter value of 0x07), the platform  shall  transmit\n              the number of ISO DTCs that have at least one matching bit set in BOTH a) the\n              supplied DTCStatusMask AND b) the supplied DTCSeverityMask.\n            Note\n                UDS represents that condition thus (the middle '&' is assumed to be a logical\n                not bitwise one):\n              ((statusOfDTC & DTCStatusMask) & (severity & DTCSeverityMask)) != 0Table\u00a03.26.\u00a0Read dtc info - positive response (0x07 - reportNumberOfDTCBySeverityMaskRecord)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x073DTCStatusAvailabilityMask0x0F (in accordance with [LLR.PLAT.PDG.$19.017])4Format ID0x00 = ISO15031-6DTCFormat5Number of DTCs \u2013 high byte\n                      High-byte of the number of DTCs that satisfy the criteria\n                      given in request\n                    6Number of DTCs \u2013 low byte\n                      Low-byte of the number of DTCs",
    "LLR.PLAT.PDG.$19.006": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportDTCBySeverityMaskRecord\"\n              (subFunction parameter value of 0x08),\n               the platform  shall  transmit the status information related to\n              the ISO DTCs that have at least one matching bit set in BOTH a) the\n              supplied DTCStatusMask AND b) the supplied DTCSeverityMask.\n            Table\u00a03.27.\u00a0Read dtc info - positive response (0x08 - reportDTCBySeverityMaskRecord)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x083DTCStatusAvailabilityMask0x0F (in accordance with [LLR.PLAT.PDG.$19.017])4DTC#1 \u2013 UDS severity value\n                      Where DTC#1 is a matching DTC.\n                    50x00\n                      (The implementation-specific DTCFunctionalUnit is not currently supported.)\n                    6DTC#1 ID \u2013 high byte\n                    7DTC#1 ID \u2013 mid byte\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    8DTC#1 ID \u2013 low byte\n                      \n                        TODO: presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    9Status of DTC#1[0x00 to 0x0B] (in accordance with [LLR.PLAT.PDG.$19.018]) ... Same as 4 to 9 for all remaining supported DTCs",
    "LLR.PLAT.PDG.$19.007": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportSeverityInformationOfDTC\"\n              (subFunction parameter value of 0x09),\n               the platform  shall  transmit the status information related to\n              the first ISO DTC matching the ID specified in the request message,\n              or else a negative response if there is no match.\n            NoteThe UDS specification does not indicate what to do if there\n                    is no matching DTC. Sending a negative response is assumed here.\n              The response format is the same as for 0x08 reportDTCBySeverityMaskRecord above,\n              but with only one DTC reported.",
    "LLR.PLAT.PDG.$19.004": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for the information of all supported DTCs (subFunction parameter value of 0x0A),\n              the platform  shall  transmit the status information related to all the ISO DTCs.\n              The format of the response shall be as specified in the ISO 14229 specification.\n            Table\u00a03.28.\u00a0Read dtc info - request 0x19 reportSupportedDTCByte #Byte descriptionValues1Service ID0x192Subfunction request0x0ATable\u00a03.29.\u00a0Read dtc info - positive response (0x0A - DTCInfo for all supported DTCS)Byte #Byte descriptionValues1Positive response0x592Subfunction request0x0A3DTCStatusAvailabilityMask0x0F (in accordance with [LLR.PLAT.PDG.$19.017])4DTC#1 ID \u2013 high byte\n                      Where DTC#1 is a supported DTC.\n                    5DTC#1 ID \u2013 mid byte\n                      Where DTC#1 is a supported DTC.\n                      \n                        Note: This is lower byte of 16 bit DTC ID.\n                      \n                    6DTC#1 ID \u2013 low byte\n                      Where DTC#1 is a supported DTC.\n                      \n                        TODO: presently set to 0x00 since we are supporting\n                        16-bit DTC identifiers at present\n                      \n                    7Status of DTC#1[0x00 to 0x0B] (in accordance with [LLR.PLAT.PDG.$19.018]) ... Same as 4 to 7 for all remaining supported DTCs",
    "LLR.PLAT.PDG.$19.008": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportFirstTestFailedDTC\"\n              (subFunction parameter value of 0x0B),\n               the platform  shall  transmit the status information related to\n              the first ISO DTC which failed its test (reached a PENDING state)\n              since fault information was cleared (requiring NVM storage).\n            \n              The response format is the same as for 0x0A reportSupportedDTCs above,\n              but with only one DTC reported. If no DTC has yet failed, then zero\n              DTCs are reported (response ends at DTCStatusAvailabilityMask byte).",
    "LLR.PLAT.PDG.$19.009": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportFirstConfirmedDTC\"\n              (subFunction parameter value of 0x0C),\n               the platform  shall  transmit the status information related to\n              the first ISO DTC which reached an ACTIVE state\n              since fault information was cleared (requiring NVM storage).\n            \n              The response format is the same as for 0x0B reportFirstTestFailedDTC above.",
    "LLR.PLAT.PDG.$19.010": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportMostRecentTestFailedDTC\"\n              (subFunction parameter value of 0x0D),\n               the platform  shall  transmit the status information related to\n              the ISO DTC which most recently reached a PENDING state\n              since fault information was cleared (requiring NVM storage).\n            \n              The response format is the same as for 0x0B reportFirstTestFailedDTC above.",
    "LLR.PLAT.PDG.$19.011": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportMostRecentConfirmedDTC\"\n              (subFunction parameter value of 0x0E),\n               the platform  shall  transmit the status information related to\n              the ISO DTC which most recently reached an ACTIVE state (requiring NVM storage).\n            \n              The response format is the same as for 0x0B reportFirstTestFailedDTC above.",
    "LLR.PLAT.PDG.$19.012": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportNumberOfEmissionsRelatedOBDDTCByStatusMask\" (subFunction\n              parameter value of 0x12), the platform  shall  transmit\n              the number of ISO DTCs that have BOTH a) have at least one matching bit set\n              in the supplied DTCStatusMask AND b) are emissions-related (emissions severity\n              equal or greater than calibrated threshold for emissions-related reporting).\n            \n              The response format is the same as that for subfunction $01 reportNumberOfDTCByStatusMask above.",
    "LLR.PLAT.PDG.$19.013": "In response to a ReadDTCInformation (0x19) request by\n              the test tool for \"reportEmissionsRelatedOBDDTCByStatusMask\" (subFunction\n              parameter value of 0x13), the platform  shall  transmit a list\n              of the ISO DTCs that have BOTH a) have at least one matching bit set\n              in the supplied DTCStatusMask AND b) are emissions-related (emissions severity\n              equal or greater than calibrated threshold for emissions-related reporting).\n            \n              The response format is the same as that for subfunction $0A reportSupportedDTCs above.",
    "LLR.PLAT.PDG.$19.003": "If there is a ReadDTCInformation (0x19) request with\n              subFunction parameter of a value other\n              than those specified as supported in this document,\n              then the platform  shall  report an error\n              (subFunctionNotSupported error 0x12).\n            Table\u00a03.30.\u00a0Read dtc info - negative responseByte #Byte descriptionValues1Negative response0x7F2Service ID0x193Error code0x12Note: \n              Source: ISO 14229-1 sections 9.2.4 and 11.3.2.1",
    "LLR.PLAT.PDG.$19.017": "For any $19 subfunction required to emit a DTCStatusAvailabilityMask value, the platform\n               shall  respond with a DTCStatusAvailabilityMask consisting of the following bits set to 1:\n              \n                bit 0 (testFailed)\n                \n                bit 1 (testFailedThisOperationCycle)\n                \n                bit 2 (pendingDTC)\n                \n                bit 3 (activeDTC)\n                \n            Rationale: \n              There are more status bits available, but only the bottom four bits are currently supported.\n            Note: \n              Source: ISO 14229-1 section D.2",
    "LLR.PLAT.PDG.$19.018": "For any $19 subfunction required to emit a statusOfDTC value, the platform  shall  populate that value as follows:\n              \n                bit 0 (testFailed) - Set to 1 if the DTC being reported has failed the most recently run test, 0 otherwise.\n                \n                bit 1 (testFailedThisOperationCycle) - Set to 1 if the DTC being reported has failed a test at any time during the current drive cycle, 0 otherwise.\n                \n                bit 2 (pendingDTC) - Set to 1 if the DTC being reported is in state Pending, 0 otherwise.\n                \n                bit 3 (activeDTC) - Set to 1 if the DTC being reported is in state Active, 0 otherwise.\n                \n            Rationale: \n              There are more status bits available, but only the bottom four bits are currently supported (see [LLR.PLAT.PDG.$19.017]).\n            Note: \n              Source: ISO 14229-1 section D.2",
    "LLR.PLAT.PDG.$19.019": "If there is a ReadDTCInformation (0x19) request with\n              an incorrect message length, then the platform  shall  report an error\n              (incorrectMessageLengthOrInvalidFormat error 0x13).\n            Table\u00a03.31.\u00a0Read dtc info - negative responseByte #Byte descriptionValues1Negative response0x7F2Service ID0x193Error code0x13Note: \n              Source: ISO 14229-1 sections 9.2.4 and 11.3.2.1",
    "LLR.PLAT.PDG.$22.001": "The platform  shall  provide the parameter data related to the specified PID\n              if it has a 16-bit identifier defined in response to a KW2000-3\n              ReadDataByCommonIdentifier (0x22) or\n              UDS ReadDataByIdentifier (0x22) request by the test tool.\n            Table\u00a03.33.\u00a0Read data by common identifier - positive responseByte #Byte descriptionValues1Positive response0x622ID high byteAs in request3ID low byteAs in request4...nPID data bytes\n                      An array of bytes. The number of bytes is as\n                      defined by the application for the PID requested",
    "LLR.PLAT.PDG.$22.002": "The data  will  be overridden data if the test tool has overridden the data\n              previously and the resend-input-as-output attribute is\n              set; otherwise, it  will  be the actual parameter data as specified by the\n              application.",
    "LLR.PLAT.PDG.$22.003": "The platform  shall  support multiple PIDs per 0x22 requests by UDS.",
    "LLR.PLAT.PDG.$22.004": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x31\n              when the requested PID is not found.\n            Table\u00a03.34.\u00a0Read data by common identifier - negative response 0x31Byte #Byte descriptionValues1Negative response0x7F2Service ID0x223Error code0x31",
    "LLR.PLAT.PDG.$22.005": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x14\n              when Tx buffer is too small for the PID array\n            Table\u00a03.35.\u00a0Read data by common identifier - negative response 0x14Byte #Byte descriptionValues1Negative response0x7F2Service ID0x223Error code0x14",
    "LLR.PLAT.PDG.$22.006": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x13\n              when request has greater than 3 bytes.\n            Table\u00a03.36.\u00a0Read data by common identifier - negative response 0x13Byte #Byte descriptionValues1Negative response0x7F2Service ID0x223Error code0x13",
    "LLR.PLAT.PDG.$24.001": "The platform  shall  receive and process valid UDS ReadScalingDataByIdentifier (0x24)\n              requests from the test tool, with formats as defined by ISO 14229-1.\n            Note: \n              Source: ISO 14229-1 section 10.4",
    "LLR.PLAT.PDG.$24.002": "In response to a valid UDS service $24 request from the test tool,\n              the platform  shall  transmit a positive response, with format as defined by ISO 14229-1.\n            Note: \n              Source: ISO 14229-1 section 10.4",
    "LLR.PLAT.PDG.$24.003": "If the service $24 request specifies a PID which is not defined by the application\n              or does not support UDS, the platform  shall  transmit a negative response with error\n              code of requestOutOfRange (0x31).",
    "LLR.PLAT.PDG.$24.004": "If the service $24 request contains incorrect number of bytes,\n              the platform  shall  transmit a negative response with error code of incorrectMessageLength (0x13).",
    "LLR.PLAT.PDG.$28UDS.012": "At initialisation (prior to the reception of any communications\n              control diagnostic service) the platform  shall  indicate\n              transmission and reception of all message types on each subnet is\n              allowed.",
    "LLR.PLAT.PDG.$28UDS.013": "In response to a valid UDS service $28 request, the platform  shall \n              transmit a positive response, with the format as defined by\n              IS0 14229-1:2006 and the platform shall update the communications\n              status storage (control type per communication type per\n              subnet) for access by the application.",
    "LLR.PLAT.PDG.$28UDS.001": "A service 0x28 request  shall  only be processed\n              in an extended diagnostic session or a programming session.\n              Otherwise the ECU shall respond with a negative response code\n              indicating \u201cno support in active session\u201d.",
    "LLR.PLAT.PDG.$28UDS.002": "During an UDS extended diagnostic session if a\n              0x28 request is received of length other than\n              1, 2 or 3 bytes, the ECU  shall  respond with a negative response code\n              indicating \u201cincorrectMessageLengthOrInvalidFormat\u201d.\n            Rationale: \n              Note: Allowing message sizes of 1 and 2 bytes to support J2190 see\n              [LLR.PLAT.PDG.$28J2190.002].",
    "LLR.PLAT.PDG.$28UDS.003": "During an UDS extended diagnostic session if a\n              0x28 request is received with the subfuncion\n              parameter (control type) in the range 0x4 to\n              0x7F inclusivethe ECU  shall  respond with a\n              negative response code indicating\n              \u201csubFunctionNotSupported\u201d.\n            Rationale: \n              Note: As per table 53 of IS0 14229-1:2006(E) these ranges are\n              reserved or specific to the manufacturer and supplier.",
    "LLR.PLAT.PDG.$28UDS.004": "During an UDS extended diagnostic session if a\n              0x28 request is received with a communication\n              type requesting a network in the range 0x3 to\n              0xE inclusive, the ECU  shall  respond with a\n              negative response code indicating\n              \u201crequestOutOfRange\u201d.\n            Rationale: \n              Note: OpenECU at present has a maximum of 3 CAN buses. Subnets\n              identifiers 0 and 0xF have specific functions. Subnets identifiers\n              1, 2 and 3 can be used to individually identify each CAN bus.",
    "LLR.PLAT.PDG.$28UDS.005": "During an UDS extended diagnostic session if a\n              0x28 request is received with a communication\n              type equal to 0 (ISOSAEReserved), the ECU  shall  respond with a\n              negative response code indicating\n              \u201crequestOutOfRange\u201d.",
    "LLR.PLAT.PDG.$28UDS.006": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.106": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.206": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.032": "When the application invokes the interface for communication\n                control status the platform  shall  read the data store for the\n                given subnet and return the control status of the requested\n                communication type.",
    "LLR.PLAT.PDG.$28UDS.010": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.110": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.210": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$28UDS.011": "The interface  shall  update a data store to inidcate when the\n                negative response code conditionsNotCorrect (NRC $22) should be\n                sent in response to a service $28 request with a matching\n                communication type and subnet number.",
    "LLR.PLAT.PDG.$28J2190.005": "In response to a valid J2190 service $28 request, the platform\n               shall  transmit a positive response, with a format as defined by\n              J2190 (issued JUN93) and update the stored status of\n              communications.",
    "LLR.PLAT.PDG.$28J2190.001": "J2190 service 0x28 request  shall  only be processed\n              in either the extended diagnostic session or programming session.\n              Requesting service 0x28 in any other\n              diagnostic session  shall  result in the ECU responding with a\n              negative response code indicating \u201cno support in active\n              session\u201d.",
    "LLR.PLAT.PDG.$28J2190.002": "For a J2190 service 0x28 request of length other\n              than 1 or 2 bytes, the ECU  shall  respond with a negative response code\n              indicating \u201cincorrectMessageLengthOrInvalidFormat\u201d.",
    "LLR.PLAT.PDG.$28J2190.003": "For a J2190 service 0x28 request with the\n              subfuncion parameter not equal to either 0x01\n              or 0x02, the ECU  shall  respond with a negative\n              response code indicating \u201csubFunctionNotSupported\u201d.",
    "LLR.PLAT.PDG.$28J2190.004": "If a J2190 service 0x28 request is received with\n              the subfuncion parameter equal to 0x02, the ECU\n               shall  not respond.",
    "LLR.PLAT.PDG.$29J2190.005": "In response to a valid J2190 service $29 request, the platform\n               shall  transmit a positive response, with a format as defined by\n              J2190 (issued JUN93) and update the stored status of\n              communications.",
    "LLR.PLAT.PDG.$29J2190.001": "J2190 service 0x29 request  shall  only be processed\n              in either extended diagnostic session or programming session.\n              Requesting service 0x29 in a any other\n              diagnostic session  shall  result in the ECU responding with a\n              negative response code indicating \u201cno support in active\n              session\u201d.",
    "LLR.PLAT.PDG.$29J2190.002": "For a J2190 service 0x29 request of length other\n              than 2 bytes, the ECU  shall  respond with a negative response code\n              indicating \u201cincorrectMessageLengthOrInvalidFormat\u201d.",
    "LLR.PLAT.PDG.$29J2190.003": "For a J2190 service 0x29 request with the\n              subfuncion parameter not equal to either 0x01\n              or 0x02, the ECU  shall  respond with a negative\n              response code indicating \u201csubFunctionNotSupported\u201d.",
    "LLR.PLAT.PDG.$29J2190.004": "If a J2190 service 0x29 request is received with\n              the subfuncion parameter equal to 0x02, the ECU\n               shall  not respond.",
    "LLR.PLAT.PDG.$23.001": "The platform  shall  provide a positive response to a ReadMemoryByAddress ($23)\n              request formatted according to either KW2000-3 or UDS, unless one of the\n              error conditions below applies.\n            Table\u00a03.39.\u00a0Read memory by address - positive responseByte #Byte descriptionValues1Positive response0x632Byte value at requested address0xNN3Byte value at requested address + 1 ...0xMM4...n...etc",
    "LLR.PLAT.PDG.$23.002": "The platform  shall  emit a negative response if the request message\n              size is invalid (in the UDS case, taking account of the format byte).\n            Rationale: \n              Note: the choice of error codes is not specified here to avoid the\n              issue of which one should be emitted if more than one error condition\n              applies. It is sufficient that a properly formatted negative response\n              is returned to the test tool if the request cannot or should not be honoured.",
    "LLR.PLAT.PDG.$23.003": "The platform  shall  emit a negative response if the requested memory\n              is not entirely within a readable microcontroller memory area. (The\n              PEF external flash area is supported, on targets which implement it,\n              using the same virtual address range as for CCP access of that area.)\n            Rationale: \n              Implementing control of which memory areas are accessible\n              would be complicated by the many regions available on different targets.\n              Instead we take the approach of allowing the read of any accessible memory,\n              but restricting access according to session type and security status.",
    "LLR.PLAT.PDG.$23.004": "The platform  shall  emit a negative response if the current session\n              is the default type, and the C-API configuration is\n              set to disallow access in that session type.",
    "LLR.PLAT.PDG.$23.005": "The platform  shall  emit a negative response if the current session\n              is the extended type, and the C-API configuration is\n              set to disallow access in that session type.",
    "LLR.PLAT.PDG.$23.006": "The platform  shall  emit a negative response if the current session\n              is the programming type, and the C-API configuration is\n              set to disallow access in that session type.",
    "LLR.PLAT.PDG.$23.007": "The platform  shall  emit a negative response if a suitable SecurityAccess ($27)\n              seed\/key exchange has not been successfully passed (i.e. the ECU remains \"locked\")\n              and the C-API configuration is\n              set to disallow access without such security having been passed",
    "LLR.PLAT.PDG.$23.008": "The platform  shall  apply the same rules concerning session type and\n              security access in the boot loader as in the main application, even\n              if the application has been erased and the power cycled.\n            Rationale: \n              Similar continuity of security access is required for HIS flash\n              reprogramming. Doing the same for memory read access prevents\n              unauthorised users from accessing memory by entering a programming\n              session, perhaps with a partially erased application area of flash\n              to prevent further application execution.",
    "LLR.PLAT.PDG.$23.009": "The platform  shall  emit a negative response if the size of memory\n              requested means that the expected response message would not fit\n              in the ISO 15765-2 transmit buffer in the ECU.",
    "LLR.PLAT.PDG.$2A.001": "The platform  shall  provide a positive response to a ReadDataByPeriodicIdentifier ($2A)\n              request formatted according to UDS, unless one of the error conditions below applies.\n            Table\u00a03.41.\u00a0Read data by periodic identifier  - positive responseByte #Byte descriptionValues1Positive response0x6A",
    "LLR.PLAT.PDG.$2A.002": "After the initial positive response, the platform  shall  start or stop\n              sending a single periodic response message for each periodicDataIdentifier.\n              Periodic messages shall be formatted according to UDS type #1.\n            Table\u00a03.42.\u00a0Read data by periodic identifier - periodic responseByte #Byte descriptionValues1Positive response0x6A2Periodic Data Identifier[0 to 0xFF]3Data Record Data #1[0 to 0xFF]...Data Record Data #n [0 to 0xFF]",
    "LLR.PLAT.PDG.$2A.007": "If the ECU is in default diagnostic session when the request is received,\n              the platform  shall  return a serviceNotSupportedInActiveSession (0x7f) error response.",
    "LLR.PLAT.PDG.$2A.003": "The platform  shall  emit a negative response if the request message\n              size is invalid.\n            Rationale: \n              Note: the choice of error codes is not specified here to avoid the\n              issue of which one should be emitted if more than one error condition\n              applies. It is sufficient that a properly formatted negative response\n              is returned to the test tool if the request cannot or should not be honoured.",
    "LLR.PLAT.PDG.$2A.004": "The platform  shall  emit with a negative response if the requested\n              periodic data identifier is not defined in memory.",
    "LLR.PLAT.PDG.$2A.005": "The platform  shall  emit a negative response if the request will\n              exceed the memory available for the scheduling of periodic data\n              identifiers.",
    "LLR.PLAT.PDG.$2A.006": "The platform  shall  emit a negative response if the size of the\n              identifier data requested means that the expected response message\n              would not fit in the ISO 15765-2 transmit buffer in the ECU.",
    "LLR.PLAT.PDG.$2C.001": "The platform  shall  provide a positive response to a DynamicallyDefineDataIdentifier ($2C)\n              request formatted according to UDS, unless one of the error conditions below applies.\n            Table\u00a03.46.\u00a0Dynamically define data identifier - positive responseByte #Byte descriptionValues1Positive Response0x6C2Definition Type[0 to 0x7F]3Dynamically Defined Data Identifier (MSB)[0xF2, 0xF3]4Dynamically Defined Data Identifier (LSB)[0 to 0xFF]",
    "LLR.PLAT.PDG.$2C.002": "The platform  shall  emit a negative response if the request message\n              size is invalid.\n            Rationale: \n              Note: the choice of error codes is not specified here to avoid the\n              issue of which one should be emitted if more than one error condition\n              applies. It is sufficient that a properly formatted negative response\n              is returned to the test tool if the request cannot or should not be honoured.",
    "LLR.PLAT.PDG.$2C.003": "The platform  shall  emit a negative response when the source\n              data identifier is not defined in memory.",
    "LLR.PLAT.PDG.$2C.004": "The platform  shall  emit a negative response if the request sub-function\n              is defineByMemory and the the current session is the\n              default type, and the C-API configuration is\n              set to disallow access in that session type.",
    "LLR.PLAT.PDG.$2C.005": "The platform  shall  emit a negative response if the request sub-function\n              is defineByMemory and the current session is the extended\n              type, and the C-API configuration is set to disallow access in that session type.",
    "LLR.PLAT.PDG.$2C.006": "The platform  shall  emit a negative response if the request sub-function\n              is defineByMemory and the current session is the programming\n              type, and the C-API configuration is set to disallow access in that session type.",
    "LLR.PLAT.PDG.$2C.007": "The platform  shall  emit a negative response if the request sub-function is\n              defineByMemory and a suitable SecurityAccess ($27) seed\/key exchange has\n              not been successfully passed (i.e. the ECU remains \"locked\") and the\n              C-API configuration is set to disallow access without such security having\n              been passed.",
    "LLR.PLAT.PDG.$2C.008": "The platform  shall  emit a negative response if the size of memory\n              requested or the size of identifier data requested means that the\n              expected response message would not fit in the ISO 15765-2 transmit\n              buffer in the ECU.",
    "LLR.PLAT.PDG.$2C.009": "The platform  shall  emit a negative response if the request will\n              exceed the memory available for the storage of dynamically defined\n              identifiers.",
    "LLR.PLAT.PDG.$2C.010": "The platform  shall  append to existing data if the request sub-function\n              is defineByMemory or defineByIdentifier and the identifier in the request\n              is already defined in dynamically defined identifier memory.",
    "LLR.PLAT.PDG.$2E.001": "The platform  shall  receive and process valid KW2000-3 WriteDataByCommonID (0x2E) requests to write Non-Volatile PID values\n              from the test tool, with format as defined by KW2000-3 spec.",
    "LLR.PLAT.PDG.$2E.002": "The platform  shall  receive and process valid UDS WriteDataByID (0x2E) requests to write Non-Volatile PID values\n              from the test tool, with format as defined by ISO14229 spec.",
    "LLR.PLAT.PDG.$2E.003": "The platform  shall  receive and process valid KW2000-3 WriteDataByLocalIdentifier (0x3B) requests to write Non-Volatile PID values\n              from the test tool, with format as defined by KW2000-3 spec.",
    "LLR.PLAT.PDG.$2E.004": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x22\n              when any of the following occur:\n              \n                  If the ECU is in Default diagnostic session.\n                  HIS spec disallows in default session and application mode, but Torchwood needs it to be supported in application mode for ECU variant coding etc.\n                  If the service request is made using functional addressing.\n                  No point using functional addressing to write ECU data",
    "LLR.PLAT.PDG.$2E.005": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x13\n              when the length of request is too short (less than 4 for $2E and less than 3 for $3B).",
    "LLR.PLAT.PDG.$2E.006": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x72\n              when the length of data bytes to be written in the request is greater than 255 bytes or\n              there has been a problem while writing the value into the PID.",
    "LLR.PLAT.PDG.$2E.007": "On successfully writing into the requested NonVolatile PID, the platform  shall  transmit a\n              positive response of 0x6E for $2E and\n              0x7B for $3B request along with the PID written.",
    "LLR.PLAT.PDG.$2F.001": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x00 - returnToECU\n            Table\u00a03.48.\u00a0io_control_by_id - positive response kw2k (0x00 returnToECU)Byte #Byte descriptionValues1Positive response0x6F2PID identifier high byte[0x00 to 0xFF]3PID identifier low byte[0x00 to 0xFF]4Parameter0x00",
    "LLR.PLAT.PDG.$2F.002": "The platform  shall  support UDS IOControlParmeter\n              0x00 - returnToECU\n            Table\u00a03.49.\u00a0io_control_by_id - positive response UDS (0x00 returnToECU)Byte #Byte descriptionValues1Positive response0x6F2PID identifier high byte[0x00 to 0xFF]3PID identifier low byte[0x00 to 0xFF]4Parameter0x00",
    "LLR.PLAT.PDG.$2F.003": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x01 - reportCurrent",
    "LLR.PLAT.PDG.$2F.004": "The platform  shall  support UDS IOControlParmeter\n              0x02 - freezeCurrentState",
    "LLR.PLAT.PDG.$2F.005": "The platform  shall  support UDS IOControlParmeter\n              0x03 - shortTermAdjust",
    "LLR.PLAT.PDG.$2F.006": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x05 - freezeCurrentState\n            Table\u00a03.50.\u00a0io_control_by_id - positive response kw2k (0x05 freezeCurrentState)Byte #Byte descriptionValues1Positive response0x6F2PID identifier high byte[0x00 to 0xFF]3PID identifier low byte[0x00 to 0xFF]4Parameter0x055...n\n                      PID data with values set to those when the request was sent.",
    "LLR.PLAT.PDG.$2F.007": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x07 - shortTermAdjust\n            Table\u00a03.51.\u00a0io_control_by_id - positive response kw2k (0x07 shortTermAdjust)Byte #Byte descriptionValues1Positive response0x6F2PID identifier high byte[0x00 to 0xFF]3PID identifier low byte[0x00 to 0xFF]4Parameter0x075...n\n                      PID data with values set to those sent in data bytes 5\n                      onwards in the request\n                    \u00a0n+1...m\n                      (Optional) controlEnableMask bytes, accepted only if the\n                      PID is configured to accept them.",
    "LLR.PLAT.PDG.$2F.008": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x31\n              when any of the following occur:\n              \n                  If the action requested in parameter (byte 4 in request) fails\n                \n                  When the action requested in parameter (byte 4 in request) is\n                  not supported (i.e. other than values listed in the requirements\n                  PLAT.PDG.$2F.001-7)\n                \n                  When the number of bytes of the override data supplied mismatches\n                  the defined length of the PID data.\n                  (applicable only for shortTermAdjustment)\n            Table\u00a03.52.\u00a0IO control by (common) identifier - negative response 0x31Byte #Byte descriptionValues1Negative response0x7F2Service ID0x2F3Error code0x31",
    "LLR.PLAT.PDG.$2F.009": "If the ECU is in default diagnostic session when the request is received,\n              the platform  shall  return a RequestOutOfRange (0x31) error response.\n            <llr:rationale>\n              \n                The NRC value of requestOutOfRange (0x31) is used here and not the generic\n                serviceNotSupportedInActiveSession (0x7f) since there is an explicit check for\n                active session in the Flowchart that documents the evaluation sequence for this service in\n                the ISO14229-1 specification.\n              \n            <\/llr:rationale>",
    "LLR.PLAT.PDG.$30.001": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x00 - returnToECU",
    "LLR.PLAT.PDG.$30.002": "The platform  shall  support UDS IOControlParmeter\n              0x00 - returnToECU\n            Table\u00a03.54.\u00a0io_control_by_local_id - positive response UDS and kw2k(0x00 returnToECU)Byte #Byte descriptionValues1Positive response0x702PID identifier[0x00 to 0xFF]3Parameter0x00",
    "LLR.PLAT.PDG.$30.003": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x01 - reportCurrent\n            Table\u00a03.55.\u00a0io_control_by_local_id - positive response kw2k (0x01 reportCurrentState)Byte #Byte descriptionValues1Positive response0x702PID identifier[0x00 to 0xFF]3Parameter0x014...n\n                      PID data with current value of PID when the request was sent.",
    "LLR.PLAT.PDG.$30.004": "The platform  shall  support UDS IOControlParmeter\n              0x02 - freezeCurrentState",
    "LLR.PLAT.PDG.$30.005": "The platform  shall  support UDS IOControlParmeter\n              0x03 - shortTermAdjust",
    "LLR.PLAT.PDG.$30.006": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x05 - freezeCurrentState\n            Table\u00a03.56.\u00a0io_control_by_local_id - positive response kw2k (0x05 freezeCurrentState)Byte #Byte descriptionValues1Positive response0x702PID identifier[0x00 to 0xFF]3Parameter0x054...n\n                      PID data with values set to those when the request was sent.",
    "LLR.PLAT.PDG.$30.007": "The platform  shall  support KW2000-3 IOControlParmeter\n              0x07 - shortTermAdjust\n            Table\u00a03.57.\u00a0io_control_by_local_id - positive response kw2k (0x07 shortTermAdjust)Byte #Byte descriptionValues1Positive response0x702PID identifier[0x00 to 0xFF]3Parameter0x074...n\n                      PID data with values set to those sent in data bytes 4\n                      onwards in the request",
    "LLR.PLAT.PDG.$30.008": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x31\n              when any of the following occur:\n              \n                  If the action requested in parameter (byte 3 in request) fails\n                \n                  When the action requested in parameter (byte 3 in request) is\n                  not supported (i.e. other than values listed in the requirements\n                  PLAT.PDG.$30.001-7)\n                \n                  When the number of bytes of the override data supplied mismatches\n                  the defined length of the PID data.\n                  (applicable only for shortTermAdjustment)\n            Table\u00a03.58.\u00a0IO control by (local) identifier - negative response 0x31Byte #Byte descriptionValues1Negative response0x7F2Service ID0x303Error code0x31",
    "LLR.PLAT.PDG.$31.001": "The platform  shall  support sub-function\n              0x01 - startRoutine for \"Method A\" (untimed) routines.",
    "LLR.PLAT.PDG.$31.002": "The platform  shall  support sub-function\n              0x01 - startRoutine for \"Method B\" (timed) routines.",
    "LLR.PLAT.PDG.$31.003": "The platform  shall  support sub-function\n              0x02 - stopRoutine for \"Method A\" (untimed) routines.",
    "LLR.PLAT.PDG.$31.004": "The platform  shall  support sub-function\n              0x02 - stopRoutine for \"Method B\" (timed) routines.",
    "LLR.PLAT.PDG.$31.005": "The platform  shall  support sub-function\n              0x03 - requestRoutineResults",
    "LLR.PLAT.PDG.$31.006": "The platform  will  provide the negative response\n              according to ISO 14229.\n            Table\u00a03.60.\u00a0routine_control - negative response Byte #Byte descriptionValues1Negative response0x7F2Service ID0x313Error Code[0x00 to 0xFF]",
    "LLR.PLAT.PDG.$31.007": "The platform  shall  respond with  negative response of 0x7F\n              and an error code of 0x12 if:\n              \n                  the received subfunction request is not one of the following:\n                  0x01 - startRoutine, 0x02 - stopRoutine,\n                  or 0x03 - requestRoutineResults; OR\n                \n                  The routineRequest subfunction is requestRoutineResults and the\n                  requested routine is configured to not have results.",
    "LLR.PLAT.PDG.$31.008": "The platform  shall  respond with  negative response of 0x7F\n              and an error code of 0x13 if the received message length is incorrect\n              for the requested routine ID.",
    "LLR.PLAT.PDG.$31.039": "The platform  shall  respond with  negative response of 0x7F\n              and an error code of 0x22 if the routine is requested when\n              application specifies that the routine is not ready to run.",
    "LLR.PLAT.PDG.$31.010": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x24\n              when any of the following occur:\n              \n                  The routineRequest subfunction is requestRoutineResults and\n                  the application specifies that results are not valid.\n                \n                  The routineRequest subfunction is startRoutine and the requested\n                  routineID is currently running.\n                \n                  The routineRequest subfunction is stopRoutine and the requested\n                  routineID is not currently running.",
    "LLR.PLAT.PDG.$31.011": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x31\n              when any of the following occur:\n              \n                  The application does not support the requested routine identifier.\n                \n                  The application optional routineControlOptionRecord contains invalid data for the\n                  requested routineIdentifier.",
    "LLR.PLAT.PDG.$31.014": "In response to a valid request, the platform  will  provide the positive response\n              according to ISO 14229.\n            Table\u00a03.61.\u00a0routine_control - positive response Byte #Byte descriptionValues1Positive response0x712routineRequest (sub function)[0x01 to 0x03]3routineIdentifier high byte[0x00 to 0xFF]4routineIdentifier low byte[0x00 to 0xFF]5 - nroutineStatusRecord[0x00 to 0xFF]",
    "LLR.PLAT.PDG.$31.015": "In response to routineRequest 0x01 - startRoutine,\n              the platform  shall  provide a positive response after the application\n              indicates that the routine has started.  The response shall include the\n              routineStatusRecord provided by the application.",
    "LLR.PLAT.PDG.$31.017": "In response to routineRequest 0x02 - stopRoutine, the platform\n               shall  provide a positive response after the application indicates that the routine\n              has stopped.  The response shall include the routineStatusRecord provided by\n              the application.",
    "LLR.PLAT.PDG.$31.018": "In response to routineRequest 0x03 - requestResults, the platform\n               shall  fill the routineStatusRecord bytes with the routine results provided by the application.",
    "LLR.PLAT.PDG.$31.019": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.020": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.021": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.022": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.023": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.024": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.$31.025": "If pdgf_routine_data has a NULL pointer,\n                OR pdgf_routine_rqst has a NULL pointer,\n                then pdg_get_routine_rqst()  shall  reject the call by returning\n                PDG_ROUTINE_RC_BAD_ARGS.",
    "LLR.PLAT.PDG.$31.026": "If pdgf_routine_ctrl_option_record has a NULL pointer,\n                AND the routineControlOptionRecord byte length for the requested routine is not 0,\n                then pdg_get_routine_rqst()  shall  reject the call by returning\n                PDG_ROUTINE_RC_BAD_CONFIG_DATA.",
    "LLR.PLAT.PDG.$31.027": "If pdgf_routine_data has a NULL pointer,\n                then pdg_update_routine_ctrl_data()  shall  reject the call by returning\n                PDG_ROUTINE_RC_BAD_ARGS.",
    "LLR.PLAT.PDG.$31.028": "If pdgf_routine_status_record has a NULL pointer,\n                AND the routineStatusRecord byte length for the requested routine is not 0,\n                then pdg_update_routine_ctrl_data()  shall  reject the call by returning\n                PDG_ROUTINE_RC_BAD_CONFIG_DATA.",
    "LLR.PLAT.PDG.$31.029": "If pdgf_routine_results has a NULL pointer,\n                AND the routineResults byte length for the requested routine is not 0,\n                then pdg_update_routine_ctrl_data()  shall  reject the call by returning\n                PDG_ROUTINE_RC_BAD_CONFIG_DATA.",
    "LLR.PLAT.PDG.$31.030": "The platform shall provide a Simulink interface block named\n                pdg_RoutineControl that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionroutine_readyInportBoolean\n        \n          Flag from the application to inform the platform that the routine is able\n          to run.  If this inport is FALSE, the platform will send a negative response\n          to the diagnostic tool if this routine is requested, and the\n          routine_request outport will output noRequest.\n        \n      routine_runningInportBoolean\n        \n          Flag from the application to inform the platform that the routine is running.\n        \n      results_validInportBoolean\n        \n          Flag from application to inform the platform that the data supplied at\n          results inport is valid (i.e. the routine has been run at\n          least one time, and the results are considered valid by the application.)\n          If results are not used for this routine,set Results Length\n          to 0 in the dialog, and ground this inport.\n        \n      resultsInportArray\n        \n          This is the array of bytes that will be transmitted to the diagnostic scan\n          tool when service 0x31 is requested with subfunction 0x03 (requestRoutineResults)\n          AND results_valid is TRUE.  If results will not be used,\n          set Results Length to 0 in the dialog, and ground this\n          inport.\n        \n      status_recordInportArray\n        \n          This is an optional array of bytes that will be transmitted to the diagnostic scan\n          tool in response to any service 0x31 request.  If a status record is not used, set\n          Status Record Length in the dialog to 0 and ground this inport.\n        \n      sim_routine_requestInportU8\n        \n          This inport is only used in simulation and only appears if\n          Provide Simulation Input is ticked in the dialog.  During simulation,\n          any value supplied to this inport is immediately copied to the\n          routine_request outport.\n        \n      sim_rcorInportArray\n        \n          This inport is only used in simulation and only appears if\n          Provide Simulation Input is ticked in the dialog.  During simulation,\n          any array supplied to this inport is immediately copied to the\n          rcor outport.\n        \n      routine_requestOutportU8\n        \n          Indicates the routine request sub-function that was received from the diagnostic\n          scan tool.  Note: the received routine request sub-function will only be output\n          for one sample.\n        \n\n        Table\u00a03.62.\u00a0RoutineControl request sub-function\n                  Sub-function Name\n                \n                  Value\n                \n                  Description\n                noRequest0x00\n                  Indicates that no request has been received from the diagnostic tool.\n                startRoutine0x01\n                  Indicates that the application must start the routine.\n                stopRoutine0x02\n                  Indicates that the application must stop the routine.\n                \n        \n          Note: requestRoutineResults (0x03) is handled automatically by the\n          platform.  Thus, the routine_request outport will never be 0x03.\n        \n      rcorOutportArray\n        \n          Provides the optional routineControlOptionRecord byte array to the application.  This\n          outport only appears if the dialog entry RCOR Length is non-zero.\n        \n      Routine IDParamU16\n        \n          A unique routine ID that will be used by the diagnostic tool to identify\n          this routine.  Note: routine IDs 0x0202, 0x0203, 0xFF00, and\n            0xFF01 are reserved by the platform and cannot be used by the application.\n        \n      \n                Calibratable: no.\n              RCOR LengthParamU16\n        \n          Defines the number of bytes in the optional routineControlOptionRecord byte array.\n          Set to 0 if the routine does not use a routineControlOptionRecord.\n        \n      \n                Calibratable: no.\n              Timed RoutineParamBoolean\n        \n          If ticked, this routine is a \"Method B\" (timed) routine, and will therefore\n          stop on its own (without a stopRoutine request).  If unticked, this routine\n          is a \"Method A\" (untimed) routine, which requires a stopRoutine request to\n          stop the routine.  See ISO 14229-1 section 13 for further details regarding\n          Method A vs. Method B routines.\n        \n        \n          Even if ticked, the routine must handle a stopRoutine request to\n          allow the diagnostic tool to stop the routine if necessary.\n        \n      \n                Calibratable: no.\n              Results LengthParamU16\n        \n          Defines the number of bytes in the results array.  Set to 0 if the routine\n          does not use results.\n        \n      \n                Calibratable: no.\n              Status Record LengthParamU16\n        \n          Defines the number of bytes in the optional statusRecord array.  Set to 0 if\n          the routine does not use a statusRecord.\n        \n      \n                Calibratable: no.\n              Provide Simulation InputParamBoolean\n        \n          If ticked, two additional inports will be revealed.  See\n          sim_routine_request inport and sim_RCOR\n          for further details.\n        \n      \n                Calibratable: no.\n              Sample TimeParamdouble\n        \n          Defines the sample time that this block will use to check for incoming routine\n          requests, and update outports.  Must be a multiple of 0.001.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDG.$31.031": "The block pdg_RoutineControl shall support the targets:\n            All targets.",
    "LLR.PLAT.PDG.$31.032": "The block pdg_RoutineControl shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PDG.$31.035": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the Sample Time parameter in the block's dialog.",
    "LLR.PLAT.PDG.$31.036": "If the block mask checkbox Provide Simulation Input\n                is ticked, AND the routine_ready\n                inport is TRUE, then the block  shall  copy the\n                sim_routine_request inport to the\n                routine_request outport and the\n                sim_RCOR inport to the\n                RCOR outport.",
    "LLR.PLAT.PDG.$31.037": "When a valid routine request is received for the routine identifier specified in\n                Routine ID in the block mask,\n                then the platform  shall  write the routine request subtype to the\n                routine_request outport for one sample.",
    "LLR.PLAT.PDG.$31.038": "When a valid routine request is received for the routine identifier specified in\n                Routine ID in the block mask,\n                then the platform  shall  write the routineControlOptionRecord to the\n                RCOR outport.  Notes: 1) the RCOR\n                port  will  remain as the most recently received routineControlOptionRecord;\n                2) The RCOR port will only be written to if the\n                RCOR Length\n                block mask parameter is non-zero.",
    "LLR.PLAT.PDG.$3E.001": "The platform  shall  transmit a positive response message with data\n              0x00 in response to a request by the test tool with\n              parameter suppressPosRspMsgIndicationBit set to FALSE\n              (parameter value 0x00) to support UDS.\n            Table\u00a03.64.\u00a0Tester present - positive response 0x00Byte #Byte descriptionValues1Positive response0x7E2Diagnostic data (optional)0x00",
    "LLR.PLAT.PDG.$3E.006": "The platform  shall  transmit a positive response message with data\n              0x00 in response to a request by the test tool with\n              the parameter value set to 0x01 to support KW2000-3.\n            Table\u00a03.65.\u00a0Tester present - positive response 0x00Byte #Byte descriptionValues1Positive response0x7E2Diagnostic data (optional)0x00",
    "LLR.PLAT.PDG.$3E.003": "In response to a KW2000-3 TesterPresent (0x3E) request by\n              the test tool with no parameter byte, the platform  shall  transmit a positive\n              response message.\n            Note\n                This is considered a \u201cpass\u201d from the test\n                tool.\n              Table\u00a03.66.\u00a0Tester present - positive responseByte #Byte descriptionValues1Positive response0x7E",
    "LLR.PLAT.PDG.$3E.004": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x12 (not supported)\n              when the request is physically addressed and Diagnostics data is other\n              than 0x00, 0x01,0x02,\n              or 0x80\n            Table\u00a03.67.\u00a0Tester present - negative response 0x12Byte #Byte descriptionValues1Negative response0x7F2Service ID0x3E3Error code0x12",
    "LLR.PLAT.PDG.$3E.005": "The platform  shall  respond with a negative response of\n              0x7F and an error code of 0x13\n              when the request is physically addressed and the length of the request\n              is greater than 2\n            Table\u00a03.68.\u00a0Tester present - negative response 0x13Byte #Byte descriptionValues1Negative response0x7F2Service ID0x3E3Error code0x13",
    "LLR.PLAT.PDG.$85.001": "If the platform receives an 0x85 (DTC Control Setting)\n              request but an extended diagnostic session is not in progress, it\n               shall  respond with a negative response of 'not supported in active session'.",
    "LLR.PLAT.PDG.$85.002": "If an 0x85 request is received with message length not equal to 2 bytes,\n              the platform  shall  respond with a negative \u201cincorrect message length\u201d response.",
    "LLR.PLAT.PDG.$85.003": "If an 0x85 request is received with a DTCSettingType value of\n              0x02 (off value),\n              the platform  shall  emit a positive response if required (see below) and then stop\n              the setting of diagnostic trouble codes.",
    "LLR.PLAT.PDG.$85.004": "If the off entry is to proceed according to the\n              above, and the suppressPosRspMsgIndicationBit was not set in the\n              requested session value (bit 7), then the platform  shall  emit a positive response,\n              otherwise not.",
    "LLR.PLAT.PDG.$85.005": "If an 0x85 request is received with a DTCSettingType value of\n              0x01 (on value),\n              the platform  shall  emit a positive response if required (see below) and then allow\n              the setting of diagnostic trouble codes.",
    "LLR.PLAT.PDG.$85.006": "If the on entry is to proceed according to the\n              above, and the suppressPosRspMsgIndicationBit was not set in the\n              requested session value (bit 7), then the platform  shall  emit a positive response,\n              otherwise not.",
    "LLR.PLAT.PDG.$85.007": "If an 0x85 request is received with any other setting value, the\n              platform  shall  respond with a negative response of \u201csubfunction not supported\u201d.",
    "LLR.PLAT.PDG.$85.008": "When the platform switches to the Default Diagnostics sesssion mode, it  shall  again allow\n              the setting of diagnostic trouble codes if previously disabled by service request 0x85.",
    "LLR.PLAT.PDG.GENCALBK.001": "If selected by the application, a callback function  shall  be called by the\n              platform every time a complete ISO15765-2 request message has been received,\n              but before any response has been emitted. Sufficient data shall be provided\n              in the function call for the application to exercise the options detailed\n              in the following requirements.",
    "LLR.PLAT.PDG.GENCALBK.002": "The platform  shall  emit no response for a request message where the\n              application returns a value requesting \"stay silent\" of\n              PDG_STAY_SILENT.",
    "LLR.PLAT.PDG.GENCALBK.003": "The platform  shall  emit its normal response for this request message\n              where the application returns a value requesting \"standard platform reply\"\n              of PDG_STANDARD_PLATFORM_REPLY, which could be a positive\n              or negative response.",
    "LLR.PLAT.PDG.GENCALBK.004": "The platform  shall  transmit the message prepared in the ISO15765-2\n              transmit buffer supplied to the application instead of its usual response\n              where the application returns a value requesting \"send whole application\n              message\" of PDG_SEND_WHOLE_APP_MSG.",
    "LLR.PLAT.PDG.GENCALBK.005": "The platform  shall  provide a callback interface, selectable by the\n              application.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.001": "If the application returns a value requesting\n              PDG_STANDARD_PLATFORM_REPLY, the platform  shall \n              emit its normal response for this  request message (which could be\n              a positive or negative response) as defined in this document.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.002": "If the application returns a value requesting PDG_STAY_SILENT,\n              the platform  shall  emit no response for this request message, regardless\n              of any other PIDs requested.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.003": "If the application returns a value requesting\n                PDG_SEND_WHOLE_APP_MSG, the platform  shall  transmit\n                the message prepared in the ISO15765-2 transmit buffer supplied to the\n                application instead of its usual response, regardless of any other PIDs\n                in the request message.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.004": "If the application returns a value requesting\n              PDG_SEND_WITH_APP_ID_DATA, the platform  shall  incorporate\n              the value bytes for the current PID (supplied by the callback routine)\n              into its response message and continue processing the response as normal.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.005": "If the application returns a value requesting\n              PDG_SEND_OMITTING_THIS_ID, the platform  shall  not include\n              this PID in its response message, but continue processing any other PIDs that\n              contribute to this message.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.006": "The platform  shall  respond with the appropriate error for \"no such PID\" for\n              services $21 or $22 where no PIDs would\n              be output in the response message because the application has requested their\n              omission.",
    "LLR.PLAT.PDG.J1939IDRQCALLBACK.007": "If no PIDs would be output in the response message because the application\n              has requested their omission, the platform  shall  emit no response \"no such PID\"\n              for service $01 (this is the normal behaviour for J1979 $01\n              if unknown PIDs are requested).",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.004": "If the message length is invalid a negative response\n                READ_DATA_BY_COMMON_ID\/SUBFUNCTION_NOT_SUPPORTED\n                is generated.",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.005": "If the application returns a value requesting\n              PDG_STANDARD_PLATFORM_REPLY, the platform  shall \n              emit its normal response for this  request message (which could be\n              a positive or negative response) as defined in this document.",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.006": "If the application returns a value requesting PDG_STAY_SILENT,\n              the platform  shall  emit no response for this request message, regardless\n              of any other PIDs requested.",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.007": "If the application returns a value requesting\n              PDG_SEND_WHOLE_APP_MSG, the platform  shall  transmit\n              the message prepared in the ISO15765-2 transmit buffer supplied to the\n              application instead of its usual response, regardless of any other PIDs\n              in the request message.",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.008": "If the application returns a value requesting\n              PDG_SEND_WITH_APP_ID_DATA, the platform  shall  incorporate\n              the value bytes for the current PID (supplied by the callback routine)\n              into its response message and continue processing the response as normal.",
    "LLR.PLAT.PDG.UDSIDRQCALLBACK.009": "If the application returns a value requesting\n              PDG_SEND_OMITTING_THIS_ID, the platform  shall  not include\n              this PID in its response message, but continue processing any other PIDs that\n              contribute to this message.",
    "LLR.PLAT.PDG.INFOTYPE.001": "The platform  shall  initialise InfoType $0B In-use Performance Tracking to be supported.",
    "LLR.PLAT.PDG.INFOTYPE.002": "The platform  shall  initialise all other InfoTypes to be not supported.",
    "LLR.PLAT.PDG.INFOTYPE.003": "When the application invokes the interface for an InfoType listed in the table below,\n              the platform  shall  list that InfoType as supported.",
    "LLR.PLAT.PDG.INFOTYPE.004": "When the application invokes the interface for an InfoType as listed in the table above,\n              the platform  shall  associate with that InfoType the data passed to it by the application.",
    "LLR.PLAT.PDG.INFOTYPE.005": "When the application invokes the interface for an InfoType that is not listed above,\n              the platform  shall  not alter the supported status of that InfoType and ignore any\n              data passed.",
    "LLR.PLAT.PDG.INFOTYPE.006": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.INFOTYPE.106": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.INFOTYPE.206": "<xi:include><\/xi:include>",
    "LLR.PLAT.PDG.INFOTYPE.016": "If pdgf_infotype_id is either an InfoType-supported InfoType\n                (i.e. 0x00, 0x20, 0x40, ... 0xE0) or a platform InfoType as identified by\n                LLR.PLAT.PDG.INFOTYPE.001, then the platform  shall  reject the call by returning\n                PDG_RC_PLATFORM_INFOTYPE.",
    "LLR.PLAT.PDG.INFOTYPE.007": "If pdgf_infotype_data has a NULL pointer,\n                then the platform  shall  reject the call by returning\n                PDG_RC_BAD_ARGS.",
    "LLR.PLAT.PDG.INFOTYPE.017": "If pdgf_infotype_id is not an InfoType that is defined\n                in J1979 SEP2010, then the platform  shall  reject the call by returning\n                PDG_RC_BAD_ARGS.",
    "LLR.PLAT.PDG.INFOTYPE.008": "If pdgf_infotype_id is defined in J1979 SEP2010 but is not supported\n                by the platform (i.e. it is neither one of the IDs listed in LLR.PLAT.PDG.INFOTYPE.003\n                as supported for application interface, nor a platform InfoType as identified in\n                LLR.PLAT.PDG.INFOTYPE.016), then the platform  shall  reject the call by returning\n                PDG_RC_BAD_INFOTYPE.",
    "LLR.PLAT.PDG.INFOTYPE.018": "If pdgf_infotype_length does not match the definition for that\n                InfoType in J1979 SEP2010, then the platform  shall  reject the call by returning\n                PDG_RC_BAD_ARGS.",
    "LLR.PLAT.PDG.INFOTYPE.010": "If the interface parameter checks pass then the function  shall  implement requirements\n                LLR.PLAT.PDG.INFOTYPE.003, LLR.PLAT.PDG.INFOTYPE.004, LLR.PLAT.PDG.INFOTYPE.005 above.",
    "LLR.PLAT.PDG.INFOTYPE.011": "The platform shall provide a Simulink interface block named\n                pdg_InfotypeInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninInportInteger\n        \n          Application supplied data which is to be accessed via service 0x09 by a diagnostic scan tool.\n        \n        \n          Note this inport accepts inputs from multidimensional data types,\n          such as a simulink Mux,\n          simulink constant block whose constant value is a vector (specified in the data dictionary), etc.\n        \n        \n          Note the length of the supplied data must match that defined in the J1979 standard.\n        \n      pendingInportBoolean\n        \n          Indicates the availablity of the application data.\n          False indicates the data is available.\n          When true, a J1979 request for the data will result in the negative\n          response code $78 (requestCorrectlyReceived-ResponsePending) followed\n          by a negative response code $78 message at 4.5s intervals until\n          pending transistions to false where upon the supplied infotype data is sent.\n        \n        \n          Currently this is only required by Infotype 0x06 (CVN).\n        \n      InfoTypeParamList\n        \n          A drop down to select the service 0x09 InfoType.\n        \n        \n          $02\n                    Vehicle Identification Number.\n                  $04\n                    Calibration Identifications\n                  \n                    Note the number of data items (NODI) is currently limited to 1 for this InfoType\n                  $06\n                    Calibration Verification Number (CVN)\n                  $0A\n                    ECUNAME\n                  $0B\n                    In-use Performance Tracking\n                  \n                    This infotype is automatically generated by the platform software using the data\n                    processed by the Diagnostic Monitor Entities (see\n                    ppr_DiagnosticMonitorEntity\n                    for more details). Any value passed here will be ignored.\n                  $0D\n                    Engine Serial Number\n                  $0F\n                    Exhaust Regulation Or Type Approval Number\n                  \n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDG.INFOTYPE.111": "The block pdg_InfotypeInput shall support the targets:\n            All targets.",
    "LLR.PLAT.PDG.INFOTYPE.211": "The block pdg_InfotypeInput shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PDG.INFOTYPE.012": "If the target subtype (as identified by the put_Identification block\n                ECU type,\n                Part Number and\n                Issue Number mask parameters)\n                is unsupported for this block, then the block  shall  raise an error.",
    "LLR.PLAT.PDG.INFOTYPE.013": "If the length in bytes of the in inport\n                data does not match that defined in SAE J1979 SEP2010 for the InfoType identified in\n                the InfoType block mask parameter, then\n                the block  shall  raise an error.",
    "LLR.PLAT.PDG.INFOTYPE.014": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is in.",
    "LLR.PLAT.PDG.INFOTYPE.015": "The block  shall  update the InfoType identified by the mask parameter\n                InfoType in accordance with\n                LLR.PLAT.PDG.INFOTYPE.003 and LLR.PLAT.PDG.INFOTYPE.004 using the data\n                provided by the inport in\n                at initialisation and on each iteration.",
    "LLR.PLAT.DTC.CLEARALL.001": "When requested by the application software, the platform  shall  clear all DTCs of the specified type\n              in the specified table.",
    "LLR.PLAT.DTC.CLEARALL.011": "Clearing DTCs  shall  only be carried out if the conditions described in\n              LLR.PLAT.DTC.CLEARCONDITIONS.* are met.",
    "LLR.PLAT.DTC.CLEARALL.002": "The platform shall provide a C interface function named\n                pdtc_clear_all() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table\n          in\n        const PDTC_TABLE_T *const\nPointer to table of DTCs. \n Cannot be NULL.pdtcf_type\n          in\n        const PIO_DTC_TYPE_T\nType of DTC (J1939, ISO, etc.) to match against. See the PIO header files for more details.\n                The function returns void.",
    "LLR.PLAT.DTC.CLEARALL.012": "The function pdtc_clear_all() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CLEARALL.013": "The function pdtc_clear_all() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.DTC.CLEARALL.003": "The platform  shall  reject calls if pdtcf_table has a NULL pointer, by\n                raising a recoverable error PDTC_CLEAR_ALL_INVALID_ARG.",
    "LLR.PLAT.DTC.CLEARALL.004": "If the interface checks pass then the function  shall  clear all DTCs identified by the table,\n                pdtcf_table of type pdtcf_type.",
    "LLR.PLAT.DTC.CLEARALL.005": "The platform shall provide a Simulink interface block named\n                pdtc_ClearAll that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionclearInportBoolean\n        \n          Set to 1 to force the\n          state of each DTC, with matching type to that specified by parameter\n          DTC type, to clear. Otherwise, set to 0 for no\n          change in DTC states.\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of DTC to act on in the DTC table specified by parameter\n          DTC table identifier.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.CLEARALL.014": "The block pdtc_ClearAll shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.CLEARALL.015": "The block pdtc_ClearAll shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.CLEARALL.006": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALL.007": "If the table specified by the mask parameter DTC table identifier\n                is not found in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALL.008": "If there are no tables specified in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALL.009": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.CLEARALL.010": "The block  shall  clear all DTCs specified in DTC table identifier\n                of DTC type when the inport\n                clear is set to 1 otherwise no action is taken.",
    "LLR.PLAT.DTC.CLEAR_DTCS.001": "When requested by the application software, the platform  shall  clear DTCs, which match the supplied\n              comparison criteria, of the specified type, emissions severity and state, in the specified table.",
    "LLR.PLAT.DTC.CLEAR_DTCS.002": "The platform  shall  allow the user to select that clearing DTCs shall only be carried out if the conditions described in\n              LLR.PLAT.DTC.CLEARCONDITIONS.* are met.",
    "LLR.PLAT.DTC.CLEAR_DTCS.012": "The platform  shall  allow the user to select that clearing DTCs shall be carried out regardless of the conditions\n              described in LLR.PLAT.DTC.CLEARCONDITIONS.*.\n            \n          \n            This is required to allow stored DTCs to be reset in conditions where OBD regulations do not apply: for example,\n            during production at end of line; or when transferring a used ECU to a different vehicle.  The application is responsible\n            for ensuring that this is not carried out in situations which would violate any relevant OBD regulations.",
    "LLR.PLAT.DTC.CLEAR_DTCS.003": "The platform shall provide a C interface function named\n                pdtc_clear_dtcs() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table\n          in\n        const PDTC_TABLE_T *const\nPointer to table of DTCs. \n Cannot be NULL.pdtcf_type\n          in\n        const PIO_DTC_TYPE_T\nType of DTC (J1939, ISO, etc.) to clear. See the PIO header files for more details.pdtcf_type_comparator\n          in\n        const PDTC_IT_TYPE_COMPARATOR_T\nThe comparison to apply to the type of DTCs to clear e.g. PDTC_IT_TYPE_DC pdtcf_esev\n          in\n        const PIO_EMISSION_SEV_TYPE_T\nEmissions severity of DTC to clear. See the PIO header files for more details.pdtcf_esev_comparator\n          in\n        const PDTC_IT_ESEV_COMPARATOR_T\nThe comparison to apply to the emissions severity of DTCs to clear e.g. PDTC_IT_ESEV_LT pdtcf_state\n          in\n        const PDTC_STATE_T\nState of DTCs to clear (e.g., PDTC_STATE_ACTIVE).pdtcf_state_comparator\n          in\n        const PDTC_IT_STATE_COMPARATOR_T\nThe comparison to apply to the state of DTCs to clear e.g. PDTC_IT_STATE_NE pdtcf_clear_unconditionally\n          in\n        const BOOL\nIf set TRUE, all DTCs meeting the terms of the comparator(s) will be cleared immediately, regardless of whether they are CARB permanent DTCs or Euro non-erasable DTCs. If set FALSE, any CARB permanent DTCs will be cleared under the conditions of the CARB regulations, and Euro non-erasable DTCs will never be cleared.\n Typically this would be set FALSE for clearing DTCs via OBD scan tool request, and would be set TRUE for a full reset of DTCs during production or in other situations where OBD regulations on clearing DTCs are not relevant (e.g. moving the ECU to a different vehicle).\n                The function returns void.",
    "LLR.PLAT.DTC.CLEAR_DTCS.103": "The function pdtc_clear_dtcs() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CLEAR_DTCS.203": "The function pdtc_clear_dtcs() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CLEAR_DTCS.004": "The platform  shall  reject calls if pdtcf_table has a NULL pointer, by\n                raising a recoverable error PDTC_CLEAR_DTCS_INVALID_ARG.",
    "LLR.PLAT.DTC.CLEAR_DTCS.005": "If the interface checks pass, then the function  shall  clear all DTCs identified by the table,\n                pdtcf_table which match the type pdtcf_type (in accordance with the comparator\n                given in pdtcf_type_comparator) and emissions severity\n                pdtcf_esev (in accordance with the comparator given in pdtcf_esev_comparator)\n                and state pdtcf_state\n                (in accordance with the comparator given in pdtcf_state_comparator).\n              Note: \n                For example, the user may wish to clear all DTCs with an emissions severity less than or equal to severity B1.\n                The pdtcf_esev_comparator parameter is provided for this purpose.",
    "LLR.PLAT.DTC.CLEAR_DTCS.013": "If pdtcf_clear_unconditionally is TRUE, all DTCs meeting the conditions in LLR.PLAT.DTC.CLEAR_DTCS.005\n                 shall  be cleared, regardless of whether any are configured as CARB permanent or Euro non-erasable.",
    "LLR.PLAT.DTC.CLEAR_DTCS.014": "If pdtcf_clear_unconditionally is FALSE, all DTCs meeting the conditions in LLR.PLAT.DTC.CLEAR_DTCS.005\n                 shall  be cleared if they meet the additional conditions specified in LLR.PLAT.DTC.CLEARCONDITIONS.*.",
    "LLR.PLAT.DTC.CLEAR_DTCS.006": "The platform shall provide a Simulink interface block named\n                pdtc_ClearDtcs that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionclearInportBoolean\n        \n          Set to 1 to force the state of each DTC to state\n          clear which match the block\n          parameters DTC type (in accordance with comparator Type comparison),\n          DTC emissions severity (in accordance with comparator Emissions severity comparison),\n          DTC state (in accordance with comparator State comparison).\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              Type comparisonParamList\n        \n          A drop-down selection\n          of the comparison to perform on the DTC's type (first step) when clearing DTCs, in the DTC table (specified by parameter\n          DTC table identifier).  See parameter DTC type for\n          the second step.\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of DTCs to use (second step) for clearing DTCs in the DTC table (specified by parameter\n          DTC table identifier).  If the parameter Type comparison is\n          set to 'Any' then this drop-down is not available.\n        \n      \n                Calibratable: no.\n              Emissions severity comparisonParamList\n        \n          A drop-down selection\n          of the comparison to perform on the DTC's emissions severity (first step) when clearing DTCs, in the DTC table (specified by parameter\n          DTC table identifier).  See parameter DTC emissions severity for\n          the second step.\n        \n      \n                Calibratable: no.\n              DTC emissions severityParamList\n        \n          A drop-down selection\n          of the emissions severity to use (second step) for clearing DTCs in the DTC table (specified by parameter\n          DTC table identifier).  If the parameter Emissions severity comparison is\n          set to 'Any' then this drop-down is not available.\n        \n      \n                Calibratable: no.\n              State comparisonParamList\n        \n          A drop-down selection\n          of the comparison to perform on the DTC's state (first step) when clearing DTCs, in the DTC table (specified by parameter\n          DTC table identifier).  See parameter DTC state for\n          the second step.\n        \n      \n                Calibratable: no.\n              DTC stateParamList\n        \n          A drop-down selection\n          of the DTC state to use (second step) for clearing DTCs in the DTC table (specified by parameter\n          DTC table identifier).  If the parameter State comparison is\n          set to 'Any' then this drop-down is not available.\n        \n      \n                Calibratable: no.\n              Clear DTCs unconditionallyParamBoolean\n        \n          If checked, this block will clear DTCs matching the comparison criteria above unconditionally, regardless\n          of whether they are configured as CARB permanent DTCs or as Euro non-erasable DTCs.\n        \n        \n          If unchecked, this block will only clear DTCs which match the comparison criteria above, and which are permitted\n          to be cleared at this time by OBD regulations.  Any CARB permanent DTCs will be cleared under the conditions\n          of the CARB regulations, and Euro non-erasable DTCs will never be cleared.\n        \n        \n          Typically this would be unchecked for clearing DTCs via OBD scan tool request, and would be checked for a full\n          reset of DTCs during production or in other situations where OBD regulations on clearing DTCs are not relevant\n          (e.g. moving the ECU to a different vehicle).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.CLEAR_DTCS.106": "The block pdtc_ClearDtcs shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.CLEAR_DTCS.206": "The block pdtc_ClearDtcs shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CLEAR_DTCS.007": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEAR_DTCS.008": "If the table specified by the mask parameter DTC table identifier\n                is not found in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEAR_DTCS.009": "If there are no tables specified in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEAR_DTCS.010": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.CLEAR_DTCS.011": "The block  shall  clear all DTCs specified in\n                DTC table identifier\n                of DTC type\n                (in accordance with comparator Type comparison)\n                and\n                emissions severity DTC emissions severity\n                (in accordance with comparator Emissions severity comparison)\n                and\n                state DTC state\n                (in accordance with comparator State comparison)\n                when the inport\n                clear is set to 1, otherwise no action is taken.\n              Note: \n                For example, the user may wish to clear all DTCs with an emissions severity less than or equal to severity B1.\n                The Emissions severity comparison parameter is provided for this purpose.",
    "LLR.PLAT.DTC.CLEAR_DTCS.015": "If Clear DTCs unconditionally is selected, all DTCs meeting the conditions in LLR.PLAT.DTC.CLEAR_DTCS.011\n                 shall  be cleared, regardless of whether any are configured as CARB permanent or Euro non-erasable.",
    "LLR.PLAT.DTC.CLEAR_DTCS.016": "If Clear DTCs unconditionally is not selected, all DTCs meeting the conditions in LLR.PLAT.DTC.CLEAR_DTCS.011\n                 shall  be cleared if they meet the additional conditions specified in LLR.PLAT.DTC.CLEARCONDITIONS.*.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.001": "When requested by the application software, the platform  shall  clear all active DTCs of the specified type\n              in the specified table.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.011": "Clearing DTCs  shall  only be carried out if the conditions described in\n              LLR.PLAT.DTC.CLEARCONDITIONS.* are met.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.002": "The platform shall provide a C interface function named\n                pdtc_clear_all_if_active() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table\n          in\n        const PDTC_TABLE_T *const\nPointer to table of DTCs. \n Cannot be NULL.pdtcf_type\n          in\n        const PIO_DTC_TYPE_T\nType of DTC (J1939, ISO, etc.) to match against. See the PIO header files for more details.\n                The function returns void.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.102": "The function pdtc_clear_all_if_active() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.202": "The function pdtc_clear_all_if_active() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.DTC.CLEARALLACTIVE.003": "The platform  shall  reject calls if pdtcf_table has a NULL pointer, by\n                  raising a recoverable error PDTC_CLEAR_ALL_IF_ACT_INVALID_ARG.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.004": "If the interface checks pass then the function  shall  clear all active DTCs identified by the table,\n                  pdtcf_table of type pdtcf_type.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.005": "The platform shall provide a Simulink interface block named\n                pdtc_ClearAllIfActive that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionclearInportBoolean\n        \n          Set to 1 to force the\n          state of each DTC, with matching type to that specified by parameter\n          DTC type, to clear if it is currently\n          active. Otherwise, set to 0 for no\n          change in DTC states.\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of DTC to act on in the DTC table specified by parameter\n          DTC table identifier.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.105": "The block pdtc_ClearAllIfActive shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.205": "The block pdtc_ClearAllIfActive shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.CLEARALLACTIVE.006": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.007": "If the table specified by the mask parameter DTC table identifier\n                is not found in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.008": "If there are no tables specified in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.009": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.CLEARALLACTIVE.010": "The block  shall  clear all active DTCs specified in\n                DTC table identifier\n                of DTC type when the inport\n                clear is set to 1 otherwise no action is taken.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.001": "When requested by the application software, the platform  shall  clear all inactive DTCs of the specified type\n              in the specified table.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.011": "Clearing DTCs  shall  only be carried out if the conditions described in\n              LLR.PLAT.DTC.CLEARCONDITIONS.* are met.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.002": "The platform shall provide a C interface function named\n                pdtc_clear_all_if_inactive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table\n          in\n        const PDTC_TABLE_T *const\nPointer to table of DTCs. \n Cannot be NULL.pdtcf_type\n          in\n        const PIO_DTC_TYPE_T\nType of DTC (J1939, ISO, etc.) to match against. See the PIO header files for more details.\n                The function returns void.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.102": "The function pdtc_clear_all_if_inactive() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.202": "The function pdtc_clear_all_if_inactive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.003": "The platform  shall  reject calls if pdtcf_table has a NULL pointer, by\n                  raising a recoverable error PDTC_CLEAR_ALL_IF_INACT_INVALID_ARG.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.004": "If the interface checks pass then the function  shall  clear all inactive DTCs identified by the table,\n                  pdtcf_table of type pdtcf_type.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.005": "The platform shall provide a Simulink interface block named\n                pdtc_ClearAllIfInactive that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionclearInportBoolean\n        \n          Set to 1 to force the\n          state of each DTC, with matching type to that specified by parameter\n          DTC type, to clear if it is currently\n          inactive. Otherwise, set to 0 for no\n          change in DTC states.\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of DTC to act on in the DTC table specified by parameter\n          DTC table identifier.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.105": "The block pdtc_ClearAllIfInactive shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.205": "The block pdtc_ClearAllIfInactive shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.006": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.007": "If the table specified by the mask parameter DTC table identifier\n                is not found in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.008": "If there are no tables specified in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.009": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.CLEARALLINACTIVE.010": "The block  shall  clear all inactive DTCs specified in DTC table identifier\n                of DTC type when the inport\n                clear is set to 1 otherwise no action is taken.",
    "LLR.PLAT.DTC.CLEARCONDITIONS.001": "For DTCs specified as \"non-erasable\" under Euro regulations, when a DTC is in Active state and a request\n              is received from a diagnostic scan tool requiring this DTC to be cleared, the DTC  shall  transition to\n              Previously Active state but  shall  not be cleared.\n           Note: \n              European directive 2005-78-EC Annex IV section 3.9.2 requires that non-erasable DTCs are not erased through the use of\n              diagnostic scan tools.\n            \n              There is no explicit requirement for DTCs to transition from Active to Previously Active\n              on command from a diagnostic scan tool.  However a basic analysis of use cases shows that when a fault is fixed by a service\n              technician and the service technician then attempts to clear DTCs, the technician and end user will expect the MIL to be\n              extinguished immediately, because the fault conditions no longer exist.  This requirement ensures that the MIL and DTCs behave\n              as expected by users, whilst ensuring that regulatory requirements on storing DTC information are still met.\n            \n              Source: Discussions between Dave Price and Tenneco",
    "LLR.PLAT.DTC.CLEARCONDITIONS.002": "For DTCs specified as \"non-erasable\" under Euro regulations, when a DTC is in state Pending and a request\n              is received from a diagnostic scan tool requiring this DTC to be cleared, the DTC  shall  be cleared.\n           Note: \n              European directive 2005-78-EC Annex IV section 3.7 only requires fault code storage for faults which have caused the MIL to be\n              illuminated.  If the MIL is not illuminated, there is no requirement for fault storage.",
    "LLR.PLAT.DTC.CLEARCONDITIONS.003": "For DTCs specified as \"non-erasable\" under Euro regulations, when a DTC is in state Previously Active and a request\n              is received from a diagnostic scan tool requiring this DTC to be cleared, the DTC state and all other stored data for this DTC\n               shall  remain unchanged.\n           Note: \n              European directive 2005-78-EC Annex IV section 3.9.2 requires that non-erasable DTCs are not erased through the use of\n              diagnostic scan tools.",
    "LLR.PLAT.DTC.CLEARCONDITIONS.004": "For DTCs which are not specified as \"non-erasable\" under Euro regulations, when a request\n              is received from a diagnostic scan tool requiring this DTC to be cleared, the DTC and all associated data  shall  be cleared.",
    "LLR.PLAT.DTC.CLEARCONDITIONS.005": "For DTCs specified as \"permanent\" under CARB regulations, when a DTC is in Active state and a request\n              is received from a diagnostic scan tool requiring this DTC to be cleared, the DTC  shall  not be cleared.  Instead, it shall\n              set a flag for the DTC to report that the DTC has been requested to be cleared.  The DTC shall then be\n              cleared at some time in the future if further conditions (fault not present, vehicle\/operating conditions met) are correct,\n              as specified by the DTC state machine in LLR.PLAT.DTC.DTC.053.\n           Note: \n              Source: CARB 19711 sections (d)(2.3.1)(C)(ii), (d)(2.3.2)(D)(ii).",
    "LLR.PLAT.DTC.CONTROL.001": "When the application software indicates that a new drive cycle has started, the platform  shall \n              update the states of all DTCs whose tests have been run (reported as faulty or not faulty) during the\n              previous drive cycle as required, according to the DTC state machine.\n           Note: \n              See requirements LLR.PLAT.DTC.DTC.* for details of DTC behaviour on drive cycles.\n            \n              Note that there is no concept of a time \"between\" drive cycles, regardless of whether the key, engine or ECU power is off.\n              The start of a new drive cycle forms the end of the previous drive cycle.",
    "LLR.PLAT.DTC.CONTROL.004": "If the target supports PPR then the PPR feature  shall  be informed of the new drive cycle.",
    "LLR.PLAT.DTC.CONTROL.005": "When the application software indicates that a warm-up has taken place, the platform  shall \n              update the states of all DTCs whose tests have been run (reported as faulty or not faulty) during the\n              current ignition cycle as required, according to the DTC state machine.\n            Note: \n              See requirements LLR.PLAT.DTC.DTC.* for details of DTC behaviour on drive cycles.\n            \n              Note that warm-up is considered as an attribute of an ignition cycle.  A warm-up cycle is defined as\n              an ignition cycle in which a warm-up takes place.  Depending on the DTC state machine requirements,\n              some actions may be required immediately when a warm-up is reported, but other actions may also be\n              appropriate later in the same ignition cycle after a warm-up has been reported.",
    "LLR.PLAT.DTC.CONTROL.028": "When the application software indicates that the engine is or is not running, the platform  shall \n              maintain timers for all DTCs whose tests have been run (reported as faulty or not faulty) during\n              the current ignition cycle and which require ageing by engine running time,\n              and shall carry out this ageing after the required time according to the\n              DTC state machine.\n            Note: \n              See requirements LLR.PLAT.DTC.DTC.* for details of DTC behaviour on engine running time.",
    "LLR.PLAT.DTC.CONTROL.033": "When the application software indicates that the engine is running, the platform  shall \n              maintain a common cumulative engine running timer for all the DTCs of severity level B1 - System Greatest B1 Counter.\n            Note: \n              Source: J1939-73 2013 spec, section \"Cumulative Continuous MI - System (DM39 - HCMI)\"\n                      UN ECE Regulation No. 49, Addendum 48, section \"OBD information\" specifies that the timers are 'engine operating hours'.\n            \n              The J1939-73 2013 spec, section \"System Greatest B1 Counter\" says - \"System Greatest B1 Counter provides the total amount of\n              time that one or more B1 DTCs have been active...\" and the heading says \"the system specific cumulative information\".\n              Hence, we have considered this to mean that this counter will never be reset - in line with the definition of\n              Cumulative continuous-MI counter in the UN ECE Regulation No. 49, Addendum 48.",
    "LLR.PLAT.DTC.CONTROL.035": "When the application software indicates that the engine is running, the platform  shall \n              maintain a common continuous engine running timer for all the DTCs of severity level B1 - Single B1-counter.\n            Note: \n              Source: UN ECE Regulation No. 49, Addendum 48, section \"MI illumination schemes\", sub-section \"Single B1-counter\"\n            \n              The UN-ECE regulation 49, section Single B1-counter says - \"The (Single) B1 counter shall be reset to zero when\n              three consecutive operating sequences have occurred during which no Class B1 malfunctions have been detected.\"\n              Hence, we have considered that there must *continuously* be at least one B1 failure for the given hours to decide the MI activation mode.",
    "LLR.PLAT.DTC.CONTROL.034": "When an OBD clear request has been received by the platform, and the application software subsequently\n              indicates that there are no DTCs of severity B1 that have to be in the Active state,\n              then the platform  shall  reset the Single B1-counter to 190 hours if it has exceeded the 200 hour limit.\n            Note: \n              Source: UN ECE Regulation No. 49, Addendum 48, section \"MI illumination schemes\"\n            \n              The Regulation says - \"In the case where the B1 counter has exceeded 200 engine running hours, the OBD\n              system shall set the counter to 190 engine running hours when the OBD system has determined that a Class B1 \n              malfunction is no longer confirmed and active, or when all Class B1 malfunctions have been erased by a scan tool.\"",
    "LLR.PLAT.DTC.CONTROL.036": "The platform  shall  reset the Single B1-counter to zero when three consecutive drive cycles\n              occur with no Class B1 DTC being Active.\n            Note: \n              Source: UN ECE Regulation No. 49, Addendum 48, section \"MI illumination schemes\"\n            \n              The Regulation says - \"The B1 counter shall be reset to zero when three consecutive operating sequences\n              have occurred during which no Class B1 malfunctions have been detected.\"",
    "LLR.PLAT.DTC.CONTROL.029": "When an OBD clear request has been received by the platform, and the application software subsequently\n            indicates that vehicle\/operating conditions are suitable for permanent DTCs in state\n            Active to cease illuminating the MIL, the platform  shall  carry out appropriate\n            DTC ageing as specified by the DTC state machine.\n          \n            Note: \n              Source: CARB 19711 sections (d)(2.3.1)(C)(ii), (d)(2.3.2)(D)(ii).\n            \n              The application software is required to meet the conditions from CARB 19711 section (d)(2.3.2)(D)(ii)b.3.\n              or appropriate alternative conditions as agreed with certification authorities.  These conditions\n              relate to vehicle, operating or environmental conditions, and as such are outside of the scope of the platform.\n              Whilst CARB sections (d)(2.3.1)(C)(ii)b.3 and (d)(2.3.2)(D)(ii)b.3 are specifically required for DTCs whose associated\n              monitors are not subject to minimum ratio requirements, the application software may optionally configure other permanent\n              DTCs to be cleared using the same logic, as stated in CARB sections (d)(2.3.1)(C)(ii)c. and (d)(2.3.2)(D)(ii)c.\n            \n              Note that CARB 19711 refers to \"erasing\" the DTC; in this context it corresponds to the DTC transition from \"Active\" to\n              \"Previously Active\".\n            \n              See requirements LLR.PLAT.DTC.DTC.* for details of DTC behaviour during DTC ageing.",
    "LLR.PLAT.DTC.CONTROL.009": "The platform shall provide a C interface function named\n                pdtc_plat_obd_update_dc_count() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_start_of_dc\n          in\n        BOOL\nIndicates whether it is the start of drive cycle or otherwise. \n Application should call pdtc_plat_obd_update_dc_count(TRUE) while transitioning into a new drive cycle.\n                The function returns void.",
    "LLR.PLAT.DTC.CONTROL.109": "The function pdtc_plat_obd_update_dc_count() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CONTROL.209": "The function pdtc_plat_obd_update_dc_count() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.010": "The platform  shall  register a drive cycle if the\n                pdtcf_start_of_dc parameter is true, otherwise no action is taken.",
    "LLR.PLAT.DTC.CONTROL.011": "The platform shall provide a C interface function named\n                pdtc_plat_obd_update_wup_count() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_start_of_wup\n          in\n        BOOL\nIndicates whether it is the start of warmup cycle or otherwise. \n Application should call pdtc_plat_obd_update_wup_count(TRUE) while transitioning into a new warm-up cycle.\n                The function returns void.",
    "LLR.PLAT.DTC.CONTROL.111": "The function pdtc_plat_obd_update_wup_count() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CONTROL.211": "The function pdtc_plat_obd_update_wup_count() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.012": "The platform  shall  register a warm-up taking place during the current ignition cycle if the\n                pdtcf_start_of_wup parameter is true, otherwise no action is taken.",
    "LLR.PLAT.DTC.CONTROL.013": "The platform shall provide a C interface function named\n                pdtc_plat_obd_update_ign_cyc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_start_of_ignc\n          in\n        BOOL\nIndicates whether it is the start of an ignition cycle or otherwise. \n Application should call pdtc_plat_obd_update_ign_cyc with pdtcf_start_of_ignc set to TRUE when transitioning into a new ignition cycle.\n                The function returns void.",
    "LLR.PLAT.DTC.CONTROL.113": "The function pdtc_plat_obd_update_ign_cyc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CONTROL.213": "The function pdtc_plat_obd_update_ign_cyc() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.014": "The platform  shall  register an ignition cycle if the\n                pdtcf_start_of_ignc parameter is true, otherwise no action is taken.",
    "LLR.PLAT.DTC.CONTROL.020": "The platform shall provide a C interface function named\n                pdtc_plat_obd_update_engine_running() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_engine_is_running\n          in\n        BOOL\nIf TRUE, indicates that engine is running\n                The function returns void.",
    "LLR.PLAT.DTC.CONTROL.120": "The function pdtc_plat_obd_update_engine_running() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CONTROL.220": "The function pdtc_plat_obd_update_engine_running() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.026": "The platform  shall  register the engine running if the pdtcf_engine_is_running parameter\n                is true, and  shall  register the engine stopped if the pdtcf_engine_is_running parameter is false.",
    "LLR.PLAT.DTC.CONTROL.030": "The platform shall provide a C interface function named\n                pdtc_plat_obd_update_clr_perm_ok() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_ok_to_clear_perm\n          in\n        BOOL\nIf TRUE, indicates that vehicle\/operating conditions are met according to CARB 19711 section (d)(2.3.1)(C)(ii)b..\n                The function returns void.",
    "LLR.PLAT.DTC.CONTROL.130": "The function pdtc_plat_obd_update_clr_perm_ok() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.CONTROL.230": "The function pdtc_plat_obd_update_clr_perm_ok() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.031": "The platform  shall  register that conditions are valid for a DTC configured as permanent and not\n                subject to minimum ratio requirements to transition from \"Active\" to \"Clear\" if the\n                pdtcf_ok_to_clear_perm parameter is true.",
    "LLR.PLAT.DTC.CONTROL.015": "The platform shall provide a Simulink interface block named\n                pdtc_Control that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiondc_startInportBoolean\n        \n          A transition from 0 to 1 indicates the start of a new\n          drive cycle. The input should remain high throughout the\n          drive cycle, but it must be switched low for at least\n          one iteration between cycles.\n        \n      wu_startInportBoolean\n        \n          A transition from 0 to 1 indicates the start of a new\n          warm-up cycle. The input should remain high throughout the\n          warm-up cycle, but it must be switched low for at least\n          one iteration between cycles.\n        \n      ic_startInportBoolean\n        \n          A transition from 0 to 1 indicates the start of a new\n          ignition cycle. The input should remain high throughout the\n          ignition cycle, but it must be switched low for at least\n          one iteration between cycles.\n        \n      eng_runningInportBoolean\n        \n          Set to 1 for engine running.  Set to 0 otherwise.\n        \n      ok_to_clr_permInportBoolean\n        \n          Set to 1 to indicate that vehicle\/operating conditions are currently met\n          such that an OBD clear request may be carried out for permanent DTCs.  Set to 0 otherwise.",
    "LLR.PLAT.DTC.CONTROL.115": "The block pdtc_Control shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.CONTROL.215": "The block pdtc_Control shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.CONTROL.016": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.CONTROL.017": "If the inport dc_start is 1 then the block  shall \n                register a drive cycle by setting the drive cycle flag, otherwise it shall clear the drive cycle flag.",
    "LLR.PLAT.DTC.CONTROL.018": "If the inport wu_start is 1 then the block  shall \n                register a warm-up cycle by setting the warm-up cycle flag, otherwise it shall clear the warm-up cycle flag.",
    "LLR.PLAT.DTC.CONTROL.019": "If the inport ic_start is 1 then the block  shall \n                register an ignition cycle by setting the ignition cycle flag, otherwise it shall clear the ignition cycle flag.",
    "LLR.PLAT.DTC.CONTROL.025": "If the inport eng_running is 1 then the block  shall \n                register the engine running by setting the engine running flag, otherwise it shall clear the engine running flag.",
    "LLR.PLAT.DTC.CONTROL.032": "If the inport ok_to_clr_perm is 1 then the block  shall \n                register that conditions are valid for a DTC configured as permanent and not\n                subject to minimum ratio requirements to transition from \"Active\" to \"Clear\".",
    "LLR.PLAT.DTC.DTC.080": "In C, DTCs  shall  be defined by appropriate definition of structures.\n            Note: \n              The detail of these structures is considered to be implementation, and as such should not be specified in requirements.",
    "LLR.PLAT.DTC.DTC.007": "The platform shall provide a C interface function named\n                pdtc_update_plat_obd_dtc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_const_dtc\n          in\n        const PDTC_DTC_T *const\nPointer to DTC to update. \n Cannot be NULL.pdtcf_test_failed\n          in\n        BOOL\nTRUE = Test failed for this DTC in current runFALSE = Test passed for this DTC in current run\npdtcf_test_completed\n          in\n        BOOL\nTRUE = Test for this DTC has been run before current callFALSE = Test for this DTC has not been run before current call\n\n                The function returns a value of type\n                PDTC_ERROR_CODE_T\n                with a value of:\n              PDTC_OK - if the function completes without issuePDTC_UPDATE_INVALID_ARG - if the input parameters are invalidPDTC_BAD_LICENSE - if the user is not licensed to use this function",
    "LLR.PLAT.DTC.DTC.107": "The function pdtc_update_plat_obd_dtc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.DTC.207": "The function pdtc_update_plat_obd_dtc() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.DTC.008": "The platform  shall  reject calls with NULL pointers by\n                raising a recoverable error PDTC_UPDATE_INVALID_ARG and returning PDTC_UPDATE_INVALID_ARG.",
    "LLR.PLAT.DTC.DTC.010": "If pdtcf_test_completed is true then the platform  shall  check to see if any state transitions are required\n                otherwise just return with PDTC_OK.",
    "LLR.PLAT.DTC.DTC.011": "The function  shall  determine if any state transitions are required by using the pdtcf_test_failed parameter.",
    "LLR.PLAT.DTC.DTC.012": "The platform shall provide a C interface function named\n                pdtc_get_dtc_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_dtc\n          in\n        const PDTC_DTC_T *const\nPointer to DTC to retrieve values from. Cannot be NULL.pdtcf_lamp_bitmap\n          out\n        U8 *\nPointer to location to accept bitmap of lamp information (relevant to J1939 DTCs only). This location will be set to the value of the pdtcf_lamp_bitmap_in parameter used in the most recent call to pdtc_update_j1939_dtc.\n May be NULL, in which case no output is written for this value.\n Note that this is only used by the legacy (deprecated) interface for J1939 DTCs, to allow backwards compatibility for existing applications, and may be removed in a future version of the API. Instead of this parameter, use one of pdtc_get_lamp_state(), pdtc_get_MIL_status(), pdtc_get_RSL_status(), pdtc_get_AWL_status(), pdtc_get_Protect_lamp_status(), or pdtc_get_j1939_current_lamps().pdtcf_state\n          out\n        PDTC_STATE_T *\nPointer to where the current DTC state will be written. One of PDTC_STATE_CLEAR, PDTC_STATE_ACTIVE, PDTC_STATE_INACTIVE or PDTC_STATE_PENDING will be written. \n May be NULL, in which case no output is written for this value.pdtcf_count\n          out\n        U8 *\nPointer to where the current J1939-style DTC activation count will be written. \n May be NULL in which case no output is written for this value. \n Range: [0, 127] counts\n                The function returns a value of type\n                PDTC_ERROR_CODE_T\n                with a value of:\n              PDTC_OK - if the function completes without issuePDTC_GET_DTC_STATUS_INVALID_ARG - if the input parameters are invalidPDTC_BAD_LICENSE - if the user is not licensed to use this function",
    "LLR.PLAT.DTC.DTC.112": "The function pdtc_get_dtc_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.DTC.212": "The function pdtc_get_dtc_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.DTC.013": "The platform  shall  reject calls with a NULL pointer in pdtcf_dtc by\n                  returning PDTC_GET_DTC_STATUS_INVALID_ARG.",
    "LLR.PLAT.DTC.DTC.014": "If parameter checks pass then the function  shall  update pdtcf_lamp_bitmap with the DTC lamp state\n                value most recently set by a corresponding call to pdtc_update_dtc().",
    "LLR.PLAT.DTC.DTC.015": "If parameter checks pass then the function  shall  update pdtcf_state with the DTC state.",
    "LLR.PLAT.DTC.DTC.016": "If parameter checks pass then the function  shall  update pdtcf_count with the DTC count, reporting\n                the number of times this DTC has transitioned to the 'Active' state.",
    "LLR.PLAT.DTC.DTC.017": "The platform shall provide a Simulink interface block named\n                pdtc_DiagnosticTroubleCodeExt that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiontest_failedInportBoolean\n        \n          Set to 1 if this DTC is currently in the \"faulty\" condition.\n        \n        \n          Range: 0 or 1\n        \n      test_completedInportBoolean\n        \n          Set to 1 if the test has been completed for this DTC (can be hardwired\n          to 1 for a continuously monitored DTC).\n        \n        \n          Range: 0 or 1\n        \n      stateOutportInteger\n        \n          Set to the value of the\n          current DTC state (see the DTC states descriptions\n          for a list of states and values).\n        \n      countOutportInteger\n        \n          A count of the number of times\n          a J1939 DTC has changed to the active state.\n          Available only if the parameter DTC type is J1939 DTC,\n          and currently not supported by the platform-controlled fault handling.\n        \n        \n          Range: [0, 127] counts - 0 to 126 (The value 127 is reserved for indicating not available).\n        \n      dc_countOutportInteger\n        \n          Drive cycle count. The number of drive cycles to 'debounce' the DTC\n          state before setting it to active. This is exported for information only,\n          as the platform is responsible for progressing the state machine.\n        \n        \n          Range: [0, 127]\n        \n      wu_countOutportInteger\n        \n          Warm-up cycle count. The number of warm-up cycles in which the DTC has not\n          failed - used to 'heal' faults that are no longer present. This is exported\n          for information only, as the platform is responsible for progressing the\n          state machine.\n        \n        \n          Range: [0, 127]\n        \n      DTC nameParamString\n        \n          An optional name can be given to a DTC to identify it for calibrating\n          the ID parameters. If no name is given, it will be allocated a name\n          when the model is built. Note that this allocated name can change\n          between builds, so should not be use for calibration. If a DTC will\n          need to be calibrated, it should be explicitly named.\n        \n        \n          Generation of DDE entries for DTCs needs to be\n          enabled. See Configuration options\n          for more details.\n        \n      \n                Calibratable: no.\n              DTC table identifierParamString\n        \n          The name of\n          the DTC table to store this DTC in (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of the DTC.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Suspect parameter numberParamInteger\n        \n          The value\n          of the SPN for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type includes J1939 DTC.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              Failure mode indicatorParamInteger\n        \n          The value\n          of the FMI for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type includes J1939 DTC.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Conversion methodParamInteger\n        \n          The value\n          of the CM for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type includes J1939 DTC.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: used during initialisation (power-up).\n              ISO IDParamInteger\n        \n          The value of the ID for this DTC. This ID uniquely identifies the DTC.\n          Available only if the parameter DTC type includes ISO DTC.\n        \n        \n          Range: [0, 65535]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Emissions severity levelParamList\n        \n          A drop-down\n          selection of the emissions severity level at which a DTC fits.\n          This allows the modeller to combine\n          \"emissions related\" and other DTCs within the same system.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              UDS severity levelParamList\n        \n          A drop-down\n          selection of the UDS service $19 severity level for the DTC.\n          Available only if the parameter DTC type includes ISO DTC.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              MIL actionParamInteger\n        \n          The action for the Malfunction Indicator Lamp when this DTC is active.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              RSL actionParamInteger\n        \n          The action for the Red Stop Lamp when this DTC is active.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              AWL actionParamInteger\n        \n          The action for the Amber Warning Lamp when this DTC is active.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              PL actionParamInteger\n        \n          The action for the Protection Lamp when this DTC is active.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              PermanentParamBoolean\n        \n          Whether or not this DTC is considered 'permanent' (as defined by\n          CARB\/EPA) when the DTC is active.  If the ECU is intended to comply with\n          CARB, this should be selected for all DTCs that light the MIL.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Requires vehicle\/operating conditions for OBD clear requestParamBoolean\n        \n          Available only if the parameter Permanent is true.\n          CARB requires that for permanent DTCs, an OBD clear request does not immediately clear the DTC;\n          instead the DTC may only be cleared when the ECU has verified that the fault is no longer\n          present.\n        \n        \n          If this option is selected, vehicle\/operating conditions as specified by CARB must have been met\n          during a drive cycle since an OBD clear request was received, ensuring that the vehicle has been\n          exercised over a range of behaviour which would be likely to detect any fault that still exists.\n          The test for this DTC must then have been completed (during the same drive cycle or a later one)\n          and report no fault existing.  At the end of the drive cycle in which the test for this DTC is run,\n          the DTC is cleared as per a normal OBD clear request.\n        \n        \n          If this option is unselected, vehicle\/operating conditions are not required.  The test for this\n          DTC must have been completed and report no fault existing  since the OBD clear request was received.\n          At the end of the drive cycle in which the test for this DTC is run,\n          the DTC is cleared as per a normal OBD clear request.\n        \n        \n          Vehicle\/operating conditions met is indicated by the inport ok_to_clr_perm to the\n          block pdtc_Control.\n        \n        \n          CARB requires that this option is selected for DTCs relating to specific monitors, and optionally\n          may be selected for DTCs relating to other monitors.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Non-erasableParamBoolean\n        \n          Whether or not this DTC is non-erasable (as defined by\n          Euro regulations).\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Active drive cyclesParamInteger\n        \n          The number of drive cycles for which the fault condition must be present\n          before this DTC automatically transitions from Pending to Active. By default,\n          this parameter is set to 1 (as recommended by the CARB regulations).\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Previously active drive cyclesParamInteger\n        \n          The number of drive cycles for which the fault condition must be absent\n          before this DTC automatically transitions from Active to Previously Active.\n          By default, this parameter is set to 3 (as recommended by the CARB\n          regulations).\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              DTC de-activate using engine running timeParamBoolean\n        \n          Whether or not this DTC uses elapsed engine running time for it to transition from Active to Previously Active.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Elapsed engine running time for de-activationParamInteger\n        \n          The value of the elapsed engine running time for the DTC to transition from Active to Previously Active\n          Available only if the parameter DTC de-activate using engine running time is checked.\n        \n        \n          Range: [0, 47185920] seconds\n        \n      \n                Calibratable: used during initialisation (power-up).\n              DTC clear using warmup cyclesParamBoolean\n        \n          Whether or not this DTC uses warmup cycles for it to transition from Previously Active to Clear.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Clear warm-up cyclesParamInteger\n        \n          The number of warm-up cycles for which the fault condition must be absent\n          before this DTC automatically transitions from Previously Active to Clear.\n          By default, this parameter is set to 40 (as recommended by the CARB\n          regulations).\n          Available only if the parameter DTC clear using warmup cycles is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              DTC clear using engine running timeParamBoolean\n        \n          Whether or not this DTC uses elapsed engine running time for it to transition from Previously Active to Clear.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Elapsed engine running time for clearParamInteger\n        \n          The value of the elapsed engine running time for the DTC to transition from Previously Active to Clear.\n          Available only if the parameter DTC clear using engine running time is checked.\n        \n        \n          Range: [0, 47185920] seconds\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Regulated exhaust level exceedance DTCParamBoolean\n        \n          Whether or not regulated exhaust level exceedance applies to this DTC.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Has torque derateParamBoolean\n        \n          Whether or not this DTC has torque derate.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Time until derateParamInteger\n        \n          The amount of time until the derate will occur, should this DTC become active.\n          Available only if the parameter Has torque derate is checked.\n        \n        \n          Range: [0, 225000] seconds\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Freeze frame associated with this DTCParamString\n        \n          A reference to the name of the frame frame to capture is entered here (see pff_FreezeFrame for specifics).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.DTC.117": "The block pdtc_DiagnosticTroubleCodeExt shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.DTC.217": "The block pdtc_DiagnosticTroubleCodeExt shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.DTC.018": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.019": "If the mask parameter DTC table identifier\n                is not found in a pdtc_Table block in the model then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.020": "If the parameter Suspect parameter number is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.021": "If the parameter Failure mode indicator is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.022": "If the parameter Conversion method is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.023": "If the parameter ISO ID is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.024": "If the parameter Active drive cycles is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.025": "If the parameter Previously active drive cycles is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.026": "If the parameter Clear warm-up cycles is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.027": "If another pdtc_DiagnosticTroubleCodeExt block with the same DTC name is found in the model,\n                the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.028": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.DTC.044": "The block  shall  write the value of the inport test_failed to the 'test failed'\n                flag in the platform for the specified DTC name and\n                DTC table identifier.",
    "LLR.PLAT.DTC.DTC.045": "The block  shall  write the value of the inport test_completed to the 'test completed'\n                flag in the platform for the specified DTC name and\n                DTC table identifier.",
    "LLR.PLAT.DTC.DTC.046": "The block  shall  update the outport state with the state of the DTC obtained from the platform.",
    "LLR.PLAT.DTC.DTC.047": "The block  shall  update the outport count with the DTC occurrence count from the platform.",
    "LLR.PLAT.DTC.DTC.048": "The block  shall  update the outport dc_count with the drive cycle count of the DTC\n                obtained from the platform.",
    "LLR.PLAT.DTC.DTC.049": "The block  shall  update the outport wu_count with the warm up cycle count of the DTC\n                obtained from the platform.",
    "LLR.PLAT.DTC.DTC.053": "The platform  shall  maintain the state of the DTC using the 'test completed' and 'test run' flags given by the application,\n              drive cycle completion, warm-up ignition cycle completion, engine running time and overall DTC control setting (via UDS\n              service 0x85), according to the state machine below:-\n            Note: \n              Note that this state machine may be implemented by actions divided across multiple functions.  The division of this state\n              machine across functions and tasks is considered to be implementation-specific, and as such is not specified here.\n            Note: \n              This state machine covers the following use case scenarios.  Many use cases below are mutually exclusive, which dictates the\n              configuration options required.  Note that these use cases are listed only for information, and do not themselves form requirements.\n            \n                  DTC transitions from Clear to Active immediately on fault.\n                  (Non-emissions-related manufacturer-specific DTCs; possibly emissions-related DTCs, CARB 19711 (f)(2.4.1)(ii) as an implementation of commanding slow flash)\n                \n                  DTC transitions from Clear via Pending to Active after faults detected on successive drive cycles.\n                  (Emissions-related DTCs, CARB 19711 (d)(2.2))\n                \n                  DTC transitions from Clear to Pending, and returns to Clear at end of subsequent drive cycle if fault is transient and test passes on subsequent drive cycle.\n                  (Emissions-related DTCs, CARB 19711 (d)(2.2))\n                \n                  DTC transitions from Active to Clear immediately when test passes.\n                  (Non-emissions-related manufacturer-specific DTCs)\n                \n                  DTC transitions from Active to Previously Active immediately when test passes.\n                  (Emissions-related DTCs, CARB 19711 (f)(7.4.2)(B))\n                \n                  DTC transitions from Active to Previously Active after multiple successive drive cycles with test passed.\n                  (Emissions-related DTCs, CARB 19711 (d)(2.3.1)(A), Euro 2005-78-EC Annex IV section 3.8.1)\n                \n                  DTC transitions from Active to Previously Active after multiple successive drive cycles with test passed,\n                  or after engine is running for some time with test passed.\n                  (Emissions-related DTCs, Euro 2005-78-EC Annex IV section 3.8.1)\n                \n                  DTC transitions from Active to Clear on OBD reset request.\n                  (Covered by LLR.CLEAR requirements and not shown on the state machine)\n                \n                  CARB permanent DTC transitions from Active to Previously Active after OBD reset request and subsequent\n                  drive cycle with test passed.\n                  (Permanent emissions-related DTCs, CARB 19711 (d)(2.3.1)(C)(ii)a.)\n                \n                  CARB permanent DTC transitions from Active to Previously Active after OBD reset request, subsequent\n                  drive cycle with test passed, and subsequent drive cycle with suitable vehicle\/operating conditions met.\n                  (Permanent emissions-related DTCs, CARB 19711 (d)(2.3.1)(C)(ii)b.)\n                \n                  DTC transitions from Previously Active to Clear when test passes on multiple successive warm-up cycles.\n                  (Emissions-related DTCs, CARB 19711 (d)(2.3.1)(B))\n                \n                  DTC transitions from Previously Active to Clear when test passes on multiple successive warm-up cycles,\n                  or when test passes and engine is running for some time..\n                  (Emissions-related DTCs, Euro 2005-78-EC Annex IV section 3.9.1)\n                \n                  DTC transitions from Previously Active to Clear when test passes and engine is running for some time.\n                  (Emissions-related DTCs, Euro 2005-78-EC Annex IV section 3.9.2)\n                \n                  DTC transitions from Previously Active to Active immediately on fault.\n                  (Optional manufacturer-specific behaviour)\n                \n                  DTC transitions from Previously Active to Pending immediately on fault, and then to Active\n                  if fault detected on subsequent drive cycles, or back to Previously Active if test passes on\n                  subsequent drive cycle.\n                  (Optional manufacturer-specific behaviour)",
    "LLR.PLAT.DTC.DTC.081": "The DTC state machine specified in LLR.PLAT.DTC.DTC.053  shall  maintain its state across ignition cycles.\n              As such, all relevant data to allow resumption of\n              the DTC state machine shall be held in non-volatile storage, as described in LLR.PLAT.DTC.MEMORY.001.\n            Note: \n              Note that this includes all relevant timers, counters and flags, as well as the DTC state itself.\n            \n              Note also that timers, counters and flags which are reset on ignition cycles need not use non-volatile storage, since\n              loss of power implicitly indicates a new ignition cycle.",
    "LLR.PLAT.DTC.DTC.077": "When the 'test completed' flag is set, the status of the 'test run' flag  shall  be stored in RAM for reporting\n              the transient fault state via J1939 DM35.\n              When the 'test completed' flag is cleared, the stored status shall be held.\n              The flag shall initially report that no fault is present.\n            \n          \n            Source: J1939-73, Feb 2010.",
    "LLR.PLAT.DTC.DTC.079": "When the 'test completed' flag is set, this  shall  be stored in non-volatile storage to indicate via\n              KW2000-3 DTC status bit DTCReadinessFlag that the test has been run since the last successful OBD clear request.\n              This status shall be reset when the DTC is cleared via a successful OBD clear request, or if non-volatile\n              storage of DTCs fails.\n            \n          \n            Source: KW2000-3 v1.5, section 8.2.1.2.",
    "LLR.PLAT.DTC.DTC.054": "The platform shall provide a C interface function named\n                pdtc_update_j1939_dtc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_dtc\n          in\/out\n        const PDTC_DTC_T *const\nPointer to DTC to update. Cannot be NULL.pdtcf_active_in\n          in\n        U8\nTrue if the DTC should become active, false otherwise.pdtcf_lamp_bitmap\n          in\n        U8\nBitmap of lamp information (for J1939 DTCs). For future software, this must always be set to PDTC_LAMPS_OFF, which selects lamp state as calibrated for the DTC. For legacy software this may be set to a bitmap where bits 7:6 correspond to the malfunction lamp, bits 5:4 correspond to the red lamp, bits 3:2 correspond to the amber lamp and bits 1:0 correspond to the protect lamp. The bit pattern for each lamp state is determined by the J1939 specification.pdtcf_active_out\n          out\n        U8 *\nPointer to where the boolean result of whether the DTC is active or not is to be stored. \n Cannot be NULL.pdtcf_state\n          out\n        U8 *\nPointer to where the current DTC state will be written. Cannot be NULL.\n Range: 1 = Clear, 2 = Active, 3 = Inactivepdtcf_count\n          out\n        U8 *\nPointer to where the current DTC activation count will be written. \n Cannot be NULL. \n Range: [0, 127] counts\n                The function returns void.",
    "LLR.PLAT.DTC.DTC.154": "The function pdtc_update_j1939_dtc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.DTC.254": "The function pdtc_update_j1939_dtc() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.DTC.DTC.055": "The platform  shall  reject calls with a NULL pointer in pdtcf_dtc,\n                  pdtcf_active_out, pdtcf_state or pdtcf_count\n                  by returning PDTC_UPDATE_INVALID_ARG.",
    "LLR.PLAT.DTC.DTC.056": "If parameter checks pass then the function  shall  change states based on pdtcf_active_in\n                indication of whether the fault is active.",
    "LLR.PLAT.DTC.DTC.057": "If parameter checks pass then the function  shall  set lamp statuses as specified by pdtcf_lamp_bitmap,\n                using the following bit representation:-\n              Bit 7Bit 6Bit 5Bit 4Bit 3Bit 2Bit 1Bit 0Lamp status selectedXXXXXX00Protect lamp - slow flashXXXXXX01Protect lamp - fast flashXXXXXX10Protect lamp - continuous onXXXXXX11Protect lamp - continuous offXXXX00XXAmber warning lamp - slow flashXXXX01XXAmber warning lamp - fast flashXXXX10XXAmber warning lamp - continuous onXXXX11XXAmber warning lamp - continuous offXX00XXXXRed stop lamp - slow flashXX01XXXXRed stop lamp - fast flashXX10XXXXRed stop lamp - continuous onXX11XXXXRed stop lamp - continuous off00XXXXXXMIL - slow flash01XXXXXXMIL - fast flash10XXXXXXMIL - continuous on11XXXXXXMIL - continuous off",
    "LLR.PLAT.DTC.DTC.058": "If parameter checks pass then the function  shall  update pdtcf_active_out with TRUE (1)\n                if the DTC is in state 'Active' or with FALSE (0) if the DTC is in any other state.",
    "LLR.PLAT.DTC.DTC.059": "If parameter checks pass then the function  shall  update pdtcf_state with the current DTC state,\n                as specified by enumeration PDTC_STATE_T.",
    "LLR.PLAT.DTC.DTC.060": "If parameter checks pass then the function  shall  update pdtcf_count with the DTC active count.",
    "LLR.PLAT.DTC.DTC.061": "The platform shall provide a C interface function named\n                pdtc_update_iso_dtc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_dtc\n          in\/out\n        const PDTC_DTC_T *const\nPointer to DTC to update. Cannot be NULL.pdtcf_state_in\n          in\n        PDTC_STATE_T\nThe state to change to (or remain at).\n                The function returns a value of type\n                PDTC_ERROR_CODE_T\n                with a value of:\n              PDTC_OK - if the function completes without issuePDTC_UPDATE_INVALID_ARG - if the input parameters are invalidPDTC_BAD_LICENSE - if the user is not licensed to use this function",
    "LLR.PLAT.DTC.DTC.161": "The function pdtc_update_iso_dtc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.DTC.261": "The function pdtc_update_iso_dtc() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.DTC.062": "The platform  shall  reject calls with a NULL pointer in pdtcf_dtc by\n                  returning PDTC_UPDATE_INVALID_ARG.",
    "LLR.PLAT.DTC.DTC.063": "If parameter checks pass then the function  shall  attempt to transition to the state requested by\n                pdtcf_state_in.",
    "LLR.PLAT.DTC.DTC.064": "Lamp states required for this DTC  shall  be taken from the DTC configuration and shall not be explicitly commanded.",
    "LLR.PLAT.DTC.DTC.065": "The platform shall provide a Simulink interface block named\n                pdtc_DiagnosticTroubleCode that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionactiveInportBoolean\n        \n          Set to 1 if the dtc is\n          active, set to zero otherwise.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: 0 or 1\n        \n      lamp_malfunctionInportInteger\n        \n          Set to desired lamp state (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off).\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 3]\n        \n      lamp_redInportBoolean\n        \n          Set to desired lamp state (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off).\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 3]\n        \n      lamp_amberInportBoolean\n        \n          Set to desired lamp state (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off).\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 3]\n        \n      lamp_protectInportBoolean\n        \n          Set to desired lamp state (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off).\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 3]\n        \n      active.OutportBoolean\n        \n          Set to 1 if the dtc\n          is in the active state, set to zero otherwise.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n      stateOutportList\n        \n          Set to the value of the\n          current DTC state (see the DTC types descriptions\n          for a list of states and values).\n          Available only if the parameter DTC type is J1939 DTC.\n        \n      countOutportInteger\n        \n          A count of the number of times\n          a DTC has changed to the active state.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 127]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to store this DTC in (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of the DTC.\n        \n      \n                Calibratable: no.\n              Suspect parameter numberParamInteger\n        \n          The value\n          of the SPN for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              Failure mode indicatorParamInteger\n        \n          The value\n          of the FMI for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: no.\n              Conversion methodParamInteger\n        \n          The value\n          of the CM for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n          Available only if the parameter DTC type is J1939 DTC.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.DTC.165": "The block pdtc_DiagnosticTroubleCode shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.DTC.265": "The block pdtc_DiagnosticTroubleCode shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.DTC.066": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.067": "If the parameter Suspect parameter number is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.068": "If the parameter Failure mode indicator is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.069": "If the parameter Conversion method is out of range or the wrong type,\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.070": "If another pdtc_DiagnosticTroubleCode block is found in the model with the same SPN, FMI and conversion method,\n                the block  shall  raise an error.",
    "LLR.PLAT.DTC.DTC.078": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.DTC.072": "The block  shall  write the value of the inport active to the 'active'\n                flag in the platform for the specified DTC.",
    "LLR.PLAT.DTC.DTC.073": "The block  shall  write the values of the inports lamp_protect,\n                lamp_amber, lamp_red\n                and lamp_malfunction to the lamp statuses in the platform for the\n                specified DTC.  Valid inport values are:-\n              ValueLamp status selected0Slow flash1Fast flash2Continuous on3Continuous off",
    "LLR.PLAT.DTC.DTC.074": "The block  shall  update the outport active with a value of 1 if the state of the\n                DTC obtained from the platform is 'Active', or 0 if the DTC is in any other state.",
    "LLR.PLAT.DTC.DTC.075": "The block  shall  update the outport state with the state of the DTC obtained from the platform,\n                according to the enumeration PDTC_STATE_T.",
    "LLR.PLAT.DTC.DTC.076": "The block  shall  update the outport count with the DTC occurrence count from the platform.",
    "LLR.PLAT.DTC.DTC.002": "For J1939 DTCs, the platform  shall  maintain the state for DTCs as shown in the following state diagram:",
    "LLR.PLAT.DTC.MATCHEXISTS.001": "The platform  shall  determine if one or more DTCs exist of given type, severity and state.",
    "LLR.PLAT.DTC.MATCHEXISTS.002": "The platform shall provide a C interface function named\n                pdtc_match_exists() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table\n          in\n        const PDTC_TABLE_T *const\nPointer to table of DTCs. \n Cannot be NULL.pdtcf_type\n          in\n        const PIO_DTC_TYPE_T\nType of DTC (J1939, ISO, etc.) to match against. See the PIO header files for more details.pdtcf_esev\n          in\n        const PIO_EMISSION_SEV_TYPE_T\nEmissions severity of DTC to match against. See the PIO header files for more details.pdtcf_esev_gte_test\n          in\n        BOOL\nSet to TRUE if the function is to match against DTCs with an emissions severity greater than or equal to that supplied in parameter pdtcf_esev. Set to FALSE if the function is to match against DTCs with an emissions severity equal to that supplied in parameter pdtcf_esev.pdtcf_state\n          in\n        const PDTC_STATE_T\nState of DTC to match against (e.g., PDTC_STATE_ACTIVE).pdtcf_count\n          out\n        U16 *\nCount of the number of matching DTCs.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - At least one matching DTC exists. FALSE - Otherwise.",
    "LLR.PLAT.DTC.MATCHEXISTS.102": "The function pdtc_match_exists() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.MATCHEXISTS.202": "The function pdtc_match_exists() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.MATCHEXISTS.003": "The platform  shall  reject calls with NULL pointers by\n                raising a recoverable error PDTC_MATCH_EXISTS_INVALID_ARG.",
    "LLR.PLAT.DTC.MATCHEXISTS.015": "If the parameter pdtcf_esev_compare_gte is set to TRUE, the function  shall  attempt to match\n                DTCs with an emissions severity greater than or equal to the emissions severity value pdtcf_esev.\n                Otherwise, the function  shall  attempt to match DTCs with an emissions severity equal to the\n                emissions severity value pdtcf_esev.",
    "LLR.PLAT.DTC.MATCHEXISTS.004": "The function  shall  return TRUE if at least one DTC exists within pdtcf_table which matches the\n                pdtcf_type, and emissions severity value pdtcf_esev\n                (in accordance with requirement LLR.PLAT.DTC.MATCHEXISTS.015) and state pdtcf_state.",
    "LLR.PLAT.DTC.MATCHEXISTS.005": "The function  shall  return FALSE if no DTC exists within pdtcf_table which matches the\n                pdtcf_type, and emissions severity value pdtcf_esev\n                (in accordance with requirement LLR.PLAT.DTC.MATCHEXISTS.015) and state pdtcf_state.",
    "LLR.PLAT.DTC.MATCHEXISTS.016": "The function  shall  return a count of the number of DTCs that exist within pdtcf_table which match the\n                pdtcf_type, and emissions severity value pdtcf_esev\n                (in accordance with requirement LLR.PLAT.DTC.MATCHEXISTS.015) and state pdtcf_state.",
    "LLR.PLAT.DTC.MATCHEXISTS.006": "The platform shall provide a Simulink interface block named\n                pdtc_MatchExists that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiondtc_matchOutportBoolean\n        \n          Set to 1 if at least one DTC exists, in the DTC table, that matches the criteria.  Set to 0, otherwise.\n        \n      dtc_countOutportInteger\n        \n          Set to the number of DTCs, in the DTC table, that match the criteria.\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              DTC typeParamList\n        \n          A drop-down selection\n          of the type of DTCs to match in the DTC table (specified by parameter\n          DTC table identifier).\n        \n      \n                Calibratable: no.\n              DTC emissions severityParamList\n        \n          A drop-down selection\n          of the emissions severity of the DTCs to match in the DTC table (specified by parameter\n          DTC table identifier).\n        \n      \n                Calibratable: no.\n              GTE emissions comparisonParamBoolean\n        \n          If this option is checked, the block will attempt to match DTCs that have an emissions severity\n          greater than or equal to the DTC emissions severity.  Otherwise,\n          the block will attempt to match DTCs that have an emissions severity equal\n          to the DTC emissions severity.\n        \n      \n                Calibratable: no.\n              DTC stateParamList\n        \n          A drop-down selection\n          of the state of the DTCs to match in the DTC table (specified by parameter\n          DTC table identifier).\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution in seconds.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.MATCHEXISTS.106": "The block pdtc_MatchExists shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.MATCHEXISTS.206": "The block pdtc_MatchExists shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.MATCHEXISTS.007": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.DTC.MATCHEXISTS.008": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.MATCHEXISTS.009": "If the mask parameter DTC table identifier\n                is not found in a pdtc_Table block then the block  shall  raise an error.",
    "LLR.PLAT.DTC.MATCHEXISTS.010": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.DTC.MATCHEXISTS.014": "If the parameter GTE emissions comparison is checked, the function  shall  attempt to match\n              DTCs with an emissions severity greater than or equal to the emissions severity DTC emissions severity.\n              Otherwise, the function  shall  attempt to match DTCs with an emissions severity equal to the emissions severity\n              DTC emissions severity.",
    "LLR.PLAT.DTC.MATCHEXISTS.011": "The block  shall  set the outport dtc_match\n                to TRUE if at least one DTC exists within table DTC table identifier\n                of type DTC type and emissions severity\n                DTC emissions severity (in accordance\n                with requirement LLR.PLAT.DTC.MATCHEXISTS.014) and state\n                DTC state.",
    "LLR.PLAT.DTC.MATCHEXISTS.012": "The block  shall  set the outport dtc_match\n                to FALSE if no DTC exists within table DTC table identifier\n                of type DTC type and emissions severity\n                DTC emissions severity (in accordance\n                with requirement LLR.PLAT.DTC.MATCHEXISTS.014) and state DTC state.",
    "LLR.PLAT.DTC.MATCHEXISTS.013": "The block  shall  set the outport dtc_count\n                to the number of DTCs that exist within table DTC table identifier\n                of type DTC type and emissions severity\n                DTC emissions severity (in accordance\n                with requirement LLR.PLAT.DTC.MATCHEXISTS.014) and state DTC state.",
    "LLR.PLAT.DTC.MEMORY.015": "If at start-up the platform determines the retrieved DTC data to\n              be invalid, it  shall  clear all DTC data in NVM.",
    "LLR.PLAT.DTC.MEMORY.001": "When requested (and only when requested) by the application software, the platform  shall  check whether DTCs have\n              been modified since NVM-stored DTC data was last written.  If so, the platform shall\n              store DTC data to NVM.",
    "LLR.PLAT.DTC.MEMORY.004": "The platform shall provide a C interface function named\n                pdtc_commit_to_store() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.DTC.MEMORY.104": "The function pdtc_commit_to_store() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.MEMORY.204": "The function pdtc_commit_to_store() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.DTC.MEMORY.002": "It  shall  be possible to configure the build to use flash storage for non-volatile storage of DTCs.\n              If flash storage is not valid for the target selected, the build shall report an error.",
    "LLR.PLAT.DTC.MEMORY.003": "It  shall  be possible to configure the build to use battery backed RAM storage for non-volatile storage of DTCs.\n              If battery backed RAM storage is not valid for the target selected, the build shall report an error.",
    "LLR.PLAT.DTC.MEMORY.006": "The platform shall provide a Simulink interface block named\n                pdtc_Memory that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_store_up_to_dateInportBoolean\n        \n          Simulation value\n          for the outport store_up_to_date.\n        \n        \n          Range: 0 or 1\n        \n      commit_dtcsInportBoolean\n        \n          Set to 1 to update the\n          check-sum for the DTC tables and to write the result to non-volatile memory.\n          Set to zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      store_up_to_dateOutportBoolean\n        \n          Set to 1 if the\n          check-sum and DTC table data match, set to zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      Storage locationParamList\n        \n          A drop-down\n          of memory storage locations for the DTC table data.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.MEMORY.106": "The block pdtc_Memory shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.MEMORY.206": "The block pdtc_Memory shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.MEMORY.007": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.DTC.MEMORY.008": "If Storage location is not supported for the selected target\n                then the block  shall  raise an error.",
    "LLR.PLAT.DTC.MEMORY.009": "The value of inport sim_store_up_to_date  shall  be written to outport\n                store_up_to_date.",
    "LLR.PLAT.DTC.MEMORY.010": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.MEMORY.013": "The block  shall  update the DTC NVM storage when the inport commit_dtcs is set\n                to 1, otherwise no action is taken.",
    "LLR.PLAT.DTC.MEMORY.014": "The block  shall  update the outport store_up_to_date with\n                the status of DTC NVM storage, reporting a value of true (1) if DTC states are unchanged since the\n                last DTC NVM write, or false (0) if DTC states have changed since then.",
    "LLR.PLAT.DTC.TABLE.001": "The platform  shall  create and use the DTC table(s) specified by the user.",
    "LLR.PLAT.DTC.TABLE.002": "In C, DTC tables  shall  be configured by appropriate definitions of structures\/arrays.\n              Note: \n                The detail of these structures\/arrays is considered to be implementation, and as such should not be specified in requirements.",
    "LLR.PLAT.DTC.TABLE.003": "The platform shall provide a Simulink interface block named\n                pdtc_Table that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionDTC table identifierParamString\n        \n          The name of\n          the DTC table (there must not be another pdtc_Table\n          block with the same identifier in the model).\n        \n      \n                Calibratable: no.\n              DTC table descriptionParamString\n        \n          A textual\n          description of the DTC table used for documentation purposes only.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.TABLE.103": "The block pdtc_Table shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.TABLE.203": "The block pdtc_Table shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.DTC.TABLE.004": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.TABLE.005": "If the mask parameter DTC table identifier\n                is found in another pdtc_Table block then the block  shall  raise an error.",
    "LLR.PLAT.DTC.TABLECLEARED.001": "When requested by the application software, the platform  shall  return the 'DTC table cleared' status.\n                This shall report the clearing of DTC tables in response to ISO-15765 and\/or J1939 requests.\n              Note: \n              This does not require clearing to have been successful, only that a valid request was made. For instance, if a J1939 DM11 request to clear active DTCs\n              is received but no DTCs are currently active in this table, this function will still return that a J1939 DM11 request was received; and if one or more\n              DTCs is configured as \"permanent\" and therefore cannot be cleared by OBD requests, any OBD clear requests will still be reported.",
    "LLR.PLAT.DTC.TABLECLEARED.002": "The platform shall provide a C interface function named\n                pdtc_check_table_cleared() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_table_to_check\n          in\n        const PDTC_TABLE_T *const\nDTC table for which OBD clear request(s) will be reported.\n                The function returns a value of type\n                U32\n                with a value of:\n              Bitmask indicating OBD clear request(s) since last call to this function:Bit 0 = ISO-15765 emissions-related DTCs cleared via $04 (PDTC_OBD_CLEAR_EMISSIONS_RELATED)Bit 1 = ISO-15765 DTCs cleared (regardless of groupOfDTC) via $14 (PDTC_OBD_CLEAR_ALL)Bit 2 = J1939 DTCs in Previously Active state cleared (PDTC_OBD_CLEAR_PREV_ACTIVE)Bit 3 = J1939 DTCs in Active state cleared (PDTC_OBD_CLEAR_ACTIVE)",
    "LLR.PLAT.DTC.TABLECLEARED.102": "The function pdtc_check_table_cleared() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.TABLECLEARED.202": "The function pdtc_check_table_cleared() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.TABLECLEARED.003": "The interface function  shall  return the \"DTC table cleared\" status from the platform.",
    "LLR.PLAT.DTC.TABLECLEARED.004": "The platform shall provide a Simulink interface block named\n                pdtc_TableCleared that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionclearedOutportInteger\n        \n          Indication of whether the table's DTCs have been cleared since the\n          block's previous execution. The value corresponds to which (if any)\n          DTCs have been cleared since the last execution.\n        \n        clearedJ1939 Cleared Active DTCs (DM11)J1939 Cleared Previously Active DTCs (DM3)ISO Cleared All DTCs ($14)ISO Cleared Emissions DTCs ($04)0----1---Y2--Y-3--YY4-Y--5-Y-Y6-YY-7-YYY8Y---9Y--Y10Y-Y-11Y-YY12YY--13YY-Y14YYY-15YYYY\n        \n          Range: [0, 15]\n        \n        Note\n            The KWP\/UDS service $14 value is set regardless of the groupOfDTC parameter requested,\n            even if that means only a subset of DTCs were actually cleared.\n          \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to monitor (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution. The sample time must be set\n          explicitly - the block cannot be set to inherit a sample time from\n          its parent. As the block's outport value is valid only until its next\n          execution, the sample time should be sufficient for the value to be\n          processed before this occurs.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.TABLECLEARED.104": "The block pdtc_TableCleared shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.TABLECLEARED.204": "The block pdtc_TableCleared shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.TABLECLEARED.005": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.DTC.TABLECLEARED.006": "If the mask parameter DTC table identifier\n                is empty then the block  shall  raise an error.",
    "LLR.PLAT.DTC.TABLECLEARED.007": "If the mask parameter DTC table identifier\n                is not found in a pdtc_Table block then the block  shall  raise an error.",
    "LLR.PLAT.DTC.TABLECLEARED.008": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.DTC.TABLECLEARED.009": "The block  shall  update the outport cleared with the status of \"DTC table cleared\".",
    "LLR.PLAT.DTC.LAMP.001": "When a DTC is controlled by the legacy J1939 DTC interface (see LLR.PLAT.DTC.DTC.054 and LLR.PLAT.DTC.DTC.065),\n              lamp states for each lamp for the DTC  shall  be controlled directly by the application.",
    "LLR.PLAT.DTC.LAMP.002": "When lamp state for a DTC is controlled by the platform (see LLR.PLAT.DTC.DTC.007) or by the legacy ISO-15765 DTC\n              interface (see LLR.PLAT.DTC.DTC.061), and the DTC is in state 'Active',\n              lamp states for each lamp for the DTC  shall  be controlled by the DTC calibration.",
    "LLR.PLAT.DTC.LAMP.003": "When multiple DTCs are active and commanding different lamp states, the platform  shall  select the highest priority state for\n              each lamp. Priorities (in order) shall be:-\n            \n              * Continuously ON (highest)\n            \n              * Fast flash\n            \n              * Slow flash\n            \n              * Unavailable\/off (lowest)\n            Note: \n              CARB is not aware of a flashing state for the MIL, and requires emissions-related faults to set the MIL to continuous ON.\n              Manufacturer-specific behaviour of the MIL (i.e. flashing) is not strictly compliant with CARB.  Other OBD schemes do allow MIL\n              flashing, but we are not committed to meeting them.",
    "LLR.PLAT.DTC.LAMP.004": "The platform  shall  provide a mechanism for the application to select the lamp state priority scheme below, using the calibration\n              pdtc_lamp_flashing_is_priority:-\n            \n              * Fast flash (highest)\n            \n              * Slow flash\n            \n              * Continuously ON\n            \n              * Unavailable\/off (lowest)\n            Note: \n              The source of this was from a meeting with Tenneco on 21 April 2011, attended by D Price and A Farrell.\n              Meeting minutes contained in email from Thomas Stephens at Tenneco to D Price, sent on 26 April 2011.",
    "LLR.PLAT.DTC.LAMP.023": "The platform  shall  enable periodic lamp updates at application initialization after\n              reset.\n            Note: \n              This ensures backwards compatibility for applications that assumed this function\n              was always present.",
    "LLR.PLAT.DTC.LAMP.005": "The platform  shall  update the desired state of each lamp based on DTCs\n              during each iteration of the PDTC task in which periodic lamp updates were enabled\n              at the initiation of that task.",
    "LLR.PLAT.DTC.LAMP.020": "The platform shall provide a C interface function named\n                pdtc_get_lamp_state() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_dtc_table\n          in\n        const PDTC_TABLE_T *const\nTable of DTCs for which lamp status is to be reportedpdtcf_lamp\n          in\n        const PDTC_LAMP_T\nLamp for which status is to be reported\n                The function returns a value of type\n                PIO_DTC_LAMP_STATES_T\n                with a value of:\n              PIO_DTC_LAMP_SLOW_FLASH - Slow flash (1Hz, 50% duty cycle)PIO_DTC_LAMP_FAST_FLASH - Fast flash (2Hz or faster, 50% duty cycle)PIO_DTC_LAMP_ON - Continuously ONPIO_DTC_LAMP_OFF - Continuously OFF",
    "LLR.PLAT.DTC.LAMP.120": "The function pdtc_get_lamp_state() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.LAMP.220": "The function pdtc_get_lamp_state() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.024": "The platform shall provide a C interface function named\n                pdtc_enable_periodic_lamp_updates() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdtcf_en\n          in\n        BOOL\nFlag indicating if periodic updates should be enabled (TRUE) or disabled (FALSE).\n\n                The function returns void.",
    "LLR.PLAT.DTC.LAMP.025": "The platform  shall  enable periodic lamp updates if pdtcf_en\n              is not FALSE.\n            Note: \n              Backward compatible operation is to always have periodic updates enabled, so this\n              function only disables the operation with the single specific value that means\n              \"disable\".",
    "LLR.PLAT.DTC.LAMP.026": "The platform  shall  disable periodic lamp updates if pdtcf_en\n              is FALSE.\n            Note: \n              Backward compatible operation is to always have periodic updates enabled, so this\n              function only disables the operation with the single specific value that means\n              \"disable\".",
    "LLR.PLAT.DTC.LAMP.021": "The platform shall provide a C interface function named\n                pdtc_get_MIL_status() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PIO_DTC_LAMP_STATES_T\n                with a value of:\n              PIO_DTC_LAMP_SLOW_FLASH - Slow flash (1Hz, 50% duty cycle)PIO_DTC_LAMP_FAST_FLASH - Fast flash (2Hz or faster, 50% duty cycle)PIO_DTC_LAMP_ON - Continuously ONPIO_DTC_LAMP_OFF - Continuously OFF",
    "LLR.PLAT.DTC.LAMP.121": "The function pdtc_get_MIL_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.LAMP.221": "The function pdtc_get_MIL_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.011": "The platform shall provide a C interface function named\n                pdtc_get_RSL_status() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PIO_DTC_LAMP_STATES_T\n                with a value of:\n              PIO_DTC_LAMP_SLOW_FLASH - Slow flash (1Hz, 50% duty cycle)PIO_DTC_LAMP_FAST_FLASH - Fast flash (2Hz or faster, 50% duty cycle)PIO_DTC_LAMP_ON - Continuously ONPIO_DTC_LAMP_OFF - Continuously OFF",
    "LLR.PLAT.DTC.LAMP.111": "The function pdtc_get_RSL_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.LAMP.211": "The function pdtc_get_RSL_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.012": "The platform shall provide a C interface function named\n                pdtc_get_AWL_status() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PIO_DTC_LAMP_STATES_T\n                with a value of:\n              PIO_DTC_LAMP_SLOW_FLASH - Slow flash (1Hz, 50% duty cycle)PIO_DTC_LAMP_FAST_FLASH - Fast flash (2Hz or faster, 50% duty cycle)PIO_DTC_LAMP_ON - Continuously ONPIO_DTC_LAMP_OFF - Continuously OFF",
    "LLR.PLAT.DTC.LAMP.112": "The function pdtc_get_AWL_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.LAMP.212": "The function pdtc_get_AWL_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.013": "The platform shall provide a C interface function named\n                pdtc_get_Protect_lamp_status() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PIO_DTC_LAMP_STATES_T\n                with a value of:\n              PIO_DTC_LAMP_SLOW_FLASH - Slow flash (1Hz, 50% duty cycle)PIO_DTC_LAMP_FAST_FLASH - Fast flash (2Hz or faster, 50% duty cycle)PIO_DTC_LAMP_ON - Continuously ONPIO_DTC_LAMP_OFF - Continuously OFF",
    "LLR.PLAT.DTC.LAMP.113": "The function pdtc_get_Protect_lamp_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.DTC.LAMP.213": "The function pdtc_get_Protect_lamp_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.027": "The platform shall provide a Simulink interface block named\n                pdtc_EnablePeriodicLampUpdates that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionenableInportBoolean\n        \n          Set to 0 to disable periodic lamp updates, 1 to re-enable them. Note: Changing the value to\n          0 while the lamps are currently being processed will not interrupt that processing, but take\n          effect at the next iteration of the DTC processing task.\n        \n        \n          Range: 0 or 1",
    "LLR.PLAT.DTC.LAMP.028": "When executed, the pdtc_EnablePeriodicLampUpdates block  shall  enable\n                periodic lamp processing if the enable inport is nonzero.",
    "LLR.PLAT.DTC.LAMP.029": "When executed, the pdtc_EnablePeriodicLampUpdates block  shall  disable\n                periodic lamp processing if the enable inport is zero.",
    "LLR.PLAT.DTC.LAMP.014": "The platform shall provide a Simulink interface block named\n                pdtc_Status that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionmil_statusOutportInteger\n        \n          Indicates the state of the Malfunction Indicator Lamp, taking into\n          consideration the states of all DTCs in the system.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      rsl_statusOutportInteger\n        \n          Indicates the state of the Red Stop Lamp, taking into\n          consideration the states of all DTCs in the system.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      awl_statusOutportInteger\n        \n          Indicates the state of the Amber Warning Lamp, taking into\n          consideration the states of all DTCs in the system.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      pl_statusOutportInteger\n        \n          Indicates the state of the Protection Lamp, taking into\n          consideration the states of all DTCs in the system.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      mi_actv_modeOutportInteger\n        \n          The MI Activation Mode as defined by EuroVI in\n          UN_ECE Regulation 49 Addendum 48 Rev 4.\n          (This outport is only shown if the \"Show EuroVI outputs?\" option is checked.)\n        \n        \n          Range: [0, 3] (0 is mode 1\/no fault, 1 is mode 2\/class C, 2 is mode 3\/class B1 < 200hr, 3 is mode 4\/class A or B1 > 200hr)\n        \n      mil_cumulativeOutportInteger\n        \n          The total time for which the MIL has been active with the engine running.\n          (This outport is only shown if the \"Show EuroVI outputs?\" option is checked.)\n        \n        \n          Range: [0, 4294967295] seconds\n        \n      b1_cumulativeOutportInteger\n        \n          The total time for which any B1 severity DTC has been active with the engine running.\n          This corresponds to the \"System Greatest B1 Counter\" in SAE J1939-73 DM39.\n          (This outport is only shown if the \"Show EuroVI outputs?\" option is checked.)\n        \n        \n          Range: [0, 4294967295] seconds\n        \n      b1_continuousOutportInteger\n        \n          The current time for which any B1 severity DTC has been active with the engine running.\n          This counter is reset if no B1 fault is active for three engine cycles.\n          This corresponds to the \"Single B1 Counter\" in UN_ECE Regulation 49 Addendum 48 Rev 4.\n          (This outport is only shown if the \"Show EuroVI outputs?\" option is checked.)\n        \n        \n          Range: [0, 4294967295] seconds\n        \n      Show EuroVI outputs?ParamBoolean\n        \n          Whether to set additional outports to EuroVI-related values concerning\n          MIL activation and MIL\/B1 time counters.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution in seconds.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.DTC.LAMP.114": "The block pdtc_Status shall support the targets:\n            All targets.",
    "LLR.PLAT.DTC.LAMP.214": "The block pdtc_Status shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.DTC.LAMP.015": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.DTC.LAMP.016": "The block  shall  update the outport mil_status with the MIL status obtained from the platform.",
    "LLR.PLAT.DTC.LAMP.017": "The block  shall  update the outport rsl_status with the RSL status obtained from the platform.",
    "LLR.PLAT.DTC.LAMP.018": "The block  shall  update the outport awl_status with the AWL status obtained from the platform.",
    "LLR.PLAT.DTC.LAMP.019": "The block  shall  update the outport pl_status with the protection lamp status obtained\n                from the platform.",
    "LLR.APP.PDX.DIN.001": "The application  will  invoke once an interface during application initialisation to\n              declare logical digital input channels that will be read during run time.",
    "LLR.PLAT.PDX.DIN.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to read logical digital input channels declared by the\n              application.",
    "LLR.PLAT.PDX.DIN.007": "During application run time, the platform  shall  read the digital input channels and make their states available to the application upon request.",
    "LLR.PLAT.PDX.DIN.002": "The platform shall provide a C interface function named\n                pdx_digital_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a digital input. Use the macros included by the pio.h file, of the form PIO_DIN_[NAME].pdxf_state\n          out\n        U8 *\nThe state of the digital input is written through this pointer. Consider hardware effects such as inversion, etc.. \n Cannot be NULL. \n Range: 0 or 1pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - if successful actionPDX_RC_SW_ERROR - if channel not supportedPDX_RC_HW_ERROR - if error initialising channelPDX_RC_BAD_ARGS - if configuration errorPDX_RC_SDM_ALLOC_ERROR - if error allocating RAM for SDM",
    "LLR.PLAT.PDX.DIN.102": "The function pdx_digital_input() shall support the targets:\n                      CMM-000, CMM-000, M110-000, M110-000, M220-000, M220-000, M221-000, M221-000, M250-000, M250-000, M460-000, M460-000, M461-000, M461-000, M550-000, M550-000, M670-000 and M670-000.",
    "LLR.PLAT.PDX.DIN.202": "The function pdx_digital_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.DIN.004": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware input by returning PDX_RC_BAD_ARGS.\n              Note: \n                A \u201cpotential hardware input\u201d as something the processor can read, a\n                physical quantity, in any variant of the hardware.",
    "LLR.PLAT.PDX.DIN.005": "During application run time, the function  shall  return PDX_RC_BAD_ARGS when pdxf_state\n                is NULL.",
    "LLR.PLAT.PDX.DIN.006": "If the interface checks pass then the function  shall  write the acquired\n                digital state value (0 for logic low, 1 for logic high) for the logical channel through\n                pdxf_state.\n              Note: \n                If the logical channel number does not match a physically connected channel, then the\n                acquired value is undefined.\n              Note: \n                The C interface does not account for any input signal conditioning circuits that may\n                effectively result in an inversion between the ECU and CPU pins. Therefore it is up to\n                the application code to get the high\/low sense right for the particular ECU and\n                application.",
    "LLR.PLAT.PDX.DIN.008": "The platform shall provide a Simulink interface block named\n                pdx_DigitalInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_stateInportBoolean\n        \n          Only used in simulation. when\n          the model is simulated, the outport debounced_state is set to the\n          value of this inport.\n        \n        \n          Range: 0 or 1\n        \n      debounced_stateOutportBoolean\n        \n          1 if the raw\n          input digital value has been high for at least Set dead time, 0 if\n          the raw input digital value has been low for at least\n          Reset dead time.\n        \n        \n          Range: 0 or 1\n        \n      ChannelParamList\n        \n          The channel pin for this digital input.\n        \n      \n                Calibratable: no.\n              InversionParamBoolean\n        \n          If inversion is ticked then a\n          logical NOT operation is applied to the input value before further processing.\n        \n      \n                Calibratable: no.\n              Set dead timeParamReal\n        \n          The time the input will\n          have to be high, before the block switches its output from 0 to 1. A value of\n          zero is acceptable. A negative value has the same effect as a zero value.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Reset dead timeParamReal\n        \n          The reset dead time is\n          the time the input will have to be low, before the block switches its output\n          from 1 to 0. A value of zero is acceptable. A negative value has the same effect\n          as a zero value.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          Tick to enable inport sim_state.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.DIN.108": "The block pdx_DigitalInput shall support the targets:\n            CMM-000, CMM-000, M110-000, M110-000, M220-000, M220-000, M221-000, M221-000, M250-000, M250-000, M460-000, M460-000, M461-000, M461-000, M550-000, M550-000, M670-000 and M670-000.",
    "LLR.PLAT.PDX.DIN.208": "The block pdx_DigitalInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.DIN.009": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DIN.010": "If the parameter Set dead time is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DIN.011": "If the parameter Reset dead time is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DIN.012": "If the same parameter for the mask Channel is used\n                in another block within the model, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DIN.013": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DIN.014": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDX.DIN.015": "If parameter Provide simulation input?\n                is true then the sim_state inport  shall  be available on the block\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PDX.DIN.016": "The block  shall  update the outport debounced_state\n                with the debounced logical state of the inport sim_state.",
    "LLR.PLAT.PDX.DIN.017": "The block  shall  debounce the inport sim_state\n                using the mask parameters , Sample time,\n                Set dead time and\n                Reset dead time for the debouncing parameters sample rate,\n                set dead time and reset dead time respectively.",
    "LLR.PLAT.PDX.DIN.018": "If the inversion tick-box is selected, the block  shall  invert the inport\n                sim_state before processing it further.",
    "LLR.PLAT.PDX.DIN.019": "The block  shall  initialise the channel defined by the mask  Channel.",
    "LLR.PLAT.PDX.DIN.023": "The block  shall  initialise the debounce functionality using the mask parameters,\n                Sample time,\n                Set dead time and\n                Reset dead time for the debouncing parameters\n                sample rate, set dead time and reset dead time respectively.",
    "LLR.PLAT.PDX.DIN.020": "The block  shall  read the input state of the channel defined by the mask parameter, Channel.",
    "LLR.PLAT.PDX.DIN.021": "The block  shall  debounce the digital input state of the channel defined by the mask Channel,\n                 using the mask parameters, Sample time,\n                Set dead time and\n                Reset dead time\n                for the debouncing parameters sample rate, set dead time and reset dead time respectively.",
    "LLR.PLAT.PDX.DIN.022": "The block  shall  update the outport debounced_state\n                with the debounced logical state\n                of the input channel defined by the mask Channel.",
    "LLR.APP.PDX.DOUT.001": "The application  will  invoke an interface during application initialisation to declare\n              logical digital output channels that will be set during run time.",
    "LLR.PLAT.PDX.DOUT.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to set logical digital output channels declared by the\n              application.\n            Note: \n              Currently, there are no requirements for the platform to recognise duplicated channels\n              declared by the application (this may change in the future if we can find an efficient way\n              to implement such a requirement). If the application declares a logical channel more than\n              once then the behaviour of the platform is undefined.",
    "LLR.PLAT.PDX.DOUT.002": "The initialisation process  shall  set the digital output channel to the given state.",
    "LLR.PLAT.PDX.DOUT.007": "During application run time, the platform  shall  drive the digital output channels to logical levels\n              specified by the application.",
    "LLR.PLAT.PDX.DOUT.003": "The platform shall provide a C interface function named\n                pdx_digital_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a digital output. Use the macros included by the pio.h file, of the form PIO_DOT_[NAME].pdxf_state\n          in\n        U8\nThe state to which the digital output should be driven. A state of 0 means the output is inactive, where 1 means active (non-inverted). For low-side outputs, active means pulled to ground; high-side, pulled to supply voltage. The inactive state is high impedence. \n Consider hardware effects such as inversion, low-side\/high-side driven, etc.. \n Range: 0 or 1pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_HW_ERROR - if error initialising channelPDX_RC_BAD_ARGS - configuration errorPDX_RC_SDM_ALLOC_ERROR - error allocating ram in SDM",
    "LLR.PLAT.PDX.DOUT.103": "The function pdx_digital_output() shall support the targets:\n                      CMM-000, CMM-000, M110-000, M110-000, M220-000, M220-000, M221-000, M221-000, M250-000, M250-000, M460-000, M460-000, M461-000, M461-000, M550-000, M550-000, M670-000 and M670-000.",
    "LLR.PLAT.PDX.DOUT.203": "The function pdx_digital_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.DOUT.005": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PDX_RC_BAD_ARGS.",
    "LLR.PLAT.PDX.DOUT.006": "If the interface checks pass then the function  shall  set the CPU pin to a\n                logic low if pdxf_state is set to 0, a logic high if set to 1 and an undefined state in\n                all other cases.",
    "LLR.PLAT.PDX.DOUT.008": "The platform shall provide a Simulink interface block named\n                pdx_DigitalOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionstateInportBoolean\n        \n          Place a 1 here to set the output\n          channel pin high, place a 0 here to set the output channel pin low.\n        \n        \n          Range: 0 or 1\n        \n      faultInportBoolean\n        \n          Place a 1 here to force the block\n          to use the default value for the channel pin state, otherwise place a 0 here to\n          force the block to use the inport state as the channel pin state.\n        \n        \n          Range: 0 or 1\n        \n      sim_stateOutportBoolean\n        \n          Only used in simulation. this\n          outport is set to the requested channel pin state (i.e., state or\n          the default state).\n        \n        \n          Range: 0 or 1\n        \n      ChannelParamList\n        \n          The channel pin for this digital output.\n        \n      \n                Calibratable: no.\n              InversionParamBoolean\n        \n          Inverts the mapping of the\n          input value to the channel pin. If inversion is set to 1 then a logical NOT\n          operation is applied to the input value before further processing.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Default stateParamBoolean\n        \n          This sets the output to\n          the default state in two situations: at start-up time, before this block has been\n          executed in the first model iteration; and if a fault indicator is associated\n          with the output and the fault is active. The value is mapped directly to the\n          channel pin logical state and is never inverted.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation output?ParamBoolean\n        \n          Tick to enable outport sim_state.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.DOUT.108": "The block pdx_DigitalOutput shall support the targets:\n            CMM-000, CMM-000, M110-000, M110-000, M220-000, M220-000, M221-000, M221-000, M250-000, M250-000, M460-000, M460-000, M461-000, M461-000, M550-000, M550-000, M670-000 and M670-000.",
    "LLR.PLAT.PDX.DOUT.208": "The block pdx_DigitalOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.DOUT.009": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DOUT.010": "If the parameter Default state is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DOUT.011": "If the parameter Channel is found in any other\n                block in the model then the block  shall  raise an error.",
    "LLR.PLAT.PDX.DOUT.012": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PDX.DOUT.013": "If parameter Provide simulation output?\n                is true then the sim_state outport  shall  be available on the block.",
    "LLR.PLAT.PDX.DOUT.024": "The block  shall  process state based on the parameters\n                Inversion,\n                Default state and the inport\n                fault to specify the signal inversion, default and fault states\n                respectively and the result  shall  be used to drive the outport\n                sim_state.",
    "LLR.PLAT.PDX.DOUT.014": "The block  shall  set the outport sim_state to the processed state\n                of th the inport state.",
    "LLR.PLAT.PDX.DOUT.016": "The block  shall  initialise the channel defined by the mask Channel\n                to the default state defined by Default state.",
    "LLR.PLAT.PDX.DOUT.021": "The block  shall  process state based on the parameters\n                Inversion,\n                Default state and the inport\n                fault and the result  shall  be used to drive the digital output channel\n                specified by Channel.",
    "LLR.PLAT.PDX.DOUT.022": "The block  shall  set the digital output channel specified by\n                Channel to the processed state of the inport\n                state.",
    "LLR.APP.PDX.FREQIN.001": "The application  will  invoke an interface during application initialisation to declare\n              logical frequency input channels that will be read during run time.",
    "LLR.PLAT.PDX.FREQIN.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to read logical frequency input channels declared by the application.",
    "LLR.PLAT.PDX.FREQIN.002": "During application run time, the platform  shall  continually update the period\n              counters depending on the state of the frequency input channel, and make the frequency\n              information available to the application upon request.",
    "LLR.PLAT.PDX.FREQIN.003": "The platform  shall  set a flag when the length of time between edges is longer than an application\n              supplied timeout period, and clear the flag when it is not.",
    "LLR.PLAT.PDX.FREQIN.004": "The platform  shall  measure the frequency and make this value available to the application as the\n              a value from the last measured period, or zero if no measurement has been taken.",
    "LLR.PLAT.PDX.FREQIN.005": "The platform shall provide a C interface function named\n                pdx_frequency_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a frequency input. Use the macros included by the pio.h file, of the form PIO_FIN_[NAME].pdxf_config\n          in\n        U16\nA configuration parameter used to initialise certain channels on some ECUs, use PIO_CONFIG_FIN.pdxf_count\n          in\n        U8\nA configuration parameter used to initialise certain channels on some ECUs, use PIO_COUNT_FIN.pdxf_freq\n          out\n        F32 *\nThe measured frequency is written through this pointer. If the input signal has timed out, the last measured input frequency (or zero if none has been measured) is written. \n The range of the frequency is limited in various ways.The range of the frequency that can be measured is limited by the filter circuitry of the input pin.The lowest measurable frequency is limited by the filter circuitry and the size of the corresponding processor timer for a channel. Any input frequency below the documented limit, is reported as timed-out.The highest measurable frequency is limited by the filter circuitry and the resolution of the corresponding processor timer for a channel. In general, the block reports the frequency of the filtered signal and the input filtering forms an upper limit. However, as the frequency increases, the resolution of measurement decreases. Details of the input pin's filtering and processor timing can be found in an ECU's technical specification.\n Cannot be NULL. \n Range: [0.5, ...] Hz\npdxf_last_edges\n          in\n        U16\nA count of edges seen by the frequency input function last time this function was called (or zero if this is the first time the function has been called). The counter wraps modulo 65536 and is used to determine whether the signal has timed out or not. \n Range: [0, 65535] edgespdxf_this_edges\n          out\n        U16 *\nThe count of edges seen by the frequency input function this time is written through this pointer. It is the value to be passed as pdxf_last_edges next time the function is called. \n Cannot be NULL. \n Range: [0, 65535] edgespdxf_last_time\n          in\n        U32\nThe time of the last call to this frequency input function (or zero if it is the first call). It is used to determine whether the signal has timed out or not. \n Range: [0, 4294967295] microsecondspdxf_this_time\n          out\n        U32 *\nThe time of this call is written through this pointer. It is the value to be passed as pdxf_last_time next time the function is called. \n Cannot be NULL. \n Range: [0, 4294967295] microsecondspdxf_timeout\n          in\n        U32\nThe duration of the input signal timeout period. \n Range: [100, 2000000] microsecondspdxf_timed_out\n          out\n        BOOL *\nSet if the input signal has timed out at the point of calling. If between calls, the input signal timed out and then re-established itself, the time out event is not registered. \n Cannot be NULL. \n Range: 0 or 1pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_HW_ERROR - if error initialising channelPDX_RC_BAD_ARGS - configuration errorPDX_RC_SDM_ALLOC_ERROR - error allocating ram in SDM",
    "LLR.PLAT.PDX.FREQIN.105": "The function pdx_frequency_input() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.FREQIN.205": "The function pdx_frequency_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.FREQIN.006": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PDX_RC_BAD_ARGS and also setting the recoverable\n                error PSY_PDX\/PDX_CHANNEL_INVALID.\n              Note: \n                A potential hardware input as something the processor can read, a physical quantity, in\n                any variant of the hardware.",
    "LLR.PLAT.PDX.FREQIN.007": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_freq is\n                NULL.",
    "LLR.PLAT.PDX.FREQIN.008": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_this_time is\n                NULL.",
    "LLR.PLAT.PDX.FREQIN.009": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_this_edges is\n                NULL.",
    "LLR.PLAT.PDX.FREQIN.010": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_timed_out is\n                NULL.",
    "LLR.PLAT.PDX.FREQIN.011": "If the interface checks pass, then the function  shall  write the captured\n                frequency value for the logical channel through pdxf_freq.",
    "LLR.PLAT.PDX.FREQIN.012": "If the interface checks pass, then the function  shall  write the time that this\n                function was called to read the logical channel through pdxf_this_time.",
    "LLR.PLAT.PDX.FREQIN.013": "If the interface checks pass, then the function  shall  write the value indicating\n                if the input signal for the logical channel has timed out at the point of\n                calling, through pdxf_timed_out.",
    "LLR.PLAT.PDX.FREQIN.014": "If a timeout has occurred at the point of calling, the function  shall  set\n                pdxf_freq to the frequency of the last measured period, or zero if a\n                measurement has not yet taken place.",
    "LLR.PLAT.PDX.FREQIN.015": "The platform shall provide a Simulink interface block named\n                pdx_FrequencyInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_timed_outInportBoolean\n        \n          Only used in\n          simulation. Place 1 here to simulate a time out, 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      sim_frequencyInportReal\n        \n          Only used in simulation. Place the frequency in hertz here to simulate the last measured\n          frequency. A measurement of zero hertz indicates that no measurement is available.\n        \n      timed_outOutportBoolean\n        \n          1 if the input signal has not completed a pulse within the mask parameter timeout period\n          at the point of sampling (see the mask parameter section below), 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      frequencyOutportReal\n        \n          The last measured frequency in hertz, or 0 if no measurement has been taken (regardless of\n          the state of outport timed_out). The range of the frequency is limited\n          in various ways.\n        \n        \n              The range of the frequency that can be measured is limited by the filter circuitry of\n              the input pin.\n            \n              The lowest measurable frequency is limited by the filter circuitry and the size of the\n              corresponding processor timer for a channel. Any input frequency below the documented\n              limit, is reported as timed-out.\n            \n              The highest measurable frequency is limited by the filter circuitry and the resolution\n              of the corresponding processor timer for a channel. In general, the block reports\n              the frequency of the filtered signal and the input filtering forms an upper limit.\n              However, as the frequency increases, the resolution of measurement decreases.\n            \n        \n          Details of the input pin's filtering and processor timing can be found in an ECU's\n          technical specification.\n        \n        \n          Range: [0.5,  ...] Hz (for all targets)\n        \n      ChannelParamList\n        \n          The input pin sourcing the signal to measure.\n        \n      \n                Calibratable: no.\n              Time outParamReal\n        \n          The period of time in hertz\n          after which if no complete pulse has  been measured, the outport\n          timed_out is set to 1.\n        \n        \n          Range: [0.5, 10000] Hz (for all targets)\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          If selected then create simulation inports for each of the outport\n          message signals.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.FREQIN.115": "The block pdx_FrequencyInput shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.FREQIN.215": "The block pdx_FrequencyInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.FREQIN.016": "Target type is checked by the interface, if\n                it is unsupported then the interface  shall  raise an error.",
    "LLR.PLAT.PDX.FREQIN.017": "Time out(Hz) is checked by the interface,\n                if it is not present or out of range then the interface  shall \n                raise an error.",
    "LLR.PLAT.PDX.FREQIN.018": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDX.FREQIN.019": "An option  shall  be available to provide a simulation input that\n                will appear on the block.",
    "LLR.PLAT.PDX.FREQIN.020": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                timed_out to that of its inport\n                sim_timed_out.",
    "LLR.PLAT.PDX.FREQIN.021": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                frequency to that of its inport\n                sim_frequency.",
    "LLR.PLAT.PDX.FREQIN.022": "The block  shall  write the timed out flag for the logical Channel\n                to the outport timed_out",
    "LLR.PLAT.PDX.FREQIN.023": "The block  shall  write the captured frequency value for the logical Channel\n                to the outport frequency",
    "LLR.APP.PDX.PWMIN.001": "The application  will  invoke an interface during application initialisation to declare\n              logical PWM input channels that will be read during run time.",
    "LLR.PLAT.PDX.PWMIN.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to read logical PWM input channels declared by the application.",
    "LLR.PLAT.PDX.PWMIN.002": "During application run time, the platform  shall  continually update the high\/low period\n              counters depending on the state of the PWM input channel, and make the information\n              available to the application upon request.",
    "LLR.PLAT.PDX.PWMIN.049": "The platform  shall  set a flag when the length of time between edges is longer than an application\n              supplied timeout period, and clear the flag when it is not.",
    "LLR.PLAT.PDX.PWMIN.050": "The platform  shall  count the number of timeouts and make this count available to the application\n              wrapped modulo 16777216, with a range: [0, 16777215].",
    "LLR.PLAT.PDX.PWMIN.051": "The platform  shall  measure the duty cycle and make this value available to the application as\n              the ratio of the first pulse duration to the period, or zero if no measurement has been taken,\n              with a range: [0, 1]",
    "LLR.PLAT.PDX.PWMIN.052": "The platform  shall  measure the frequency and make this value available to the application as the\n              a value from the last measured period, or zero if no measurement has been taken,\n               with a range: [0.5, 10000] Hz",
    "LLR.PLAT.PDX.PWMIN.053": "The platform  shall  measure the duration of the first pulse and make this value available to the application as\n              a value from the last measured period, or zero if no measurement has been taken,\n              with a range: [0, 2000000] microseconds",
    "LLR.PLAT.PDX.PWMIN.054": "The platform  shall  measure the duration of the second pulse and make this value available to the application as\n              a value from the last measured period, or zero if no measurement has been taken,\n              with a range: [0, 2000000] microseconds",
    "LLR.PLAT.PDX.PWMIN.055": "The platform  shall  make a count of the periods and make this available to the application,\n              wrapped modulo 16777216, with a range: [0, 16777215]",
    "LLR.PLAT.PDX.PWMIN.056": "The platform  shall  measure the state of the pin and make this available to the application,\n                with a range: [0, 1]",
    "LLR.PLAT.PDX.PWMIN.003": "The platform shall provide a C interface function named\n                pdx_pwm_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a PWM input. Use the macros included by the pio.h file, of the form PIO_PWIN_[NAME].pdxf_invert\n          in\n        U8\nSet to 0 to start measuring PWM input signal on a rising edge (first pulse is high), set to 1 to start measuring PWM input signal on a falling edge (first pulse is low). \n Parameter valid only during initialisation. \n Range: 0 or 1pdxf_freq\n          out\n        F32 *\nThe frequency of the last measured period. If a timeout has occurred, this remains as the frequency of the last measured period (or zero if a measurement has not yet been taken). \n The range of the frequency is limited in various ways.The range of the frequency that can be measured is limited by the filter circuitry of the input pin.The lowest measurable frequency is limited by the filter circuitry and the size of the corresponding processor timer for a channel. Any input frequency below the documented limit, is reported as timed-out.The highest measurable frequency is limited by the filter circuitry and the resolution of the corresponding processor timer for a channel. In general, the block reports the frequency of the filtered signal and the input filtering forms an upper limit. However, as the frequency increases, the resolution of measurement decreases. Details of the input pin's filtering and processor timing can be found in an ECU's technical specification.\n Cannot be NULL. \n Range: 0 Hz and [0.5, ...] Hz (minimum)\npdxf_dc\n          out\n        F32 *\nThe duty cycle of the last measured period. If a timeout has occurred, this remains as the duty cycle of the last measured period (or zero if a measurement has not yet been taken). \n Cannot be NULL. \n Range: [0, 1]pdxf_first_duration\n          out\n        U32 *\nThe duration of the first pulse in the last measured period (either high or low). If a timeout has occurred, this remains as the last measured first pulse duration (or zero if a measurement has not yet been taken). \n Cannot be NULL. \n Range: [0, 4294967296] microsecondspdxf_second_duration\n          out\n        U32 *\nThe duration of the second pulse in the last measured period (inverse of first pulse). If a timeout has occurred, this remains as the last measured second pulse duration (or zero if a measurement has not yet been taken). \n Cannot be NULL. \n Range: [0, 4294967296] microsecondspdxf_period_count\n          out\n        U32 *\nA count of periods seen by the PWM input function. The counter wraps modulo 16777216.\n Cannot be NULL. \n Range: [0, 16777216] periodspdxf_timeout\n          in\n        U32\nThe duration of the PWM input signal timeout period. \n Parameter valid only during initialisation. \n Range: [100, 2000000] microsecondspdxf_timeout_count\n          out\n        U32 *\nA count of instances where the input signal has timed out. The counter wraps modulo 16777216.\n Cannot be NULL. \n Range: [0, 16777216] timeoutspdxf_timed_out\n          out\n        BOOL *\nSet if the input signal has timed out at the point of calling. If between calls, the input signal timed out and then re-established itself, the time out event is counted in pdxf_timeout_count. \n Cannot be NULL. \n Range: 0 or 1pdxf_pin_state\n          out\n        BOOL *\nSet if the input signal is high, clear if the input signal is low. Cannot be NULL. \n Range: 0 or 1pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_BAD_ARGS - configuration errorPDX_RC_SDM_ALLOC_ERROR - error allocating ram in SDMPDX_RC_INACTIVE - channel inactive",
    "LLR.PLAT.PDX.PWMIN.103": "The function pdx_pwm_input() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.PWMIN.203": "The function pdx_pwm_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.PWMIN.005": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PDX_RC_BAD_ARGS.\n              Note: \n                A potential hardware input as something the processor can read, a physical quantity, in\n                any variant of the hardware.",
    "LLR.PLAT.PDX.PWMIN.006": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_freq is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.007": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_dc is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.008": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_first_duration is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.009": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_second_duration is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.010": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_period_count is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.011": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_timeout_count is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.012": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_timed_out is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.013": "During application run time, the function  shall  return\n                PDX_RC_BAD_ARGS when pdxf_pin_state is\n                NULL.",
    "LLR.PLAT.PDX.PWMIN.014": "If the interface checks pass, then the function  shall  write the captured\n                frequency value for the logical channel through pdxf_freq.",
    "LLR.PLAT.PDX.PWMIN.015": "If the interface checks pass, then the function  shall  write the captured duty\n                cycle value for the logical channel through pdxf_dc.",
    "LLR.PLAT.PDX.PWMIN.016": "If the interface checks pass, then the function  shall  write the duration of\n                the first pulse for the logical channel through pdxf_first_duration.",
    "LLR.PLAT.PDX.PWMIN.017": "If the interface checks pass, then the function  shall  write the duration of\n                the second pulse for the logical channel through\n                pdxf_second_duration.",
    "LLR.PLAT.PDX.PWMIN.018": "If the interface checks pass, then the function  shall  write the number of\n                captured periods for the logical channel through pdxf_period_count.",
    "LLR.PLAT.PDX.PWMIN.019": "If the interface checks pass, then the function  shall  write the number of\n                instances the input signal for the logical channel has timed out through\n                pdxf_timeout_count.",
    "LLR.PLAT.PDX.PWMIN.020": "If the interface checks pass, then the function  shall  write the value\n                indicating if the input signal for the logical channel has timed out at the point of\n                calling, through pdxf_timed_out.",
    "LLR.PLAT.PDX.PWMIN.021": "If the interface checks pass, then the function  shall  write the input signal\n                state for the logical channel at the point of calling through\n                pdxf_pin_state.",
    "LLR.PLAT.PDX.PWMIN.022": "If a timeout has occurred at the point of calling, the function  shall  set\n                pdxf_freq to the frequency of the last measured period, or zero if a\n                measurement has not yet taken place.",
    "LLR.PLAT.PDX.PWMIN.023": "If a timeout has occurred at the point of calling, the function  shall  set\n                pdxf_dc to the duty cycle of the last measured period, or zero if a\n                measurement has not yet taken place.",
    "LLR.PLAT.PDX.PWMIN.024": "If a timeout has occurred at the point of calling, the function  shall  set\n                pdxf_first_duration to the last measured first pulse duration, or\n                zero if a measurement has not yet taken place.",
    "LLR.PLAT.PDX.PWMIN.025": "If a timeout has occurred at the point of calling, the function  shall  set\n                pdxf_second_duration to the last measured second pulse duration, or\n                zero if a measurement has not yet taken place.",
    "LLR.PLAT.PDX.PWMIN.026": "The interface  shall  report 0% and 100% duty cycles when a timeout has occurred by\n                writing 0 or 1 through pdxf_pin_state respectively.",
    "LLR.PLAT.PDX.PWMIN.027": "The platform shall provide a Simulink interface block named\n                pdx_PwmInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_timed_outInportBoolean\n        \n          Only used in simulation. Place 1 here to simulate a time out, zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      sim_timeout_countInportInteger\n        \n          Only used in simulation. Place a count here to simulate the count of time outs in the\n          input signal.\n        \n        \n          Range: [0, 16777215]\n        \n      sim_duty_cycleInportReal\n        \n          Only used in simulation. Place a duty cycle here to simulate the duty cycle of the last\n          measured period.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      sim_freqInportReal\n        \n          Only used in simulation. Place a frequency in Hz here to simulate the frequency of the\n          last measured period.\n        \n      sim_first_durationInportInteger\n        \n          Only used in simulation. Place a duration in microseconds here to simulate the first pulse\n          from the last measured period.\n        \n        \n          Range: [0, 2000000] microseconds\n        \n      sim_second_durationInportInteger\n        \n          Only used in simulation. Place a duration in microseconds here to simulate the second\n          pulse from the last measured period.\n        \n        \n          Range: [0, 2000000] microseconds\n        \n      sim_period_countInportInteger\n        \n          Only used in simulation. Place a count here to simulate the count of periods seen in the\n          input signal.\n        \n        \n          Range: [0, 16777215]\n        \n      sim_pin_stateInportBoolean\n        \n          Only used in simulation. Place a zero or 1 here to simulate the pin state sample.\n        \n        \n          Range: 0 or 1\n        \n      timed_outOutportBoolean\n        \n          1 if a complete period has not been measured for the timeout given by the mask parameter\n          Time out, zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      timeout_countOutportInteger\n        \n          A count of the time outs, wrapped modulo 16777216.\n        \n        \n          Range: [0, 16777215]\n        \n      duty_cycleOutportReal\n        \n          Ratio of the first pulse duration to the period, or zero if no measurement has been taken.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      freqOutportReal\n        \n          Frequency of the last measured period, or zero if no measurement has been taken. The range\n          of the frequency is limited in various ways.\n        \n        \n              The range of the frequency that can be measured is limited by the filter circuitry of\n              the input pin.\n            \n              The lowest measurable frequency is limited by the filter circuitry and the size of the\n              corresponding processor timer for a channel. Any input frequency below the documented\n              limit, is reported as timed-out.\n            \n              The highest measurable frequency is limited by the filter circuitry and the resolution\n              of the corresponding processor timer for a channel. In general, the block reports\n              the frequency of the filtered signal and the input filtering forms an upper limit.\n              However, as the frequency increases, the resolution of measurement decreases.\n            \n        \n          Details of the input pin's filtering and processor timing can be found in an ECU's\n          technical specification.\n        \n        \n          Range: [0.5, ...] Hz\n        \n      first_durationOutportInteger\n        \n          The duration of the first pulse from the last measured period, or zero if no measurement\n          has been taken.\n        \n        \n          Range: [0, 2000000] microseconds\n        \n      second_durationOutportInteger\n        \n          The duration of the second pulse from the last measured period, or zero if no measurement\n          has been taken.\n        \n        \n          Range: [0, 2000000] microseconds\n        \n      period_countOutportInteger\n        \n          A count of the periods, wrapped modulo 16777216.\n        \n        \n          Range: [0, 16777215]\n        \n      pin_stateOutportBoolean\n        \n          Set to 1 if the input signal is high when the block iterates, set to zero if the input\n          signal is low when the block iterates.\n        \n        \n          Range: 0 or 1\n        \n      ChannelParamList\n        \n          The input pin sourcing the signal to measure.\n        \n      \n                Calibratable: no.\n              InvertParamBoolean\n        \n          Whether the first pulse in the period will be high (option unticked) or low (option\n          ticked). This option does not consider any inversion performed by the hardware, the user\n          must do so.\n        \n      \n                Calibratable: no.\n              Time outParamReal\n        \n          The period of time after which if no complete period has been measured, the outport\n          timed_out is set to 1.\n        \n        \n          Range: [0.5, 10000] Hz\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          If selected then create simulation inports for each of the outport message signals.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.PWMIN.127": "The block pdx_PwmInput shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.PWMIN.227": "The block pdx_PwmInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.PWMIN.028": "Target type is checked by the interface, if\n                it is unsupported then the interface  shall  raise an error.",
    "LLR.PLAT.PDX.PWMIN.029": "Time out(Hz) is checked by the interface,\n                if it is not present or out of range then the interface  shall \n                raise an error.",
    "LLR.PLAT.PDX.PWMIN.030": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDX.PWMIN.031": "An option  shall  be available to provide a simulation input that\n                will appear on the block.",
    "LLR.PLAT.PDX.PWMIN.032": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                timed_out to that of its inport\n                sim_timed_out.",
    "LLR.PLAT.PDX.PWMIN.033": "If the parameter Provide simulation input?\n                 is true, the platform  shall  set the value of the outport\n                 timeout_count to that of its inport\n                 sim_timeout_count.",
    "LLR.PLAT.PDX.PWMIN.034": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                duty_cycle to that of its inport\n                sim_duty_cycle.",
    "LLR.PLAT.PDX.PWMIN.035": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                freq to that of its inport\n                sim_freq.\n                .",
    "LLR.PLAT.PDX.PWMIN.036": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                first_duration to that of its inport\n                sim_first_duration.",
    "LLR.PLAT.PDX.PWMIN.037": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                second_duration to that of its inport\n                sim_second_duration.",
    "LLR.PLAT.PDX.PWMIN.038": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                period_count to that of its inport\n                sim_period_count.",
    "LLR.PLAT.PDX.PWMIN.039": "If the parameter Provide simulation input?\n                is true, the platform  shall  set the value of the outport\n                pin_state to that of its inport\n                sim_pin_state.",
    "LLR.PLAT.PDX.PWMIN.040": "The block  shall  write the timed out flag for the logical Channel\n                to the outport timed_out",
    "LLR.PLAT.PDX.PWMIN.041": "The block  shall  write the count of the timeouts for the logical Channel\n                to the outport timeout_count",
    "LLR.PLAT.PDX.PWMIN.042": "The block  shall  write the duty cycle for the logical Channel\n                to the outport duty_cycle",
    "LLR.PLAT.PDX.PWMIN.043": "The block  shall  write the captured frequency value for the logical Channel\n                to the outport freq",
    "LLR.PLAT.PDX.PWMIN.044": "The block  shall  write the value of the duration of the first pulse for the logical Channel\n                to the outport first_duration",
    "LLR.PLAT.PDX.PWMIN.045": "The block  shall  write the value of the duration of the second pulse for the logical\n                Channel to the outport second_duration",
    "LLR.PLAT.PDX.PWMIN.046": "The block  shall  write the count of the periods for the logical Channel to the outport period_count",
    "LLR.PLAT.PDX.PWMIN.047": "The block  shall  write state of the pin for the logical Channel to the outport pin_state",
    "LLR.PLAT.PDX.PWMIN.048": "The block  shall  invert the state of the pin for the logical Channel and related measurements of duty cycle, first\n                duration and second duration according to the mask parameters Invert.",
    "LLR.APP.PDX.SENTIN.001": "The application  will  invoke an interface during application initialisation to declare\n              logical SENT input channels that will be decoded during run time.",
    "LLR.PLAT.PDX.SENTIN.001": "The platform  shall  clear the decoded and desync\n              counters during initialisation.",
    "LLR.PLAT.PDX.SENTIN.002": "The platform  shall  clear the messages and crc-failures\n              counters during initialisation.",
    "LLR.APP.PDX.SENTIN.003": "The application  shall  specify the channel's transmitter SENT tick\n              duration in the range [3, 90] microseconds with a minimum resolution of 0.1\n              microseconcds.",
    "LLR.PLAT.PDX.SENTIN.004": "The platform  shall  measure the electrical state of the signal line, either low or\n              high.\n            Rationale: \n              The application can use this measure to periodically determine if the signal line is\n              shorted to ground or to power.",
    "LLR.PLAT.PDX.SENTIN.005": "The platform  shall  measure the duration of each SENT pulse, falling edge to falling\n              edge.\n            Note: \n              The need to measure falling to rising edge is currently deferred, see\n              [LLR.PLAT.PDX.SENTIN.007].",
    "LLR.PLAT.PDX.SENTIN.006": "The platform  shall  use a timer with a rate of at least 1 MHz when measuring the\n              duration of each SENT pulse.\n            Rationale: \n              The rate specified by this requirement is at least twice the rate of the minimum clock\n              rate to avoid aliasing.",
    "LLR.PLAT.PDX.SENTIN.007": "Deferred:\n              When a SENT pulse is measured, if the low part of the pulse (falling edge to rising\n              edge) is less than 4 SENT ticks then the platform  shall  increment the\n              low-pulse-desync counter (no saturation), discard information\n              from the current SENT frame and wait for the next calibration pulse.\n            Note: \n              The requirement is currently deferred because there is no need to detect errors in the\n              low pulse given in J2716. The requirement was originally added as it was felt the\n              application could use this information when implementing fault detection and fall back\n              strategies for the sensor, specifically for flagging cases where the transmitter's\n              clock drift is close to the allowable range.",
    "LLR.PLAT.PDX.SENTIN.008": "When the platform is not decoding a frame, and a SENT pulse measures 42 to 70 SENT\n              ticks inclusive (\u00b1 25% of 56 SENT ticks), then the platform  shall  start decoding the\n              frame.\n            Rationale: \n              This pulse represents the calibration pulse from the transmitter, starting a\n              frame. This pulse can be used by the receiver to account for the transmitter's clock\n              variance.",
    "LLR.PLAT.PDX.SENTIN.009": "When decoding a frame, the platform  shall  adjust the duration of each remaining frame\n              pulse by dividing the pulse duration by the ratio: measured calibration-pulse-duration\n              \/ transmitter's SENT tick duration. This normalises the pulse measurement, taking the\n              transmitter's clock variance into account.",
    "LLR.PLAT.PDX.SENTIN.083": "When the calibration pulse durations of two successive SENT frames,\n              Fn-1 and Fn, differ by more than\n              \u00b11.5625% then the platform  shall  increment the desync counter (no saturation),\n              discard information from the oldest of the two SENT frames, Fn-1,\n              and continue to decode the current SENT bit stream.\n            \n              By continuing to decode the SENT bit stream, the platform has the chance to\n              resynchronise to the current SENT frame, Fn.",
    "LLR.APP.PDX.SENTIN.010": "The application  shall  provide the number of expected fast data nibbles for a SENT\n              channel.",
    "LLR.PLAT.PDX.SENTIN.011": "When decoding a frame, the platform  shall  extract the status nibble, data nibble or\n              nibbles and CRC nibble.",
    "LLR.PLAT.PDX.SENTIN.012": "If a pulse for a nibble is found to be too short (less than 12 normalised SENT ticks)\n              or too long (more than 27 normalised SENT ticks), the platform  shall  increment the\n              desync counter (no saturation), discard information from the\n              current SENT frame and wait for the next calibration pulse.",
    "LLR.PLAT.PDX.SENTIN.013": "When the CRC nibble is extracted, if the extracted CRC does not match the CRC\n              calculated from the data nibbles, the platform  shall  increment the\n              desync counter (no saturation), discard information from the\n              current SENT frame and wait for the next calibration pulse.",
    "LLR.PLAT.PDX.SENTIN.014": "If a SENT frame contains the wrong number of expected fast data nibbles\n              (see [LLR.APP.PDX.SENTIN.010])\n              then the platform  shall  increment the desync counter (no saturation),\n              discard information from the current SENT frame and wait for the next calibration pulse.",
    "LLR.APP.PDX.SENTIN.015": "The application  shall  declare which CRC algorithm the platform uses, either\n              legacy (for revision Feb2008 or earlier) or\n              recommended (for revision Jan2010).",
    "LLR.PLAT.PDX.SENTIN.016": "When the CRC nibble matches the CRC calculated from the data nibbles, the platform\n               shall  increment the decoded counter (no saturation) remember the\n              status nibble, data nibble(s) and current time for the SENT frame for the application\n              to retrieve at a later time.\n            Rationale: \n              The data from a sensor is likely continuous in nature (pressure, temperature, gear\n              selection) rather than state change in nature (e.g., changed gear selection, no change\n              in gear selection). Thus the platform remembers only the last frame data (a queue size\n              of 1). The platform remembers the approximate time of frame arrival to allow the\n              application logic to determine if the transmitter is regularly sending information.",
    "LLR.PLAT.PDX.SENTIN.017": "When the platform discards a frame, the platform discards accumulated serial data\n              (either short or enhanced) that is not fully received.\n            Rationale: \n              There must be sufficient information from valid frames to construct the serial\n              data. Loosing one frame causes the loss of a sequence, and hence the loss of serial\n              data.",
    "LLR.PLAT.PDX.SENTIN.018": "When the shift register has accumulated at least 16 sequential valid frames, and\n              SD3[15] is one, and SD3[14:0] is zero, then short serial data has been received and the\n              platform  shall  check the validity of the message ID and data nibbles.",
    "LLR.PLAT.PDX.SENTIN.019": "If the short serial CRC does not match the CRC calculated from the short serial\n              message ID and data nibbles (see [LLR.PLAT.PDX.SENTIN.013]\n              for CRC algorithm), then the platform  shall  increment the crc-failures\n              counter (no saturation), and discard accumulated serial data.",
    "LLR.PLAT.PDX.SENTIN.020": "If the short serial CRC matches the CRC calculated from the short serial message ID\n              and data nibbles (see [LLR.PLAT.PDX.SENTIN.013]\n              for CRC algorithm), then the platform  shall  remember the serial message ID, data nibbles,\n              serial data type ('short'), and the timestamp of the last frame making up the short serial\n              data bits for the application to retrieve at a later time, increment the messages\n              counter (no saturation) and discard accumulated serial data.",
    "LLR.PLAT.PDX.SENTIN.021": "When the shift register has accumulated at least 18 sequential valid frames, and\n              SD3[17:12] are all one, and SD3[11], SD3[5] and SD3[0] are zero, then enhanced serial data\n              has been received and the platform  shall  check the validity of the message ID and data\n              nibbles.",
    "LLR.PLAT.PDX.SENTIN.022": "If the enhanced serial CRC does not match the CRC calculated from the enhanced serial\n              message ID and data nibbles (see section 5.2.4.3 of the J2716 specification for the\n              CRC algorithm), then the platform  shall  increment the crc-failures\n              counter (no saturation), and discard accumulated serial data.",
    "LLR.PLAT.PDX.SENTIN.023": "If the enhanced serial CRC matches the CRC calculated from the enhanced serial message ID\n              and data nibbles (see see section 5.2.4.3 of the J2716 specification for the CRC\n              algorithm), then the platform  shall  remember the enhanced serial message ID, data\n              nibbles, serial type (enhanced format 1 or enhanced\n              format 2, based on SD3[10]) and the timestamp of the last frame making up\n              the enhanced serial data bits for the application to retrieve at a later time, increment\n              the messages counter (no saturation) and discard accumulated\n              serial data.",
    "LLR.PLAT.PDX.SENTIN.024": "The platform  shall  ignore any pause pulses.",
    "LLR.PLAT.PDX.SENTIN.025": "The platform shall provide a C interface function named\n                pdx_sent_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a SENT input. Use the macros included by the pio.h file, of the form PIO_SENTIN_[NAME].pdxf_tick_length_us\n          in\n        F32\nThe length of the SENT sensor's transmission clock tick. \n Range: [3, 90] microseconds \n Resolution: 0.1 microsecondspdxf_num_nibbles\n          in\n        U8\nThe number of data nibbles transmitted by the SENT sensor in each frame. \n Range: [1, 6] nibblespdxf_crc_version\n          in\n        PIO_PDX_SENT_CRC_T\nWhich CRC algorithm the SENT sensor applies to each SENT frame. \n Either PIO_PDX_SENT_CRC_2008 or PIO_PDX_SENT_CRC_2010.pdxf_num_decoded_frames\n          out\n        U8 *\nA counter incremented for each frame that is successfully received, decoded and verified. \n Cannot be NULL. \n Range: [0, inf] frames, modulo 256pdxf_num_desyncs\n          out\n        U8 *\nA counter incremented for each loss of synchronisation with the SENT sensor pulse stream. Loss of synchronisation occurs when the pulse decoder has not seen a valid pulse for more than 125% of a calibration pulse duration (where a calibration pulse is 56 SENT ticks, see pdxf_tick_length_us); or a calibration, status, nibble or CRC pulse is too short; or the frame CRC verification fails. \n Cannot be NULL. \n Range: [0, inf] frames, modulo 256pdxf_valid\n          out\n        BOOL *\nTrue if at least one SENT frame has been successfully received, decoded and verified, false otherwise. If true, then the pdxf_status and pdxf_data parameters provide the status and data received from the last frame, and the pdxf_timestamp parameter provides the time when the frame was received. \n Cannot be NULL. \n Range: 0 or 1pdxf_status\n          out\n        U8 *\nThe status nibble of the last SENT frame that was successfully received, decoded and verified. Set to zero when a SENT frame has not been successfully received. \n Cannot be NULL. \npdxf_data\n          out\n        U32 *\nThe data nibbles of the last SENT frame that was successfully received, decoded and verified. Set to zero when a SENT frame has not been successfully received. The data nibbles are packed into the integer right aligned. \n Cannot be NULL. \npdxf_timestamp\n          out\n        U32 *\nA timestamp is taken when the the last SENT frame was fully received, decoded and verified. The timestamp increments in counts of 256, wrapping approximately every 4 seconds. The timestamp can be used by the application to determine whether the SENT sensor is transmitting data at the expected period. \n Cannot be NULL. \n Range: [0, inf] counts, modulo 4294967296pdxf_pin_state\n          out\n        BOOL *\n1 if the channel pin voltage is above the detection threshold, 0 otherwise. Can be used by the application for electrical diagnostics. \n Range: 0 or 1pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_BAD_ARGS - configuration errorPDX_RC_SDM_ALLOC_ERROR - error allocating ram in SDM",
    "LLR.PLAT.PDX.SENTIN.026": "The function pdx_sent_input() shall support the targets:\n                      M110-000 and M670-000.",
    "LLR.PLAT.PDX.SENTIN.027": "The function pdx_sent_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.SENTIN.028": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PDX_RC_BAD_ARGS and also setting the recoverable\n                error PSY_PDX\/PDX_CHANNEL_INVALID.\n              Note: \n                A potential hardware input as something the processor can read, a physical quantity, in\n                any variant of the hardware.",
    "LLR.PLAT.PDX.SENTIN.029": "The function  shall  return PDX_RC_BAD_ARGS when any one of the\n                parameters\n\n                pdxf_tick_length_us,\n                pdxf_num_nibbles and\n                pdxf_crc_version\n\n                is outside its allowable range during application initialisation.",
    "LLR.PLAT.PDX.SENTIN.030": "The function  shall  return PDX_RC_BAD_ARGS when any one of the\n                parameters\n\n                pdxf_num_decoded_frames,\n                pdxf_num_desyncs,\n                pdxf_valid,\n                pdxf_status,\n                pdxf_data,\n                pdxf_timestamp and\n                pdxf_pin_level\n\n                is NULL during application run-time.",
    "LLR.PLAT.PDX.SENTIN.031": "The function  shall  write the decoded counter through\n                parameter ptpuf_num_decoded_frames.",
    "LLR.PLAT.PDX.SENTIN.032": "The function  shall  write the desync counter through\n                parameter ptpuf_num_desyncs.",
    "LLR.PLAT.PDX.SENTIN.033": "If at least one SENT frame has been successfully received since reset then the\n                function  shall  write TRUE through parameter ptpuf_valid,\n                otherwise the function  shall  write FALSE through parameter\n                ptpuf_valid.",
    "LLR.PLAT.PDX.SENTIN.034": "If at least one SENT frame has been successfully received since reset then the\n                function  shall  write the last received status nibble through parameter\n                ptpuf_status, otherwise the function  shall  write the value zero\n                through parameter ptpuf_status.",
    "LLR.PLAT.PDX.SENTIN.035": "If at least one SENT frame has been successfully received since reset then the\n                function  shall  write the last received fast data nibble(s) through parameter\n                ptpuf_data, otherwise the function  shall  write the value\n                zero through parameter ptpuf_data.",
    "LLR.PLAT.PDX.SENTIN.036": "If at least one SENT frame has been successfully received since reset then the\n                function  shall  write the timestamp of the last received SENT frame through parameter\n                ptpuf_timestamp, otherwise the function  shall  write the value\n                zero through parameter ptpuf_timestamp.",
    "LLR.PLAT.PDX.SENTIN.037": "The function  shall  write the electrical state of the signal line for the SENT\n                channel through parameter ptpuf_pin_level.",
    "LLR.PLAT.PDX.SENTIN.053": "The platform shall provide a C interface function named\n                pdx_sent_serial_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a SENT input. Use the macros included by the pio.h file, of the form PIO_SENTIN_[NAME].pdxf_num_messages\n          out\n        U8 *\nA counter incremented for each serial message that is successfully received, decoded and verified. \n Cannot be NULL. \n Range: [0, inf] messages, modulo 256pdxf_num_failed_crcs\n          out\n        U8 *\nA counter incremented for each serial message that is received but that fails a CRC verification. \n Cannot be NULL. \n Range: [0, inf] messages, modulo 256pdxf_valid\n          out\n        BOOL *\nTrue if at least one serial message has been successfully received, decoded and verified, false otherwise. If true, then the pdxf_serial_format, pdxf_message_id and pdxf_data parameters provide information about the last successfully received, decoded and verified message, and the pdxf_timestamp parameter provides the time when the message was received. \n Cannot be NULL. \n Range: 0 or 1pdxf_serial_format\n          out\n        PDX_SENT_SERIAL_FORMAT_T *\nThe detected serial format of the last successfully received, decoded and verified slow serial message. Set to zero when a serial message has not been received.\n Cannot be NULL. \npdxf_message_id\n          out\n        U8 *\nThe value of the message identifier of the last successfully received, decoded and verified slow serial message. Set to zero when a serial message has not yet been received.\n Range: [0, 15] for short serial and enhanced serial format 2 \n Range: [0, 255] for enhanced serial format 1pdxf_data\n          out\n        U32 *\nThe data nibbles of the last successfully received, decoded and verified slow serial message. Set to zero when a serial message has not yet been received. \n Cannot be NULL. \n Range: [0, 255] for short serial \n Range: [0, 8192] for enhanced serial format 1 \n Range: [0, 65535] for enhanced serial format 2 \npdxf_timestamp\n          out\n        U32 *\nA timestamp is taken when the the last successfully received, decoded and verified slow serial message. The timestamp increments in counts of 256, wrapping approximately every 4 seconds. The timestamp can be used by the application to determine whether the SENT sensor is transmitting data at the expected period. \n Cannot be NULL. \n Range: [0, inf] counts, modulo 4294967296\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_BAD_ARGS - configuration error",
    "LLR.PLAT.PDX.SENTIN.054": "The function pdx_sent_serial_input() shall support the targets:\n                      M110-000 and M670-000.",
    "LLR.PLAT.PDX.SENTIN.055": "The function pdx_sent_serial_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.SENTIN.056": "The function  shall  reject a logical channel number which cannot be mapped to a potential\n                hardware output by returning PDX_RC_BAD_ARGS and also setting the recoverable\n                error PSY_PDX\/PDX_CHANNEL_INVALID.\n              Note: \n                A potential hardware input as something the processor can read, a physical quantity, in\n                any variant of the hardware.",
    "LLR.PLAT.PDX.SENTIN.079": "The function  shall  reject a logical channel number which has not already been\n                configured as a SENT channel by invoking pdx_sent_input()\n                by returning PDX_RC_SDM_ALLOC_ERROR.\n              Rationale: \n                There is insufficient information passed from the application to the platform\n                through this interface for the platform to configure the SENT channel. Instead\n                the application provides configuration information once through the\n                pdx_sent_input() interface to avoid duplication.",
    "LLR.PLAT.PDX.SENTIN.057": "The function  shall  return PDX_RC_BAD_ARGS when any one of the\n                parameters\n\n                pdxf_num_messages,\n                pdxf_num_failed_crcs,\n                pdxf_valid,\n                pdxf_serial_format,\n                pdxf_message_id,\n                pdxf_data and\n                pdxf_timestamp\n\n                is NULL during application run-time.",
    "LLR.PLAT.PDX.SENTIN.058": "The function  shall  write the messages counter through\n                parameter ptpuf_num_messages.",
    "LLR.PLAT.PDX.SENTIN.059": "The function  shall  write the crc-failures counter through\n                parameter ptpuf_num_failed_crcs.",
    "LLR.PLAT.PDX.SENTIN.060": "If at least one serial message has been successfully received since reset then the\n                function  shall  write TRUE through parameter ptpuf_valid,\n                otherwise the function  shall  write FALSE through parameter\n                ptpuf_valid.",
    "LLR.PLAT.PDX.SENTIN.061": "If at least one serial message has been successfully received since reset then the\n                function  shall  write the serial format of the last received message through parameter\n                ptpuf_serial_format, otherwise the function  shall  write the value zero\n                through parameter ptpuf_serial_format.",
    "LLR.PLAT.PDX.SENTIN.062": "If at least one serial message has been successfully received since reset then the\n                function  shall  write the message identifier of the last received message through parameter\n                ptpuf_message_id, otherwise the function  shall  write the value\n                zero through parameter ptpuf_message_id.",
    "LLR.PLAT.PDX.SENTIN.063": "If at least one serial message has been successfully received since reset then the\n                function  shall  write the data nibbles of the last received message through parameter\n                ptpuf_data, otherwise the function  shall  write the value\n                zero through parameter ptpuf_data.",
    "LLR.PLAT.PDX.SENTIN.064": "If at least one serial message has been successfully received since reset then the\n                function  shall  write the timestamp of the last received message through parameter\n                ptpuf_timestamp, otherwise the function  shall  write the value\n                zero through parameter ptpuf_timestamp.",
    "LLR.PLAT.PDX.SENTIN.038": "The platform shall provide a Simulink interface block named\n                pdx_SentInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_frames_decodedInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_desyncsInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_validInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_statusInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_dataInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_timestampInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_pin_stateInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      frames_decodedOutportInteger\n        \n          A counter incremented for each frame that is successfully received, decoded and verified.\n        \n        \n          Range: [0, inf] frames, modulo 256\n        \n      desyncsOutportInteger\n        \n          A counter incremented for each loss of synchronisation with the SENT sensor pulse stream.\n          Loss of synchronisation occurs when the block pulse decoder has not seen a valid pulse for\n          more than 125% of a calibration pulse duration (where a calibration pulse is 56 SENT ticks,\n          Tick length); or a calibration, status, nibble or CRC pulse is too short;\n          or the frame CRC verification fails.\n        \n        \n          Range: [0, inf] frames, modulo 256\n        \n      validOutportBoolean\n        \n          1 if at least one SENT frame has been successfully received, decoded and verified, 0\n          otherwise. If 1, then the status and data\n          outports provide the status and data received from the last frame, and the\n          timestamp outport provides the time when the frame was received.\n        \n        \n          Range: 0 or 1\n        \n      statusOutportInteger\n        \n          The status nibble of the last SENT frame that was successfully received, decoded and\n          verified. Set to zero when a SENT frame has not been successfully received.\n        \n        \n          Range: 0 or 1\n        \n      dataOutportInteger\n        \n          The data nibbles of the last SENT frame that was successfully received, decoded and\n          verified. Set to zero when a SENT frame has not been successfully received.\n          The data nibbles are packed into the integer right aligned.\n        \n        \n          Range: [0, 16777215] unitless\n        \n      timestampOutportInteger\n        \n          A timestamp taken when the last SENT frame was fully received, decoded and verified.\n          The timestamp increments in counts of 256, wrapping approximately every 4 seconds.  The\n          timestamp can be used by the application to determine whether the SENT sensor is\n          transmitting data at the expected period.\n        \n        \n          Range: [0, inf] counts, modulo 4294967296\n        \n      pin_stateOutportBoolean\n        \n          1 if the channel pin voltage is above the detection threshold, 0 otherwise.\n          Can be used by the application for electrical diagnostics.\n        \n        \n          Range: 0 or 1\n        \n      ChannelParamList\n        \n          The channel pin for this SENT input.\n        \n      \n                Calibratable: no.\n              Tick lengthParamReal\n        \n          The length of the SENT sensor's transmission clock tick connected to this channel.\n        \n        \n          Range: [3, 90] microseconds\n          \n          Resolution: 0.1 microseconds\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Number of data nibblesParamInteger\n        \n          The number of data nibbles transmitted by the SENT sensor in each frame.\n        \n        \n          Range: [1, 6] nibbles\n        \n      \n                Calibratable: used during initialisation (power-up).\n              CRC versionParamList\n        \n          The version of CRC algorithm used by the SENT sensor.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          If selected then the block creates simulation inports for each of the outports.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.SENTIN.039": "The block pdx_SentInput shall support the targets:\n            M110-000 and M670-000.",
    "LLR.PLAT.PDX.SENTIN.040": "The block pdx_SentInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.SENTIN.041": "If the block is included in a model targeting an ECU not supported by the\n                block then the block  shall  raise an error.",
    "LLR.PLAT.PDX.SENTIN.042": "The block  shall  raise an error if any of the mask parameters\n\n                Tick length,\n                Number of data nibbles,\n                CRC version and\n                Sample time\n\n                is outside its allowable range and resolution.",
    "LLR.PLAT.PDX.SENTIN.043": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDX.SENTIN.044": "If the Provide simulation input? mask parameter is\n                not selected, the block  shall  set outports\n\n                frames_decoded,\n                desyncs,\n                valid,\n                status,\n                data,\n                timestamp,\n                pin_state\n\n                to zero.",
    "LLR.PLAT.PDX.SENTIN.081": "If the Provide simulation input? mask parameter is\n                selected, the block  shall  set outports\n\n                frames_decoded,\n                desyncs,\n                valid,\n                status,\n                data,\n                timestamp,\n                pin_state\n\n                to their corresponding inports:\n\n                sim_frames_decoded,\n                sim_desyncs,\n                sim_valid,\n                sim_status,\n                sim_data,\n                sim_timestamp,\n                sim_pin_state\n\n                clipped to the output range of each respectively.",
    "LLR.PLAT.PDX.SENTIN.045": "The block  shall  write the decoded counter through\n                outport frames_decoded.",
    "LLR.PLAT.PDX.SENTIN.046": "The block  shall  write the desync counter through\n                outport desyncs.",
    "LLR.PLAT.PDX.SENTIN.047": "If at least one SENT frame has been successfully received since reset then the\n                block  shall  write value 1 through outport valid,\n                otherwise the block  shall  write value zero through outport\n                valid.",
    "LLR.PLAT.PDX.SENTIN.048": "If at least one SENT frame has been successfully received since reset then the\n                block  shall  write the last received status nibble through outport\n                status, otherwise the block  shall  write\n                the value zero through outport status.",
    "LLR.PLAT.PDX.SENTIN.049": "If at least one SENT frame has been successfully received since reset then the\n                block  shall  write the last received fast data nibble(s) through outport\n                data, otherwise the block  shall  write\n                the value zero through outport data.",
    "LLR.PLAT.PDX.SENTIN.050": "If at least one SENT frame has been successfully received since reset then the\n                block  shall  write the timestamp of the last received SENT frame through outport\n                timestamp, otherwise the block  shall \n                write the value zero through outport timestamp.",
    "LLR.PLAT.PDX.SENTIN.051": "The block  shall  write the electrical state of the signal line for the SENT\n                channel through outport pin_state.",
    "LLR.PLAT.PDX.SENTIN.065": "The platform shall provide a Simulink interface block named\n                pdx_SentSerialInput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_messagesInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_crc_failuresInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_validInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_serial_formatInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_message_idInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_dataInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      sim_timestampInportInteger\n        \n          Available when Provide simulation input? is ticked. The value\n          of this inport is copied to the corresponding outport during model simulation.\n        \n      messagesOutportInteger\n        \n          A counter incremented for each serial message that is successfully received, decoded and\n          verified.\n        \n        \n          Range: [0, inf] messages, modulo 256\n        \n      crc_failuresOutportInteger\n        \n          A counter incremented for each serial message that is received but that fails a CRC\n          verification.\n        \n        \n          Range: [0, inf] messages, modulo 256\n        \n      validOutportInteger\n        \n          Set to one if at least one serial message has been successfully received, decoded and\n          verified, set to zero otherwise. If set to one, then the\n          serial_formatpdxf_serial_format,\n          message_id and\n          data\n          outports provide information about the last successfully received, decoded\n          and verified message, and the\n          timestamp\n          outport provides the time when the message was received.\n        \n        \n          Range: 0 or 1\n        \n      serial_formatOutportInteger\n        \n          The detected serial format of the last successfully received, decoded and verified\n          serial message. Set to zero when a serial message has not been received.\n        \n        Outport valueDescription0Identifies a short serial message, with a 4-bit message identifier and 8-bit data1Identifies an enhanced format 1 serial message, with a 8-bit message identifier and 12-bit data2Identifies an enhanced format 2 serial message, with a 4-bit message identifier and 16-bit data\n      message_idOutportInteger\n        \n          The value of the message identifier of the last successfully received, decoded and\n          verified serial message. Set to zero when a serial message has not yet been received.\n        \n        \n          Range: [0, 15] for short serial and enhanced serial format 2\n          \n          Range: [0, 255] for enhanced serial format 1\n        \n      dataOutportInteger\n        \n          The data nibbles of the last successfully received, decoded and verified serial\n          message. Set to zero when a serial message has not yet been received.\n        \n        \n          Range: [0, 255] for short serial\n          \n          Range: [0, 8192] for enhanced format 1\n          \n          Range: [0, 65535] for enhanced format 2\n        \n      timestampOutportInteger\n        \n          A timestamp is taken when the last SENT message was fully received, decoded and verified.\n          The timestamp increments in counts of 256, wrapping approximately every 4 seconds.  The\n          timestamp can be used by the application to determine whether the SENT sensor is\n          transmitting data at the expected period.\n        \n        \n          Range: [0, inf] counts, modulo 4294967296\n        \n      ChannelParamList\n        \n          The channel pin for this SENT input.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          If selected then the block creates simulation inports for each of the outports.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.SENTIN.066": "The block pdx_SentSerialInput shall support the targets:\n            M110-000 and M670-000.",
    "LLR.PLAT.PDX.SENTIN.067": "The block pdx_SentSerialInput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.SENTIN.068": "If the block is included in a model targeting an ECU not supported by the\n                block then the block  shall  raise an error.",
    "LLR.PLAT.PDX.SENTIN.069": "The block  shall  raise an error is the mask parameter\n                Sample time\n                is outside its allowable range and resolution.",
    "LLR.PLAT.PDX.SENTIN.080": "The block  shall  raise an error if the Channel\n                parameter is not configured by the presence of a pdx_SentInput\n                block in the same model.\n              Rationale: \n                There is insufficient information passed from the application to the platform\n                through this interface for the platform to configure the SENT channel. Instead\n                the application provides configuration information once through the\n                pdx_SentInput() interface to avoid duplication.",
    "LLR.PLAT.PDX.SENTIN.070": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PDX.SENTIN.071": "If the Provide simulation input? mask parameter is\n                not selected, the block  shall  set outports\n\n                messages,\n                crc_failures,\n                valid,\n                serial_format,\n                message_id,\n                data,\n                timestamp\n\n                to zero.",
    "LLR.PLAT.PDX.SENTIN.082": "If the Provide simulation input? mask parameter is\n                selected, the block  shall  set outports\n\n                messages,\n                crc_failures,\n                valid,\n                serial_format,\n                message_id,\n                data,\n                timestamp\n\n                to their corresponding inports:\n\n                sim_messages,\n                sim_crc_failures,\n                sim_valid,\n                sim_serial_format,\n                sim_message_id,\n                sim_data,\n                sim_timestamp\n\n                clipped to the output range of each respectively.",
    "LLR.PLAT.PDX.SENTIN.072": "The block  shall  write the messages counter through\n                outport messages.",
    "LLR.PLAT.PDX.SENTIN.073": "The block  shall  write the crc-failures counter through\n                outport crc-failures.",
    "LLR.PLAT.PDX.SENTIN.074": "If at least one serial message has been successfully received since reset then the\n                block  shall  write value 1 through outport valid,\n                otherwise the block  shall  write value zero through outport\n                valid.",
    "LLR.PLAT.PDX.SENTIN.075": "If at least one serial message has been successfully received since reset then the\n                block  shall  write the serial format of the last received message through outport\n                serial_format, otherwise the block  shall  write\n                the value zero through outport serial_format.",
    "LLR.PLAT.PDX.SENTIN.076": "If at least one serial message has been successfully received since reset then the\n                block  shall  write the message identifier of the last received message through outport\n                message_id, otherwise the block  shall  write\n                the value zero through outport message_id.",
    "LLR.PLAT.PDX.SENTIN.077": "If at least one serial message has been successfully received since reset then the\n                block  shall  write the data nibbles of the last received serial message through outport\n                data, otherwise the block  shall \n                write the value zero through outport data.",
    "LLR.PLAT.PDX.SENTIN.078": "If at least one serial message has been successfully received since reset then the\n                block  shall  write the timestamp of the last received serial message through outport\n                timestamp, otherwise the block  shall \n                write the value zero through outport timestamp.",
    "LLR.APP.PDX.PHINJOUT.001": "The application  will  invoke an interface during application\n              initialisation to declare peak and hold injector output\n              channels whose injector frequency, peak duty, peak-hold duty\n              and injector clock frequency may be set during run time.",
    "LLR.PLAT.PDX.PHINJOUT.002": "During or after application initialisation, the platform\n               shall  ensure the hardware is correctly initialised to set\n              peak and hold injector output channels declared by the\n              application.",
    "LLR.PLAT.PDX.PHINJOUT.003": "The initialisation process  shall  set the peak and hold\n              injector output channel to initial values of injector frequency,\n              peak duty cycle, peak-hold duty cycle, injector clock\n              frequency and offset defined by the application.",
    "LLR.PLAT.PDX.PHINJOUT.004": "The platform  shall  update the period\n              counters of the three PWM output channels at a rate which permits\n              the output frequency range defined in the the technical specification\n              document.",
    "LLR.PLAT.PDX.PHINJOUT.039": "The platform  shall  update the offset as requested by the application.",
    "LLR.PLAT.PDX.PHINJOUT.005": "The platform shall provide a C interface function named\n                pdx_phinj_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan_phinj\n          in\n        PDX_LCHAN_PHINJ_T\nThe logical channel associated with the peak and hold injector output. Use the macros included by the pio.h file, of the form PIO_PHINJOT_[NAME]. Note that this selects channels for the peak, peak-hold and injector clock outputs.pdxf_inj_freq\n          in\n        F32\nThe desired frequency of the peak and hold injector output. If the software cannot match the desired frequency, the frequency will be adjusted to as close a match as is possible.\n Range: [0.1, 1000] Hzpdxf_peak_duty\n          in\n        F32\nThe desired peak duty cycle of the peak and hold injector output. If the software cannot match the desired duty cycle, the frequency will be adjusted to as close a match as is possible. Some channels cannot achieve very low or very high duty cycles accurately (although 0% and 100% is correctly handled) and will introduce jitter into the signal. It is up to the caller to ensure this condition does not arise. \n Range: [0, 1] unitlesspdxf_pkhold_duty\n          in\n        F32\nThe desired peak-hold duty cycle of the peak and hold injector output. This must not be less than the peak duty cycle: if it is it will be set to match the peak duty cycle. If the software cannot match the desired duty cycle, the frequency will be adjusted to as close a match as is possible. Some channels cannot achieve very low or very high duty cycles accurately (although 0% and 100% is correctly handled) and will introduce jitter into the signal. It is up to the caller to ensure this condition does not arise. \npdxf_clock_freq\n          in\n        F32\nThe desired frequency of the peak and hold injector clock. If the software cannot match the desired frequency, the frequency will be adjusted to as close a match as is possible. \n Range: [1, 10000] Hzpdxf_offset\n          in\n        F32\nThe desired phase offset of the injector output, relative to other injector output channels that have been configured with the same frequency. \n Range: [0, 10000] mspdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - if successful actionPDX_RC_BAD_ARGS - if configuration errorPDX_RC_PEAK_HOLD_TOO_LOW - if the peak-hold duty is less than the peak duty",
    "LLR.PLAT.PDX.PHINJOUT.105": "The function pdx_phinj_output() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PDX.PHINJOUT.205": "The function pdx_phinj_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.PHINJOUT.006": "The function  shall  reject a logical channel number which\n                cannot be mapped to a potential hardware output by\n                returning PDX_RC_BAD_ARGS.",
    "LLR.PLAT.PDX.PHINJOUT.007": "The function  shall  clip the pdxf_inj_freq parameter to the nearest\n                limit if it falls outside the frequency range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.PHINJOUT.008": "The function  shall  clip the pdxf_peak_duty parameter to the nearest\n                limit if it falls outside the duty cycle range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.PHINJOUT.009": "The function  shall  clip the pdxf_pkhold_duty parameter to the nearest\n                limit if it falls outside the duty cycle range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.PHINJOUT.010": "If the pdxf_pkhold_duty parameter is less than the pdxf_peak_duty\n                parameter, the function  shall  set the pdxf_pkhold_duty parameter\n                equal to the pdxf_peak_duty parameter.",
    "LLR.PLAT.PDX.PHINJOUT.011": "The function  shall  clip the pdxf_clock_freq parameter to the nearest\n                limit if it falls outside the frequency range specified in the\n                technical specification document for a PWM output.",
    "LLR.PLAT.PDX.PHINJOUT.012": "The function  shall  clip the pdxf_offset parameter to the nearest\n                limit if it falls outside the offset range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.PHINJOUT.013": "If the interface parameter checks pass then the function  shall \n                output a stepped current at the required frequency with the\n                proportion of time at the peak current level equal to the required\n                peak duty cycle, and the proportion of time at the hold current\n                level equal to the peak-hold duty cycle minus the peak duty cycle,\n                and the rest of the cycle time at zero current.",
    "LLR.PLAT.PDX.PHINJOUT.038": "The function  shall  use the clipped pdxf_offset parameter to apply the requested offset.",
    "LLR.PLAT.PDX.PHINJOUT.014": "The platform shall provide a Simulink interface block named\n                pdx_PeakHoldInjectorOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninjector_frequencyInportReal\n        \n          The frequency of the injector cycles.\n        \n        \n          Range: [0.1, 1000] Hz\n        \n      peak_duty_cycleInportReal\n        \n          After being rescaled by the mask parameter Min\/Max duty cycle\n          as described above, this is the ratio of the peak current time to the injector\n          cycle time.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      peak_hold_duty_cycleInportReal\n        \n          After being rescaled by the mask parameter Min\/Max duty cycle\n          as described above, this is the ratio of the peak-hold current time to the injector\n          cycle time.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      faultInportBoolean\n        \n          Set to 1 to force the block\n          to use the default peak and peak-hold duty cycles, 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      clock_frequencyInportReal\n        \n          The frequency of the injector clock.\n        \n        \n          Range: [1, 10000] Hz\n        \n      sim_injector_frequencyOutportReal\n        \n          Only used in simulation. This\n          outport is set to the calculated frequency for the injector cycles.\n        \n        \n          Range: [0.1, 1000] Hz\n        \n      sim_peak_duty_cycleOutportReal\n        \n          Only used in simulation. This\n          outport is set to the calculated duty cycle (after rescaling by the mask parameter\n          Min\/Max duty cycle as described above) for the peak channel.\n      \n        \n          Range: [0, 1] duty-cycle\n        \n      sim_peak_hold_duty_cycleOutportReal\n        \n          Only used in simulation. This\n          outport is set to the calculated duty cycle (after rescaling by the mask parameters\n          Min\/Max duty cycle as described above) for the peak-hold channel.\n          It is constrained to be at least as great as the peak duty cycle.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      sim_clock_frequencyOutportReal\n        \n          Only used in simulation. This\n          outport is set to the calculated frequency for the injector clock.\n        \n        \n          Range: [1, 10000] Hz\n        \n      Injector channelParamList\n        \n          The injector channel for this block.\n          The peak, peak-hold and injector clock channels are automatically assigned based on this.\n        \n      \n                Calibratable: no.\n              Initial injector frequencyParamReal\n        \n          The frequency\n          of the channel signal before the block first iterates.\n        \n        \n          Range: [0.1, 1000] Hz\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Peak default duty cycleParamReal\n        \n          This is the\n          final duty cycle of the peak signal when inport fault is set. The duty cycle\n          is mapped directly to the output channel.\n        \n        \n          Range: 0 or 1 duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Peak initial duty cycleParamReal\n        \n          The duty cycle of the peak signal (prior to rescaling by Min\/Max duty cycle)\n          before the block has first been executed.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Peak-hold default duty cycleParamBoolean\n        \n          This is the\n          final duty cycle of the peak-hold signal when inport fault is set. The duty cycle\n          is mapped directly to the output channel.\n        \n        \n          Range: 0 or 1 duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Peak-hold initial duty cycleParamReal\n        \n          The duty cycle of the peak-hold signal (prior to rescaling by Min\/Max duty cycle)\n          before the block has first been executed.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Clock initial frequencyParamReal\n        \n          The frequency\n          of the injector clock signal before the block first iterates.\n        \n        \n          Range: [1, 10000] Hz\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Min\/Max duty cycleParamReal\n        \n          Defines the lower and upper\n          end of the window into which the input duty cycles are rescaled before use. The lower limit\n          must be in the range 0 to (upper limit - 0.1). Similarly the upper limit must be in the range\n          (lower limit + 0.1) to 1.0.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              OffsetParamInteger\n        \n          The desired phase offset, in\n          milliseconds, of the injector output, relative to other injector output channels\n          that have been configured with the same frequency.\n        \n        \n          Range: [0, 10000] ms\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.",
    "LLR.PLAT.PDX.PHINJOUT.114": "The block pdx_PeakHoldInjectorOutput shall support the targets:\n            None at the moment.",
    "LLR.PLAT.PDX.PHINJOUT.214": "The block pdx_PeakHoldInjectorOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.PHINJOUT.015": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.016": "If the parameter Injector channel is found in any other block in the model then\n                the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.017": "If the parameter Initial injector frequency is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.018": "If the parameter Peak default duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.019": "If the parameter Peak-hold default duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.020": "If the parameter Peak-hold initial duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.021": "If the parameter Min\/Max duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.022": "If the parameter Clock initial frequency is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.023": "If the parameter Offset is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PHINJOUT.024": "The value of inport injector_frequency  shall  be clipped to the range defined by\n                [PIO_RATE_PHINJ_INJ_MIN_HZ, PIO_RATE_PHINJ_INJ_MAX_HZ] and written to outport\n                sim_injector_frequency.",
    "LLR.PLAT.PDX.PHINJOUT.025": "The value of inport clock_frequency  shall  be clipped to the range defined by\n                [PIO_RATE_POT_MIN_HZ, PIO_RATE_POT_MAX_HZ] and written to outport\n                sim_clock_frequency.",
    "LLR.PLAT.PDX.PHINJOUT.026": "The value of inport peak_duty_cycle  shall  be clipped to the range defined by\n                Min\/Max duty cycle and written to outport\n                sim_peak_duty_cycle.",
    "LLR.PLAT.PDX.PHINJOUT.027": "The value of inport peak_hold_duty_cycle  shall  be clipped to the range defined by\n                Min\/Max duty cycle and written to outport\n                sim_peak_hold_duty_cycle.",
    "LLR.PLAT.PDX.PHINJOUT.028": "If the value of inport fault is 1 then the outport\n                sim_peak_duty_cycle  shall  be set to the mask parameter\n                Peak default duty cycle.",
    "LLR.PLAT.PDX.PHINJOUT.029": "If the value of inport fault is 1 then the outport\n                sim_peak_hold_duty_cycle  shall  be set to the mask parameter\n                Peak-hold default duty cycle.",
    "LLR.PLAT.PDX.PHINJOUT.030": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PDX.PHINJOUT.031": "The block  shall  use the mask value Injector channel as the injector output channel.",
    "LLR.PLAT.PDX.PHINJOUT.032": "At power up the block  shall  use the mask value Initial injector frequency to set\n                the injector frequency on the injector output channel.",
    "LLR.PLAT.PDX.PHINJOUT.033": "The block  shall  use the inport value injector_frequency to update the injector frequency\n                on the injector output channel.",
    "LLR.PLAT.PDX.PHINJOUT.034": "The block  shall  use the inport value clock_frequency to update the clock frequency\n                on the injector output channel.",
    "LLR.PLAT.PDX.PHINJOUT.035": "The block  shall  use the inport value peak_duty_cycle to update the peak duty cycle\n                on the injector output channel if the inport\n                fault is false or use the mask value\n                Peak default duty cycle otherwise.",
    "LLR.PLAT.PDX.PHINJOUT.036": "The block  shall  use the inport value peak_hold_duty_cycle to update the peak hold duty cycle\n                on the injector output channel if the inport\n                fault is false or use the mask value\n                Peak hold default duty cycle otherwise.",
    "LLR.PLAT.PDX.PHINJOUT.037": "The block  shall  use the parameter value Offset to update the offset\n                used by the injector output.",
    "LLR.APP.PDX.HBRIDGE.001": "The application  will  invoke an interface during application\n              initialisation to declare H-Bridge output channels whose mode,\n              duty and frequency may be set during run time.",
    "LLR.PLAT.PDX.HBRIDGE.001": "During or after application initialisation, the platform\n               shall  ensure the hardware is correctly initialised to set\n              H-Bridge output channels declared by the application.",
    "LLR.PLAT.PDX.HBRIDGE.002": "The initialisation process  shall  set the H-Bridge output\n              channels to the given mode, duty cycle and frequency.",
    "LLR.PLAT.PDX.HBRIDGE.003": "During application run time, the platform  shall  update the H-Bridge\n              output channel period counters at a rate which permits the output\n              frequency range defined in the technical specification document.",
    "LLR.PLAT.PDX.HBRIDGE.024": "During application run time, the platform  shall  disable the H-Bridge\n              output channel to protect the hardware circuitry, as described by\n              the targets HSIS.",
    "LLR.PLAT.PDX.HBRIDGE.004": "The platform shall provide a C interface function named\n                pdx_hbridge_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan_hbridge\n          in\n        PDX_LCHAN_HBRIDGE_T\nThe group of channels used to control the H-Bridge. Use the macros included by the pio.h file, of the form PIO_HBOT_[NAME]pdxf_mode\n          in\n        PIO_HBRIDGE_MODE_T\nThe H-bridge mode to use. Any of: \nPIO_HBRIDGE_MODE_NO_DRIVE - No DrivePIO_HBRIDGE_MODE_BRAKE - BrakePIO_HBRIDGE_MODE_FORWARD - Forward drivePIO_HBRIDGE_MODE_REVERSE - Reverse drive\npdxf_freq\n          in\n        F32\nThe desired frequency of the output. If the software cannot match the desired frequency, the frequency will be adjusted to as close a match as is possible. \n Range: [0.5, 10000] Hzpdxf_duty\n          in\n        F32\nThe desired duty cycle of the PWM output. If the software cannot match the desired duty cycle, the frequency will be adjusted to as close a match as is possible. Some channels cannot achieve very low or very high duty cycles accurately (although 0% and 100% is correctly handled when the H-Bridge is not switching sides - see Note below) and will introduce jitter into the signal. It is up to the caller to ensure this condition does not arise. \n Range: [0, 1] unitlesspdxf_last_mode_ptr\n          in\/out\n        PIO_HBRIDGE_MODE_T *\nThe value of pdxf_mode for this call is written through this pointer. It is the value to be passed as pdxf_mode next time the function is called.\n Cannot be NULL.pdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel group not supported or channels not on same devicePDX_RC_BAD_ARGS - configuration errorPDX_RC_FREQ_TOO_HIGH - frequency is higher than supported frequencyPDX_RC_FREQ_TOO_LOW - frequency is lower than supported frequencyPDX_RC_DUTY_OUT_OF_RANGE - duty cycle is outside [0, 1] range",
    "LLR.PLAT.PDX.HBRIDGE.104": "The function pdx_hbridge_output() shall support the targets:\n                      M220-000, M250-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.HBRIDGE.204": "The function pdx_hbridge_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.HBRIDGE.006": "The function  shall  reject a logical channel group which\n                cannot be mapped to potential hardware outputs by\n                returning PDX_RC_BAD_ARGS.",
    "LLR.PLAT.PDX.HBRIDGE.007": "The function  shall  reject a logical channel group which\n                does map onto a set of potential hardware outputs of which\n                at least one is invalid by returning PDX_RC_BAD_ARGS.",
    "LLR.PLAT.PDX.HBRIDGE.008": "The function  shall  clip the pdxf_freq parameter to the nearest\n                limit if it falls outside the frequency range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.HBRIDGE.009": "The function  shall  clip the pdxf_duty parameter to the nearest\n                limit if it falls outside the duty cycle range specified in the\n                technical specification document.",
    "LLR.PLAT.PDX.HBRIDGE.010": "If the interface parameter checks pass and the required mode is\n                'no drive' then the function  shall  allow both left-hand and\n                right-hand H-Bridge outputs to float.",
    "LLR.PLAT.PDX.HBRIDGE.011": "If the interface parameter checks pass and the required mode is\n                'brake' then the function  shall  set both left-hand and\n                right-hand H-Bridge outputs to battery voltage.",
    "LLR.PLAT.PDX.HBRIDGE.012": "If the interface parameter checks pass and the required mode is\n                'forward' then the function  shall  set the left-hand H-Bridge\n                output to battery voltage, and output a square wave on the\n                right-hand H-Bridge output at the required frequency with the\n                proportion of time at the ground level equal to the required\n                duty cycle.",
    "LLR.PLAT.PDX.HBRIDGE.013": "If the interface parameter checks pass and the required mode is\n                'reverse' then the function  shall  output a square wave on the\n                left-hand H-Bridge output at the required frequency with the\n                proportion of time at the ground level equal to the required\n                duty cycle, and set the right-hand H-Bridge output to battery\n                voltage.",
    "LLR.PLAT.PDX.HBRIDGE.023": "If the application requests a mode transition, the platform  shall  ensure\n                that both the high and low side gates are commanded off for at least\n                100us for one task iteration or one PWM cycle, whichever is longer.\n                \n                  Rationale: The HSIS requires that when switching from high side to\n                  low side operation, the mode select signal should only be switched\n                  when the PWM signal has been off (low) for at least 100us.",
    "LLR.PLAT.PDX.HBRIDGE.014": "The platform shall provide a Simulink interface block named\n                pdx_HBridgeOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionmodeInportInteger\n        \n          Mode in which the H-bridge will operate.\n        \n        \n          Range: [0, 3] respectively for No Drive \/ Brake \/ Forward \/ Reverse.\n        \n      frequencyInportReal\n        \n          Frequency of the PWM signal\n        \n        \n          Range: [0.5, 10000] Hz (for M220, M250, M550 and M670 targets)\n        \n      duty-cycleInportReal\n        \n          Ratio of the drive time to the signal cycle time.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      ChannelsParamList\n        \n          The pair of input pins sourcing the signal to measure.\n        \n      \n                Calibratable: no.\n              Initial modeParamList\n        \n          The initial mode of operation used whilst the application is initialising.\n        \n        \n          Range: [No Drive, Brake, Forward, Reverse] (for M220, M250, M550 and M670 targets)\n        \n      \n                Calibratable: no.\n              Initial frequencyParamReal\n        \n          The initial frequency used whilst the application is initialising.\n        \n        \n          Range: [0.5, 10000] Hz (for M220, M250, M550 and M670 targets)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Initial duty cycleParamReal\n        \n          The initial duty cycle used whilst the appplication is initialising.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up).",
    "LLR.PLAT.PDX.HBRIDGE.114": "The block pdx_HBridgeOutput shall support the targets:\n            M220-000, M250-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.HBRIDGE.214": "The block pdx_HBridgeOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.HBRIDGE.015": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.HBRIDGE.016": "If the parameter Initial frequency is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.HBRIDGE.017": "If the parameter Initial duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.HBRIDGE.018": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PDX.HBRIDGE.019": "At initialisation the channel, frequency and initial duty cycle defined by the mask\n                Channels,\n                Initial mode,\n                Initial Frequency and\n                Initial duty cycle  shall  be written to the block.",
    "LLR.PLAT.PDX.HBRIDGE.020": "The block  shall  update the H-Bridge mode on the output channel defined by\n                the mask  Channels with the setting on the inport,\n                mode.",
    "LLR.PLAT.PDX.HBRIDGE.021": "The block  shall  update the H-Bridge frequency on the output channel defined by\n                the mask  Channels with the setting on the inport,\n                frequency.",
    "LLR.PLAT.PDX.HBRIDGE.022": "The block  shall  update the H-Bridge duty cycle on the output channel defined by\n                the mask  Channels with the setting on the inport,\n                duty_cycle.",
    "LLR.APP.PDX.PWMOUT.001": "The application  will  invoke an interface during application initialisation to declare\n              PWM output channels whose duty, frequency and offset may be set during run time.",
    "LLR.PLAT.PDX.PWMOUT.001": "During or after application initialisation, the platform  shall  ensure the hardware is\n              correctly initialised to set PWM output channels declared by the application.\n            Note: \n              Currently, there are no requirements for the platform to recognise duplicated channels\n              declared by the application (this may change in the future if we can find an efficient way\n              to implement such a requirement). If the application declares a logical channel more than\n              once then the behaviour of the platform is undefined.",
    "LLR.PLAT.PDX.PWMOUT.002": "The initialisation process  shall  set the PWM output channel to the given duty cycle,\n              frequency and offset.",
    "LLR.PLAT.PDX.PWMOUT.003": "During application run time, the platform  shall  update the PWM output channel period\n              counters at a rate which permits the output frequency range defined in the technical\n              specification document.",
    "LLR.PLAT.PDX.PWMOUT.012": "The platform  shall  interpret requests for 0% and 100% duty cycle output signals as\n              as not driven and constantly driven\n              outputs respectively.",
    "LLR.PLAT.PDX.PWMOUT.008": "The platform  shall  clip the duty cycle to the nearest\n              limit if it falls outside the allowed duty cycle range.",
    "LLR.PLAT.PDX.PWMOUT.007": "The platform  shall  clip the frequency to the nearest\n              limit if it falls outside the allowed frequency range.",
    "LLR.PLAT.PDX.PWMOUT.024": "The platform  shall  clip the offset to the nearest\n              limit if it falls outside the offset range.",
    "LLR.PLAT.PDX.PWMOUT.030": "The PWM update  shall  be buffered such that updates are stored until the current period is complete.\n              For example if the frequency was 0.5Hz the period would be 2s and an update within this 2 seconds would not be applied\n              until the end of the 2 second period.",
    "LLR.PLAT.PDX.PWMOUT.004": "The platform shall provide a C interface function named\n                pdx_pwm_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpdxf_lchan\n          in\n        PDX_LCHAN_T\nThe digital channel to use as a PWM output. Use the macros included by the pio.h file, of the form PIO_POT_[NAME].pdxf_freq\n          in\n        F32\nThe desired frequency of the output. If the software cannot match the desired frequency, the frequency will be adjusted to as close a match as is possible.\n If the frequency is outside of the allowed range, then it will be clipped to the allowed range and and either PDX_RC_FREQ_TOO_LOW or PDX_RC_FREQ_TOO_HIGH returned as appropriate. \n Range: [0.5, 10000] Hzpdxf_duty\n          in\n        F32\nThe desired duty cycle of the PWM output. This is the fraction of the period (1 \/ pdxf_freq) which the output will be active. For low-side outputs this is the period that the output is pulled to ground and for high-side outputs this is the time the output will be pulled to supply voltage.\n\n When the output is inactive, the output will be in a high-impedence state.\n\n If the software cannot match the desired duty cycle, the frequency will be adjusted to as close a match as is possible. Some channels cannot achieve very low or very high duty cycles accurately (although 0% and 100% is correctly handled) and will introduce jitter into the signal. It is up to the caller to ensure this condition does not arise. \n Range: [0, 1] unitlesspdxf_offset\n          in\n        F32\nThe desired phase offset of the PWM output, relative to other PWM output channels that have been configured with the same frequency. This Range: [0, 2000] mspdxf_init\n          in\n        BOOL\nTrue if the channel is to be initialised, false otherwise.\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_HW_ERROR - if error initialising channelPDX_RC_BAD_ARGS - configuration errorPDX_RC_SDM_ALLOC_ERROR - error allocating ram in SDMPDX_RC_FREQ_TOO_LOW - frequency to slow for target, frequency will be clipped to minimum allowed.PDX_RC_FREQ_TOO_HIGH - frequency to quick for target, frequency will be clipped to maximum allowed.",
    "LLR.PLAT.PDX.PWMOUT.104": "The function pdx_pwm_output() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.PWMOUT.204": "The function pdx_pwm_output() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PDX.PWMOUT.006": "The function  shall  reject a logical channel pdxf_lchan which cannot\n                be mapped to a potential hardware output by returning PDX_RC_BAD_ARGS, it  shall  also raise\n                recoverable error PSY_PDX\/pdxf_lchan + PDX_PWM_OUT_CHANNEL_UNSUPPORTED or\n                PSY_PDX\/pdxf_lchan + PDX_CHANNEL_INVALID depending on which function traps the error.",
    "LLR.PLAT.PDX.PWMOUT.028": "When the init parameter is set to TRUE the platform  shall  be initialised and enabled\n                with the specified channel, duty cycle, frequency and offset.",
    "LLR.PLAT.PDX.PWMOUT.029": "When the init parameter set to FALSE the platform  shall  be updated with the specified channel,\n                duty cycle, frequency and offset.",
    "LLR.PLAT.PDX.PWMOUT.011": "The platform shall provide a Simulink interface block named\n                pdx_PWMOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionduty_cycleInportReal\n        \n          Ratio of the\n          high time to the signal cycle time.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      faultInportBoolean\n        \n          Place a 1 here to\n          force the block to use the default duty cycle for the output, 0\n          otherwise.\n        \n        \n          Range: 0 or 1\n        \n      sim_duty_cycleOutportReal\n        \n          Only used in simulation. this\n          outport is set to the requested duty cycle (i.e., duty_cycle or the\n          default duty cycle).\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      ChannelParamList\n        \n          The channel pin for this pwm output.\n        \n      \n                Calibratable: no.\n              InversionParamBoolean\n        \n          Inverts the mapping of the\n          input value to the channel pin. If inversion is ticked then a logical NOT\n          operation is applied to the output state.\n        \n      \n                Calibratable: no.\n              Default duty cycleParamReal\n        \n          This value is used if fault is active. The value is mapped directly to the\n          output channel and is never inverted. Care should be taken to choose the\n          appropriate value to drive the output off.\n        \n        \n          Range: 0 or 1 duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Initial duty cycleParamReal\n        \n          The duty cycle that\n          is output before the block has first been executed. This value is used in a similar way to\n          Default duty cycle in that it is never inverted, however it can be set\n          anywhere in the range 0 to 1.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              FrequencyParamReal\n        \n          The frequency of the pwm signal.\n        \n        \n          Range: [0.5, 10000] Hz\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              OffsetParamReal\n        \n          The desired phase offset, in milliseconds,\n          of the PWM output, relative to other PWM output channels that have been configured with\n          the same frequency.\n        \n        \n          Range: [0, 2000] ms (for the M250, M460 targets)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Minimum duty cycleParamReal\n        \n          Must be in the\n          range 0 to (Maximum duty cycle - 0.1).\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Maximum duty cycleParamReal\n        \n          Must be in the\n          range (Minimum duty cycle + 0.1) to 1.0.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Provide simulation output?ParamBoolean\n        \n          Tick to enable outport sim_duty_cycle.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.PWMOUT.111": "The block pdx_PWMOutput shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.PWMOUT.211": "The block pdx_PWMOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.PWMOUT.013": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.014": "If the parameter Default duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.015": "If the parameter Initial duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.016": "If the parameter Minimum duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.017": "If the parameter Maximum duty cycle is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.018": "If the parameter Minimum duty cycle is not less than\n                Maximum duty cycle, then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.019": "If the parameter Frequency is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.045": "If the parameter Offset is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.020": "If the parameter Channel is found in any other block in the model\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.021": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PDX.PWMOUT.022": "An option  shall  be available to provide a simulation output on the block.",
    "LLR.PLAT.PDX.PWMOUT.044": "The block  shall  scale the duty cycle within the values defined by the mask parameters\n                Minimum duty cycle and\n                Maximum duty cycle as follows:\n                output duty cycle = Minimum duty cycle +\n                (Maximum duty cycle -\n                Minimum duty cycle) *\n                duty_cycle.",
    "LLR.PLAT.PDX.PWMOUT.023": "If mask parameter Provide simulation output?\n                is true, the block  shall  set the value of the outport sim_duty_cycle\n                to the scaled duty cycle when inport\n                fault is false or to\n                default duty cycle otherwise.",
    "LLR.PLAT.PDX.PWMOUT.025": "At initialisation the channel, frequency and initial duty cycle defined by the mask\n                Channel,\n                Frequency,\n                Offset and\n                Initial duty cycle  shall  be written to the block.",
    "LLR.PLAT.PDX.PWMOUT.026": "The block  shall  scale the duty cycle within the values defined by the mask parameters\n                Minimum duty cycle and\n                Maximum duty cycle as follows:\n                output duty cycle = Minimum duty cycle +\n                (Maximum duty cycle -\n                Minimum duty cycle) *\n                duty_cycle.",
    "LLR.PLAT.PDX.PWMOUT.027": "The block  shall  invert the duty_cycle according to the mask parameter\n                Inversion.",
    "LLR.PLAT.PDX.PWMOUT.031": "The block  shall  update the duty cycle with the scaled duty cycle on the output channel defined by\n                the mask  Channel if the inport\n                fault is false or use the mask value\n                Default duty cycle with no scaling otherwise.",
    "LLR.PLAT.PDX.PWMOUT.032": "The platform shall provide a Simulink interface block named\n                pdx_PWMVariableFrequencyOutput that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionduty_cycleInportReal\n        \n          Ratio of the\n          high time to the signal cycle time.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      frequencyInportReal\n        \n          Frequency of the\n          signal.\n        \n        \n          Range: [0.5, 10000] Hz\n        \n      faultInportReal\n        \n          Place a 1 here to force the block\n          to use the default frequency and duty cycle for the output, 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      sim_duty_cycleOutportReal\n        \n          Only used in simulation. this\n          outport is set to the processed duty cycle (i.e., duty_cycle or Initial duty cycle).\n        \n      sim_frequencyOutportReal\n        \n          Only used in simulation. This\n          outport is set to the processed frequency.\n        \n      ChannelParamList\n        \n          The channel pin for this pwm output.\n        \n      \n                Calibratable: no.\n              InversionParamBoolean\n        \n          Inverts the mapping of the\n          input value to the channel pin. If inversion is set to 1 then a logical NOT\n          operation is applied to the output state.\n        \n      \n                Calibratable: no.\n              Default duty cycleParamReal\n        \n          This is the\n          duty cycle of the channel when inport fault is set. The duty cycle\n          is mapped directly to the output channel and is not inverted by parameter\n          Inversion.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Initial duty cycleParamReal\n        \n          The duty cycle\n          of the channel signal before the block has first been executed. This duty cycle\n          is inverted if the mask parameter Inversion is set to 1.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Initial frequencyParamReal\n        \n          The frequency of the\n          PWM signal before the block first iterates.\n        \n        \n          Range: [0.5, 10000] Hz\n        \n      \n                Calibratable: used during initialisation (power-up).\n              OffsetParamReal\n        \n          The desired phase offset, in milliseconds,\n          of the PWM output, relative to other PWM output channels that have been configured with\n          the same frequency.\n        \n        \n          Range: [0, 2000] ms (for the M250, M460 targets)\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Minimum duty cycleParamReal\n        \n          Must be in the\n          range 0 to (Maximum duty cycle - 0.1).\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Maximum duty cycleParamReal\n        \n          Must be in the\n          range (Minimum duty cycle + 0.1) to 1.0.\n        \n        \n          Range: [0, 1] duty-cycle\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Provide simulation output?ParamBoolean\n        \n          Tick to enable outport sim_duty_cycle and sim_frequency.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PDX.PWMOUT.132": "The block pdx_PWMVariableFrequencyOutput shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PDX.PWMOUT.232": "The block pdx_PWMVariableFrequencyOutput shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PDX.PWMOUT.033": "If the parameter Initial frequency is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PDX.PWMOUT.034": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PDX.PWMOUT.035": "If parameter, Provide simulation output?\n                is true then 2 outports  shall  appear on the block, sim_duty_cycle and\n                sim_frequency.",
    "LLR.PLAT.PDX.PWMOUT.036": "The outport sim_duty_cycle  shall  be provided as it would appear on the target dependant on the mask\n                parameters and min\/max frequency allowed.",
    "LLR.PLAT.PDX.PWMOUT.037": "The outport sim_frequency  shall  be provided as it would appear on the target dependant on the mask\n                parameters and min\/max frequency allowed.",
    "LLR.PLAT.PDX.PWMOUT.038": "The simulation outports, sim_duty_cycle and\n                sim_frequency  shall  update to the\n                default duty cycle and\n                Initial frequency defined in the mask if the inport\n                fault is set active.",
    "LLR.PLAT.PDX.PWMOUT.039": "At initialisation the channel, duty cycle and frequency defined by the mask\n                Channel,\n                Initial duty cycle,\n                Offset and\n                Initial frequency  shall  be set.",
    "LLR.PLAT.PDX.PWMOUT.041": "The block  shall  update the duty cycle with the value defined by the inport\n                duty_cycle on the output channel defined by the mask\n                Channel.",
    "LLR.PLAT.PDX.PWMOUT.042": "The block  shall  update the frequency with the value defined by the inport\n                frequency on the output channel defined by the mask\n                Channel.",
    "LLR.PLAT.PDX.PWMOUT.043": "The block  shall  update the duty cycle and frequency on the output channel defined by the mask\n                Channel with the default values defined in the mask\n                if the inport fault is set active.",
    "LLR.PLAT.PEF.INIT.001": "The platform  shall  implement a C function named\n              pef_pre_initialise() with no parameters and\n              no return value. The function shall be called\n              at platform initialisation and will not be\n              available through the C-API.",
    "LLR.PLAT.PEF.STATUS.001": "The platform shall provide a C interface function named\n                pef_read_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpeff_status\n          out\n        U8 *\nSet to the status byte read from the device, use the PEF_STATUS_xxx macros to mask the required bits\n                The function returns a value of type\n                PEF_RC_T\n                with a value of:\n              PEF_RC_OK - if status read ok PEF_RC_ERR_NOT_AVAILABLE - if no device detected",
    "LLR.PLAT.PEF.STATUS.101": "The function pef_read_status() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.STATUS.201": "The function pef_read_status() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.STATUS.002": "The interface function  shall  return PEF_RC_OK if\n              status read ok  or one of the other PEF_RC_T return codes otherwise.",
    "LLR.PLAT.PEF.STATUS.004": "The function  shall  reject an attempt to read the\n              status if the pointer provided is NULL.",
    "LLR.PLAT.PEF.STATUS.005": "Reads the current status value from the flash device and\n            returns it to the client. This status is a bitfield\n            that can be masked to determine details about the\n            device.\n          \n            The pef_busy function utilises this function to determine\n            if the device is busy performing a previously requested\n            operation.",
    "LLR.PLAT.PEF.BUSY.001": "The platform shall provide a C interface function named\n                pef_busy() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE if the device is busy, ie a write or erase operation is in progress. FALSE otherwise, or no device is present!",
    "LLR.PLAT.PEF.BUSY.101": "The function pef_busy() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.BUSY.201": "The function pef_busy() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.BUSY.002": "The interface function  shall  return a\n              boolean flag indicating the busy status.",
    "LLR.PLAT.PEF.BUSY.003": "Uses the pef_read_status function to read the status value and\n            returns TRUE if the 'write in progress' bit is set, otherwise\n            returns FALSE.",
    "LLR.PLAT.PEF.BUSY.004": "The function does not return the standard results code, just a boolean.\n            For this reason if PEF is not available a non-busy indication  will  result.",
    "LLR.PLAT.PEF.READ.001": "The platform shall provide a C interface function named\n                pef_read() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpeff_addr\n          in\n        U32\nAddress in the device for data to be read from Range: [0, 2097150]peff_size\n          in\n        U16\nSize of data to read, in bytes Range: [2, 2097152]peff_data\n          in\n        U8 *\nPointer to data structure to populate\n                The function returns a value of type\n                PEF_RC_T\n                with a value of:\n              PEF_RC_OK - if data read ok PEF_RC_ERR_NOT_AVAILABLE - if no device detected PEF_RC_ERR_BUSY - if some previous write\/erase operation is already in progress PEF_RC_ERR - peff_data is a NULL pointer PEF_RC_ERR_SIZE - if the size is not a multiple of 2 bytes PEF_RC_ERR_ALIGNMENT - if the address is not word aligned PEF_RC_ERR_ADDR_RANGE - if address is or would go out of range",
    "LLR.PLAT.PEF.READ.101": "The function pef_read() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.READ.201": "The function pef_read() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.READ.002": "The interface function  shall  return PEF_RC_OK if\n              the block of data was read from the flash device or\n              one of the other PEF_RC_T return codes otherwise.",
    "LLR.PLAT.PEF.READ.003": "The function  shall  reject an attempt to read the\n              block of data if the feature has determined that\n              no suitable flash device exists, determined at the\n              time of initialisation.",
    "LLR.PLAT.PEF.READ.004": "The function  shall  reject an attempt to read the\n              block of data if the flash device is busy (performing\n              a previous read or erase operation).",
    "LLR.PLAT.PEF.READ.005": "The function  shall  reject an attempt to read the\n              block of data if the pointer provided is NULL.",
    "LLR.PLAT.PEF.READ.006": "The function  shall  reject an attempt to read the\n              block of data if the size is not a multiple of 2.",
    "LLR.PLAT.PEF.READ.007": "The function  shall  reject an attempt to read the\n              block of data if the address is NOT word aligned\n              (ie an even number).",
    "LLR.PLAT.PEF.READ.008": "The function  shall  reject an attempt to read the\n              block of data if the data does not fit within the\n              available flash space, based on the supplied address\n              and the size of the data.",
    "LLR.PLAT.PEF.READ.009": "The platform  shall  extract the block of data from\n              the given address within the flash device to the\n              client-supplied buffer.",
    "LLR.PLAT.PEF.WRITE.001": "The platform shall provide a C interface function named\n                pef_write() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpeff_addr\n          in\n        U32\nAddress in the device to write data to Range: [0, 2097150]peff_size\n          in\n        U16\nSize of data to write, in bytes Range: [2, 2097152]peff_data\n          out\n        const U8 *\nPointer to data to copy to flash memory\n                The function returns a value of type\n                PEF_RC_T\n                with a value of:\n              PEF_RC_OK - if data written ok PEF_RC_ERR_NOT_AVAILABLE - if no device detected PEF_RC_ERR_BUSY - if some previous write\/erase operation is already in progress PEF_RC_ERR - peff_data is a NULL pointer, or a timeout occurred when writing PEF_RC_ERR_SIZE - if the size is not a multiple of 2 bytes PEF_RC_ERR_ALIGNMENT - if the address is not word aligned PEF_RC_ERR_ADDR_RANGE - if address is or would go out of range",
    "LLR.PLAT.PEF.WRITE.101": "The function pef_write() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.WRITE.201": "The function pef_write() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.WRITE.002": "The interface function  shall  return PEF_RC_OK if\n              the block of data was sent to the flash device or\n              one of the other PEF_RC_T return codes otherwise.",
    "LLR.PLAT.PEF.WRITE.003": "The function  shall  reject an attempt to write the\n              block of data if the feature has determined that\n              no suitable flash device exists, determined at the\n              time of initialisation.",
    "LLR.PLAT.PEF.WRITE.004": "The function  shall  reject an attempt to write the\n              block of data if the flash device is busy (performing\n              a previous write or erase operation).",
    "LLR.PLAT.PEF.WRITE.005": "The function  shall  reject an attempt to read the\n              block of data if the pointer provided is NULL.",
    "LLR.PLAT.PEF.WRITE.006": "The function  shall  reject an attempt to write the\n              block of data if the size is not a multiple of 2.",
    "LLR.PLAT.PEF.WRITE.007": "The function  shall  reject an attempt to write the\n              block of data if the address is NOT word aligned\n              (ie an even number).",
    "LLR.PLAT.PEF.WRITE.008": "The function  shall  reject an attempt to write the\n              block of data if the data does not fit within the\n              available space, based on the supplied address\n              and the size of the data.",
    "LLR.PLAT.PEF.WRITE.009": "The platform  shall  copy the block of source data\n              provided by the client to the flash device such\n              that it can be subsequently retreived using\n              pef_read() or pef_block_read(). Note: Verfication\n              is not performed as part of the PEF feature.",
    "LLR.PLAT.PEF.ERASESECTOR.001": "The platform shall provide a C interface function named\n                pef_erase_sector() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpeff_addr\n          in\n        U32\nAddress in the sector of the device to erase Range: [0, 2097151]\n                The function returns a value of type\n                PEF_RC_T\n                with a value of:\n              PEF_RC_OK - if sector erase request sent ok PEF_RC_ERR_NOT_AVAILABLE - if no device detected PEF_RC_ERR_BUSY - if some previous write\/erase operation is already in progress PEF_RC_ERR_ADDR_RANGE - if address is out of range",
    "LLR.PLAT.PEF.ERASESECTOR.101": "The function pef_erase_sector() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.ERASESECTOR.201": "The function pef_erase_sector() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.ERASESECTOR.002": "The interface function  shall  return PEF_RC_OK if\n              the erase request was sent to the flash device or\n              one of the other PEF_RC_T return codes otherwise.",
    "LLR.PLAT.PEF.ERASESECTOR.003": "The function  shall  reject an attempt to erase a\n              sector if the feature has determined that\n              no suitable flash device exists, determined at the\n              time of initialisation.",
    "LLR.PLAT.PEF.ERASESECTOR.004": "The function  shall  reject an attempt to erase a\n              sector if the flash device is busy (performing\n              a previous write or erase operation).",
    "LLR.PLAT.PEF.ERASESECTOR.005": "The function  shall  reject an attempt to erase a\n              sector if the address is not within the address\n              range of the device.",
    "LLR.PLAT.PEF.ERASESECTOR.006": "The platform  shall  request the nominated flash\n              sector to be erased. The erase operation is\n              handled by the flash device in the background\n              and therefore does not delay the processor. The\n              client can use pef_busy() to determine if the\n              operation has completed prior to issuing another\n              erase or further read and\/or write requests.\n              Note: Any address within a sector can be given to\n              identify the sector to be erased!",
    "LLR.PLAT.PEF.ERASEALL.001": "The platform shall provide a C interface function named\n                pef_erase_all() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PEF_RC_T\n                with a value of:\n              PEF_RC_OK - if bulk erase request sent ok PEF_RC_ERR_NOT_AVAILABLE - if no device detected PEF_RC_ERR_BUSY - if some previous write\/erase operation is already in progress",
    "LLR.PLAT.PEF.ERASEALL.101": "The function pef_erase_all() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.ERASEALL.201": "The function pef_erase_all() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.ERASEALL.002": "The interface function  shall  return PEF_RC_OK if\n              the erase request was sent to the flash device or\n              one of the other PEF_RC_T return codes otherwise.",
    "LLR.PLAT.PEF.ERASEALL.003": "The function  shall  reject an attempt to erase the\n              entire device if the feature has determined that\n              no suitable flash device exists, determined at the\n              time of initialisation.",
    "LLR.PLAT.PEF.ERASEALL.004": "The function  shall  reject an attempt to erase the\n              entire device if the flash device is busy (performing\n              a previous write or erase operation).",
    "LLR.PLAT.PEF.ERASEALL.005": "The platform  shall  request the device to perform\n              an erase all operation (known as a bulk erase).\n              The erase operation is handled by the flash device\n              in the background and therefore does not delay the\n              processor. The client can use pef_busy() to determine\n              if the operation has completed prior to issuing another\n              erase or further read and\/or write requests.",
    "LLR.PLAT.PEF.CCP.001": "The platform  shall  implement support for the UPLOAD and SHORT UPLOAD\n              CCP commands directly in the CCP feature and thus will not have a C\n              API function. These two commands will allow a CCP tool to perform an\n              upload of external flash data.",
    "LLR.PLAT.PEF.CCP.002": "The platform  shall  implement support for the SETMTA CCP command\n              directly in the CCP feature and thus will not have a C\n              API function. This command will allow a CCP tool to specify a\n              starting address of subsequent upload of data from the external\n              flash device.\n            \n              Because the device is actually addressed through the SPI bus, rather\n              than being mapped into the processors address space like normal memory,\n              a virtual addressing scheme is required. By adding 0x1000000 to the\n              address to be accessed in the flash device the CCP driver can make the\n              distiction between flash access and normal memory access.",
    "LLR.PLAT.PEF.ISAVAIL.001": "The platform shall provide a C interface function named\n                pef_is_available() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE if the expected flash device is detected",
    "LLR.PLAT.PEF.ISAVAIL.101": "The function pef_is_available() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.ISAVAIL.201": "The function pef_is_available() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.ISAVAIL.002": "The interface function  shall  return TRUE if a\n              suitable device is present, FALSE otherwise.",
    "LLR.PLAT.PEF.IDENT.001": "The platform shall provide a C interface function named\n                pef_get_identification() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpeff_identification\n          out\n        PEF_IDENTIFICATION_T *\nIdentification information read from the flash device, 0xFFs returned if not present\n                The function returns void.",
    "LLR.PLAT.PEF.IDENT.101": "The function pef_get_identification() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.IDENT.201": "The function pef_get_identification() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.IDENT.002": "The interface function  shall  return the identification\n              information.",
    "LLR.PLAT.PEF.IDENT.003": "The identifiaction information  shall  consist of three byte\n                long fields for the manufacturer id, memory type and memory\n                capacity.",
    "LLR.PLAT.PEF.LOCK.001": "The platform shall provide a C interface function named\n                pef_get_lock() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE if lock was available, FALSE otherwise",
    "LLR.PLAT.PEF.LOCK.101": "The function pef_get_lock() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.LOCK.201": "The function pef_get_lock() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.LOCK.002": "The interface function  shall  return a boolean flag\n              indicating if the lock has been gained (TRUE) or not\n              (FALSE).",
    "LLR.PLAT.PEF.LOCK.003": "The lock\/release mechanism is designed to guard against two\n                or more clients attempting access to the external flash\n                device at the same time. If this were to occur there is\n                a possibility that the SPI data transfers could be\n                corrupted with notable side effects (such as corruption\n                of data during writing, invalid data being retured when\n                read or an erase operation not being performed).\n              \n                This function  will  suspend the scheduler and resume it on\n                completion so as to gaurd against two requests being made at\n                the same time.\n              \n                It is important to note that just because a lock has been\n                accessed that no other PEF calls can be made outside of the\n                lock ownership. That is the responsibility of the clients\n                of the PEF feature.",
    "LLR.PLAT.PEF.RELEASE.001": "The platform shall provide a C interface function named\n                pef_release_lock() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PEF.RELEASE.101": "The function pef_release_lock() shall support the targets:\n                      None at the moment.",
    "LLR.PLAT.PEF.RELEASE.201": "The function pef_release_lock() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PEF.RELEASE.002": "The interface function  shall  clear the internal\n              access locked flag.",
    "LLR.PLAT.PEM.XETK.001": "The platform  shall  attempt to detect and initialize an XETK if and only if the\n              an entry exists in the embedded registry which indicates that the XETK\n              functionality is desired.\n            Rationale: \n              The OpenECU hardware was not designed with XETK support as a requirement.  As\n              a result, detection of the XETK can incur a significant delay in initialisation.",
    "LLR.PLAT.PEM.XETK.002": "The platform  shall  delay application execution until the XETK signals that\n              it has finished its own initialization, or a fixed timeout is reached.",
    "LLR.PLAT.PEM.XETK.003": "The platform  shall  detect and utilize external calibration RAM provided on the XETK\n              independent of the other XETK functionality, as determined by the memory configuration\n              selected in the application.",
    "LLR.PLAT.PEM.XETK.004": "The platform  shall  honor requests from the XETK to switch between the reference\n              page and the working page.",
    "LLR.PLAT.PEM.XETK.005": "The platform  shall  support a direct measurement raster for each application\n              periodic task.",
    "LLR.PLAT.PFC.FL.001": "The software  shall  turn the happy light off for 1 second\n              (the digit mark).",
    "LLR.PLAT.PFC.FL.002": "For the first digit, d1, the software  shall  then turn\n              the happy light output off for 0.5 seconds then on for\n              0.5 seconds, a number of times equal to the digit.",
    "LLR.PLAT.PFC.FL.003": "The software  shall  then repeat the process\n              (llr[LLR.PLAT.PFC.FL.001] and llr[LLR.PLAT.PFC.FL.002]),\n              with digit d2.",
    "LLR.PLAT.PFC.FL.004": "The software  shall  then repeat the process\n              (llr[LLR.PLAT.PFC.FL.001] and llr[LLR.PLAT.PFC.FL.002]),\n              with digit d3.",
    "LLR.PLAT.PFC.FL.005": "The software  shall  provide a log that can hold up to 20\n              flash codes.",
    "LLR.PLAT.PFC.FL.006": "The software  shall  empty the log whenever reprogramming\n              mode or application mode is started.",
    "LLR.PLAT.PFC.FL.007": "As a condition (see llr[LLR.PLAT.PFC.FL.012] and\n              llr[LLR.PLAT.PFC.FL.013]) with a corresponding flash\n              code is detected, the software  shall  add the\n              corresponding flash code to the log unless the log is\n              full (in which case the flash code is ignored).\n            Note: \n              There is no corresponding functional point to remove\n              flash codes from the log.",
    "LLR.PLAT.PFC.FL.008": "If the log is empty, the software  shall  act as if the\n              log contained the flash code \u2018111\u2019.\n            Rationale: \n              One purpose of the happy light is to indicate to the\n              user that the ECU is functioning in some mode. If the\n              happy light never toggles, there is no active indication\n              that the ECU software is functioning.",
    "LLR.PLAT.PFC.FL.009": "The software  shall  display each flash code from the log\n              in the order the flash code was added to the log.\n            Rationale: \n              Flashing each code in order, provides an ordered view of\n              the conditions which lead up to the code being\n              generated, which may prove useful when diagnosing\n              issues.",
    "LLR.PLAT.PFC.FL.010": "Prior to displaying the first code in the log, the\n              software  shall  turn the happy light output on for 3\n              seconds (the start of log mark).",
    "LLR.PLAT.PFC.FL.011": "After each displayed flash code, the software  shall \n              turn the happy light output off for 3 seconds (the end\n              of code mark).",
    "LLR.PLAT.PFC.FL.012": "When the software is in reprogramming\n              mode, the software  shall  detect the following flash code\n              conditions:\n            Condition (reprogramming mode)Flash codeIn reprogramming mode \u2013 no other condition\n                    has been detected111Entered reprogramming mode with the FEPS\n                    input negative112Entered reprogramming mode with the FEPS\n                    input high113Entered reprogramming mode via a FEPS-less\n                    reprogramming request114Entered reprogramming mode as no valid\n                    application code exists115Entered reprogramming mode due to FEPS\n                    hardware failure.116Entered reprogramming mode due to repeated\n                    resets in application mode.117Entered reprogramming mode due to invalid\n                    application (checksum for code and\/or data failed).118Entered reprogramming mode due to memory\n                    check failure.128Entered reprogramming mode but could not determine\n                    why (unexpected event).119Entered reprogramming mode when last reset was\n                    due to the watchdog.123Entered reprogramming mode due to invalid license.222Note: \n              This table may be extended in the future to cover other\n              conditions determined by the software relating to the\n              ECU.",
    "LLR.PLAT.PFC.FL.013": "When the software is in application mode, the software\n               shall  detect the following flash code conditions:\n            Condition (application mode)Flash code\n                      In application mode \u2013 no other condition has\n                      been detected\n                    111Note: \n              This table may be extended in the future to cover other\n              conditions determined by the software relating to the\n              ECU.",
    "LLR.PLAT.PFF.CONFIG.028": "The platform  shall  provide an interface parameter called pff_dtc_sev_overrides_ff_age to allow the\n              application to choose to delete lower severity FreezeFrames in case of shortage of memory space available.\n            Rationale: \n              The Euro 6 regulations require that the freezeframes of higher severity DTCs take precedence.",
    "LLR.PLAT.PFF.CONFIG.001": "If the storing of a freeze frame in NVM would cause the total number of bytes\n              allocated to freeze frame data to exceed the limit defined by the interface parameter\n              NVM allocation, then the platform  shall  not store the freeze frame data to NVM; unless\n              parameter pff_dtc_sev_overrides_ff_age is set to TRUE. See [LLR.PLAT.PFF.CONFIG.029].\n            Rationale: \n              Legally only a single freeze frame need be stored, and the application can always\n              ensure that, by setting the NVM allocation parameter sensibly. Earlier freeze frame\n              data should be prioritised over later data, since the earlier data are likely to be\n              more indicative of the root cause of any malfunction. Thus any later data should be\n              ignored if they cannot be accommodated.",
    "LLR.PLAT.PFF.CONFIG.002": "If the capture of a freeze frame in the holding buffer in RAM would cause the total\n              number of bytes in the buffer to exceed the total specified by the interface parameter\n              RAM allocation, then the platform  shall  not capture that freeze frame.\n            Rationale: \n              The holding buffer is used to hold the freeze frame data while it is being saved\n              to NVM. The application can always ensure that the first freeze frame can be\n              accommodated in the holding buffer by specifying the RAM allocation to be large\n              enough. If a number of freeze frames arise in such quick succession that there\n              is not enough time to save them to NVM before the holding buffer is full, then\n              it is best to discard the most recent data.",
    "LLR.PLAT.PFF.CONFIG.029": "If the NVM storage available is not sufficient to store the current freeze frame AND the parameter\n              pff_dtc_sev_overrides_ff_age is TRUE; then the platform  shall  delete a freeze frame to make sufficient space for the current freeze frame as defined below:\n            \n                  The platform  shall  delete UDS Snapshot freeze frames before deleting any other type of freeze frames.\n                \n                  If the platform will not have any UDS Snapshots in NVM storage, then the platform  shall  delete\n                  freeze frames corresponding to DTC(s) that are of lower severity.",
    "LLR.PLAT.PFF.CONFIG.003": "If the total number of J1979 freeze frames already stored in NVM is equal to the\n              maximum number of J1979 freeze frames to be stored as defined by the application\n              interface, then no new J1979 freeze frame  shall  be stored.\n            Rationale: \n              In addition to the total amount of (volatile and non-volatile) memory associated with\n              the freeze frame data themselves, there is also an overhead (both in memory and processor\n              time) associated with the number of freeze frames. It is therefore sensible to limit this\n              also, and to do so for different types of freeze frame so that no one type of freeze frame\n              occupies the entire allocation.",
    "LLR.PLAT.PFF.CONFIG.004": "If the total number of J1939 DM4 freeze frames already stored in NVM is equal to the\n              maximum number of J1939 DM4 freeze frames to be stored as defined by the application\n              interface, then no new J1939 DM4 freeze frame  shall  be stored.",
    "LLR.PLAT.PFF.CONFIG.005": "If the total number of J1939 DM25 expanded freeze frames already stored in NVM is equal\n              to the maximum number of J1939 DM25 expanded freeze frames to be stored as defined by the\n              application interface, then no new J1939 DM25 expanded freeze frame  shall  be stored.",
    "LLR.PLAT.PFF.CONFIG.030": "If the total number of UDS snapshot freeze frames already stored in NVM is equal\n              to the maximum number of UDS snapshot freeze frames to be stored as defined by the\n              application interface, then no new UDS snapshot expanded freeze frames  shall  be stored.",
    "LLR.PLAT.PFF.CONFIG.017": "If the total number of sets of freeze frames stored for a given DTC equals 126, then no more\n              freeze frames  shall  be stored for that DTC.\n            Note: \n              The set of freeze frames associated with a DTC depends on how that DTC is configured:\n              it may be associated with up to one freeze frame of each type, namely J1979, UDS snapshot,\n              J1939 standard (DM4) and J1939 expanded (DM25).",
    "LLR.PLAT.PFF.CONFIG.006": "The capi file  shall  be used to specify PFF settings in the following format:\n            \nff-data\n{\n  nvm-allocation-bytes = integer;\n  ram-allocation-bytes = integer;\n  max-num-of-j1979-ff = integer;\n  max-num-of-j1939-dm4-ff = integer;\n  max-num-of-j1939-dm25-ff = integer;\n  max-num-of-uds-snapshot-ff = integer;\n  num-of-j1939-dm25-ff-spns = integer;\n  j1939-dm25-ff-name = identifier;\n  freeze-frame { ... }\n}",
    "LLR.PLAT.PFF.CONFIG.007": "The interface  shall  use the nvm-allocation-bytes value to configure the NVM space required\n              to support freeze frames.",
    "LLR.PLAT.PFF.CONFIG.008": "The interface  shall  use the ram-allocation-bytes value to configure the RAM space required\n              to support freeze frames.",
    "LLR.PLAT.PFF.CONFIG.018": "The interface  shall  use the max-num-of-j1979-ff value to set the maximum number of J1979\n              freeze frames that can be stored in non-volatile memory.",
    "LLR.PLAT.PFF.CONFIG.019": "The interface  shall  use the max-num-of-j1939-dm4-ff value to set the maximum number of\n              J1939 DM4 freeze frames that can be stored in non-volatile memory.",
    "LLR.PLAT.PFF.CONFIG.020": "The interface  shall  use the max-num-of-j1939-dm25-ff value to set the maximum number of\n              J1939 DM25 freeze frames that can be stored in non-volatile memory.",
    "LLR.PLAT.PFF.CONFIG.031": "The interface  shall  use the max-num-of-uds-snapshot-ff value to set the maximum\n              number of UDS snapshot freeze frames that can be stored in non-volatile memory.",
    "LLR.PLAT.PFF.CONFIG.021": "The interface  shall  use the num-of-j1939-dm25-ff-spns value to indicate the number of\n              SPNs that are defined within the expanded freeze frame associated with J1939 DM25.",
    "LLR.PLAT.PFF.CONFIG.027": "The interface  shall  use the j1939-dm25-ff-name string to identify the\n              calibratable vector that defines the J1939 DM25 expanded freeze frame.",
    "LLR.PLAT.PFF.CONFIG.009": "The platform shall provide a Simulink interface block named\n                pff_Configuration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionTotal non-volatile memory allocation to store freeze frames (bytes)ParamInteger\n        \n          This field specifies how much of non-volatile memory is allocated to storing instances of freeze frames.\n          The allocation will be exclusively used for freeze frame storage.\n          An appropriate size should be chosen to contain your application needs.\n        \n        \n          Captured freeze frames are stored in non-volatile memory using a file system.\n          Each captured freeze frame is stored in an individual file.\n          There is an overhead associated with each file stored in NVM.\n          This overhead is 20 bytes plus whatever is required to round up to a multiple of 8 bytes.\n          Thus on a freeze frame of 100 bytes, the overhead would be 20 bytes,\n          whereas on a freeze frame of 101 bytes, the overhead would be 27.\n          This overhead forms part of the total non-volatile memory allocation to store freeze frames,\n          for instance if the application stores 10 freeze frame files each consisting of a 100 bytes of data\n          the total NVM allocation specified here should be at least 1200 bytes.\n        \n        \n          Range: [0, 65535] bytes\n        \n      \n                Calibratable: no.\n              RAM buffer size for buffering freeze frame data prior to writing to NVM (bytes)ParamInteger\n        \n          RAM is allocated statically (at build time) in OpenECU.\n          The specified RAM buffer size is used to store instances of freeze frames prior to writing to\n          non-volatile memory.\n          As such this field should at a minimum equal or exceed the largest freeze frame data size of\n          all freeze frames in the application.\n          Writing data to NVM is carried out in the background task as it takes time to complete.\n          Should your application need to capture multiple freeze frame instances within a short interval\n          this buffer should be sized appropriately to ensure the freeze frames are successfully written to NVM.\n        \n        \n          Note: an under sized RAM buffer may result in freeze frame instances not being captured.\n        \n        \n          Note: DM4 and DM25 of J1939 specify a max freeze frame data size of 1785 bytes.\n        \n        \n          Range: [0, 8191] bytes\n        \n      \n                Calibratable: no.\n              Maximum number of J1979 freeze frame instances to store in NVMParamInteger\n        \n          This field specifies an upper limit on how many captured J1979 freeze frame instances can be stored\n          in non-volatile memory (NVM).\n        \n        \n          Range: [0, 254]\n        \n      \n                Calibratable: no.\n              Maximum number of J1939 DM4 freeze frame instances to store in NVMParamInteger\n        \n          This field specifies an upper limit to how many captured DM4 freeze frame instances can be stored\n          in non-volatile memory.\n        \n        \n          Range: [0, 137]\n        \n      \n                Calibratable: no.\n              Maximum number of J1939 DM25 freeze frame instances to store in NVMParamInteger\n        \n          This field specifies an upper limit to how many captured DM25 freeze frame instances can be stored\n          in non-volatile memory.\n        \n        \n          Range: [0, 254]\n        \n      \n                Calibratable: no.\n              Maximum number of UDS snapshot instances to store in NVMParamInteger\n        \n          This field specifies an upper limit to how many captured UDS snapshot instances can be stored\n          in non-volatile memory.\n        \n        \n          Range: [0, 254]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PFF.CONFIG.109": "The block pff_Configuration shall support the targets:\n            All targets.",
    "LLR.PLAT.PFF.CONFIG.209": "The block pff_Configuration shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PFF.CONFIG.010": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PFF.CONFIG.022": "If the\n                Total non-volatile memory allocation to store freeze frames (bytes)\n                field contains a value outside the range [0 65535] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.023": "If the\n                RAM buffer size for buffering freeze frame data prior to writing to NVM (bytes)\n                field contains a value outside the range [0 8191] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.024": "If the\n                Maximum number of J1979 freeze frame instances to store in NVM\n                field contains a value outside the range [0 254] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.025": "If the\n                Maximum number of J1939 DM4 freeze frame instances to store in NVM\n                field contains a value outside the range [0 137] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.026": "If the\n                Maximum number of J1939 DM25 freeze frame instances to store in NVM\n                field contains a value outside the range [0 254] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.032": "If the\n                Maximum number of UDS snapshot instances to store in NVM\n                field contains a value outside the range [0 254] then the block  shall  report an error.",
    "LLR.PLAT.PFF.CONFIG.011": "The block  shall  run once at initialisation on the target.",
    "LLR.PLAT.PFF.CONFIG.012": "The block  shall  use the mask parameter\n                Total non-volatile memory allocation to store freeze frames (bytes)\n                to set the NVM allocation.",
    "LLR.PLAT.PFF.CONFIG.013": "The block  shall  use the mask parameter\n                RAM buffer size for buffering freeze frame data prior to writing to NVM (bytes)\n                to set the RAM allocation.",
    "LLR.PLAT.PFF.CONFIG.014": "The block  shall  use the mask parameter\n                Maximum number of J1979 freeze frame instances to store in NVM\n                to set the maximum number of J1979 $02 freeze frame instances to store in NVM.",
    "LLR.PLAT.PFF.CONFIG.015": "The block  shall  use the mask parameter\n                Maximum number of J1939 DM4 freeze frame instances to store in NVM\n                to set the maximum number of J1939 DM4 standard freeze frame instances to store in NVM.",
    "LLR.PLAT.PFF.CONFIG.016": "The block  shall  use the mask parameter\n                Maximum number of J1939 DM25 freeze frame instances to store in NVM\n                to set the maximum number of J1939 DM25 expanded freeze frame instances to store in NVM.",
    "LLR.PLAT.PFF.STORE.054": "When the ECU powers up, the platform  shall  delete any freeze frames that are stored in NVM that are not\n              listed in the file detailing the freeze frame data stored in NVM.",
    "LLR.PLAT.PFF.STORE.055": "If the file detailing the freeze frame data of a particular type (J1979, J1939 DM4 or J1939 DM25) stored\n              in NVM cannot itself be retrieved from NVM when the ECU powers up, then the platform  shall  delete all\n              freeze frames of that type that are stored in NVM.",
    "LLR.PLAT.PFF.STORE.043": "If a failure to retrieve DTC data when the ECU powers up results in DTC data being set\n              to their default values, then the platform  shall  erase all freeze frame data.\n            Rationale: \n              The freeze frame data should be kept in synchrony with the DTCs.",
    "LLR.PLAT.PFF.STORE.044": "If DTC and freeze frame data are successfully retrieved from non-volatile memory when the\n              ECU powers up, then the platform  shall  check the freeze frame data against the DTCs and\n              erase any freeze frame data for which the corresponding DTC is in the 'clear' state.\n            Rationale: \n              The freeze frame data should be kept in synchrony with the DTCs.",
    "LLR.PLAT.PFF.STORE.001": "The platform  shall  associate with a J1979 freeze frame precisely those PIDs listed in the\n              calibratable vector that defines the freeze frame, that are themselves defined within\n              the ECU software through the mechanism defined in LLR.PLAT.PPID.PID.001, and that are not\n              PIDs-supported PIDs or PID 0x02.\n            Rationale: \n              Making the list of PIDs calibratable means that build time errors are not possible in case\n              a PID is listed that has not been defined. Simply ignoring that PID is the only sensible\n              thing to do. PIDs-supported PIDs and PID 0x02 are not really defined in this context, so\n              they can never be included in a freeze frame.",
    "LLR.PLAT.PFF.STORE.065": "J1979 freeze frames  shall  only be captured for emissions related DTCs.",
    "LLR.PLAT.PFF.STORE.002": "When a DTC which has a J1979 freeze frame associated with it changes state from the 'Clear'\n              state to the 'Pending' state, then for every PID identifier associated with that freeze frame\n              (as defined in LLR.PLAT.PFF.STORE.001), that PID's current value  shall  be captured and stored.\n            Rationale: \n              See specifically HLR.PLAT.PFF.008.",
    "LLR.PLAT.PFF.STORE.045": "When a DTC which has a J1979 freeze frame associated with it changes state from the 'Clear'\n              state to the 'Active' state, then for every PID identifier associated with that freeze frame\n              (as defined in LLR.PLAT.PFF.STORE.001), that PID's current value  shall  be captured and stored.\n            Rationale: \n              Handles the case when a DTC becomes active straightaway.",
    "LLR.PLAT.PFF.STORE.003": "When a DTC which has a J1979 freeze frame associated with it changes state to the 'Clear' state,\n              then all freeze frame instances stored in association with this DTC  shall  be erased.\n            Rationale: \n              See HLR.PLAT.PFF.009. This transition could occur from any other state potentially.",
    "LLR.PLAT.PFF.STORE.004": "When a DTC which has a J1979 freeze frame associated with it changes state from the\n              'Previously Active' state to the 'Pending' state, then for every PID identifier associated\n              with that freeze frame (as defined in LLR.PLAT.PFF.STORE.001), that PID's current value\n               shall  be captured and stored.",
    "LLR.PLAT.PFF.STORE.005": "When a DTC which has a J1979 freeze frame associated with it changes state from the 'Pending'\n              state to the 'Previously Active' state, then if a freeze frame instance has been stored as a\n              result of the previous transition from 'Previously Active' to 'Pending' then that freeze frame\n              instance  shall  be erased.\n            Rationale: \n              When a DTC transitions from 'Previously Active' to 'Pending' it will cause another freeze frame\n              to be captured. If the DTC does not then transition to 'Active', but rather returns to 'Previously\n              Active' then that last freeze frame should be deleted but not any earlier instances, all of which\n              will be associated with the DTC passing through the 'Active' state at some point.",
    "LLR.PLAT.PFF.STORE.046": "When a J1979 freeze frame is captured and stored to NVM, the platform  shall  also capture and store\n              to NVM the DTC that caused the freeze frame to be captured.",
    "LLR.PLAT.PFF.STORE.066": "The platform  shall  associate with a UDS snapshot freeze frame precisely those PIDs listed in the\n              calibratable vector that defines the freeze frame, that are themselves defined within\n              the ECU software through the mechanism defined in LLR.PLAT.PPID.PID.001.\n            Rationale: \n              Making the list of PIDs calibratable means that build time errors are not possible in case\n              a PID is listed that has not been defined. Simply ignoring that PID is the only sensible\n              thing to do.",
    "LLR.PLAT.PFF.STORE.067": "When a DTC which has a UDS snapshot freeze frame associated with it changes state from the 'Clear'\n              state to the 'Pending' state, then for every PID identifier associated with that freeze frame\n              (as defined in LLR.PLAT.PFF.STORE.001), that PID's current value  shall  be captured and stored.\n            Rationale: \n              See specifically HLR.PLAT.PFF.008.",
    "LLR.PLAT.PFF.STORE.068": "When a DTC which has a UDS snapshot freeze frame associated with it changes state from the 'Clear'\n              state to the 'Active' state, then for every PID identifier associated with that freeze frame\n              (as defined in LLR.PLAT.PFF.STORE.066), that PID's current value  shall  be captured and stored.\n            Rationale: \n              Handles the case when a DTC becomes active straightaway.",
    "LLR.PLAT.PFF.STORE.069": "When a DTC which has a UDS snapshot freeze frame associated with it changes state to the 'Clear' state,\n              then all freeze frame instances stored in association with this DTC  shall  be erased.\n            Rationale: \n              See HLR.PLAT.PFF.009. This transition could occur from any other state potentially.",
    "LLR.PLAT.PFF.STORE.070": "When a DTC which has a UDS snapshot freeze frame associated with it changes state from the\n              'Previously Active' state to the 'Pending' state, then for every PID identifier associated\n              with that freeze frame (as defined in LLR.PLAT.PFF.STORE.001), that PID's current value\n               shall  be captured and stored.",
    "LLR.PLAT.PFF.STORE.071": "When a DTC which has a UDS snapshot freeze frame associated with it captures freeze frame data and\n              more than one snapshot freeze frame instance has been stored as a result of the DTC, then the\n              previous snapshot freeze frame instance  shall  be erased.\n            Rationale: \n              UDS snapshots captured as a result of the first and the most recent occurrence of the DTC\n              are retained.",
    "LLR.PLAT.PFF.STORE.072": "When a DTC which has a UDS snapshot freeze frame associated with it captures freeze frame data and\n              zero frame instance have been stored as a result of the DTC, then the freeze frame instance  shall  be\n              marked with DTCSnapshotRecordNumber 0, otherwise it will be marked with DTCSnapshotRecordNumber 1.",
    "LLR.PLAT.PFF.STORE.007": "The platform  shall  associate with the mandatory data section of a J1939 standard freeze\n              frame (as used in DM4) such SPNs defined within the ECU software that match those\n              on the mandatory list as defined in the SAE J1939-73 FEB2010 standard section 5.7.4.\n            Rationale: \n              One could allow the application to define the mandatory data just as it does the\n              other data associated with freeze frames. However, the platform must treat the\n              mandatory data differently since it must set the values to all ones when the true\n              values are not available. Therefore mandatory data are handled by the platform.",
    "LLR.PLAT.PFF.STORE.008": "If an SPN defined on the list of mandatory data associated with a J1939 standard\n              freeze frame is not defined within the ECU software, then the platform  shall  use\n              the value 0xFF for every byte of data associated with that SPN wherever it appears\n              within the definition of the associated freeze frame.\n            Rationale: \n              Since the format of the message specifies the fields associated with the mandatory data\n              it is not an option to ignore SPNs that are not defined (as is done with the manufacturer\n              supplied data). SAE J1939-71 DEC2003 section 5.2 Parameter Definitions states that undefined\n              bytes should be sent as 255.",
    "LLR.PLAT.PFF.STORE.009": "The ECU  shall  associate with the manufacturer specific section of a J1939 standard freeze\n              frame precisely those SPNs listed in the calibratable vector that defines manufacturer\n              specific section of the freeze frame, that are themselves defined within the ECU software.\n            Rationale: \n              If a manufacturer specific SPN is listed in the calibration that defines that part of the\n              freeze frame but is not itself defined, we simply ignore it as with the PIDs for J1979\n              freeze frames rather than defaulting it as for the mandatory data. This allows the customer\n              flexibility in determining the size of the freeze frame for the manufacturer specific data,\n              which is not an option for the mandatory data.",
    "LLR.PLAT.PFF.STORE.010": "When a DTC which has a J1939 standard freeze frame associated with it changes state from the\n              'Clear' state to the 'Pending' state, then for every SPN identifier associated with that freeze\n              frame (as defined in LLR.PLAT.PFF.STORE.007, LLR.PLAT.PFF.STORE.008 and LLR.PLAT.PFF.STORE.009),\n              that SPN's current value  shall  be captured and stored.\n            Rationale: \n              See specifically HLR.PLAT.PFF.008.",
    "LLR.PLAT.PFF.STORE.047": "When a DTC which has a J1939 standard freeze frame associated with it changes state from the\n              'Clear' state to the 'Active' state, then for every SPN identifier associated with that freeze\n              frame (as defined in LLR.PLAT.PFF.STORE.007, LLR.PLAT.PFF.STORE.008 and LLR.PLAT.PFF.STORE.009),\n              that SPN's current value  shall  be captured and stored.",
    "LLR.PLAT.PFF.STORE.011": "When a DTC which has a J1939 standard freeze frame associated with it changes state to the 'Clear'\n              state, then all freeze frame instances stored in association with this DTC  shall  be erased.\n            Rationale: \n              See HLR.PLAT.PFF.009. At this stage there should only ever be one freeze frame instance.",
    "LLR.PLAT.PFF.STORE.012": "When a DTC which has a J1939 standard freeze frame associated with it changes state from the\n              'Previously Active' state to the 'Pending' state, then for every SPN identifier associated\n              with that freeze frame (as defined in LLR.PLAT.PFF.STORE.007, LLR.PLAT.PFF.STORE.008 and\n              LLR.PLAT.PFF.STORE.009), that SPN's current value  shall  be captured and stored.",
    "LLR.PLAT.PFF.STORE.013": "When a DTC which has a J1939 standard freeze frame associated with it changes state from the\n              'Pending' state to the 'Previously Active' state, then if a freeze frame instance has been\n              stored as a result of the previous transition from 'Previously Active' to 'Pending' then that\n              freeze frame instance  shall  be erased.\n            Rationale: \n              See LLR.PLAT.PFF.STORE.005.",
    "LLR.PLAT.PFF.STORE.015": "The ECU  shall  associate with a J1939 expanded freeze frame precisely those SPNs listed\n              in the calibratable vector that defines the freeze frame, that are themselves defined\n              within the ECU software.\n            Rationale: \n              See LLR.PLAT.PFF.STORE.009.",
    "LLR.PLAT.PFF.STORE.016": "When a DTC which has a J1939 expanded freeze frame associated with it changes state from the\n              'Clear' state to the 'Pending' state, then for every SPN identifier associated with that freeze\n              frame (as defined in LLR.PLAT.PFF.STORE.015), that SPN's current value  shall  be captured and\n              stored.\n            Rationale: \n              See specifically HLR.PLAT.PFF.008.",
    "LLR.PLAT.PFF.STORE.048": "When a DTC which has a J1939 expanded freeze frame associated with it changes state from the\n              'Clear' state to the 'Active' state, then for every SPN identifier associated with that freeze\n              frame (as defined in LLR.PLAT.PFF.STORE.015), that SPN's current value  shall  be captured and\n              stored.",
    "LLR.PLAT.PFF.STORE.017": "When a DTC which has a J1939 expanded freeze frame associated with it changes state to the 'Clear'\n              state, then then all freeze frame instances stored in association with this DTC  shall  be erased.\n            Rationale: \n              See HLR.PLAT.PFF.009. At this stage there should only ever be one freeze frame instance.",
    "LLR.PLAT.PFF.STORE.018": "When a DTC which has a J1939 expanded freeze frame associated with it changes state from the\n              'Previously Active' state to the 'Pending' state, then for every SPN identifier associated\n              with that freeze frame (as defined in LLR.PLAT.PFF.STORE.015), that SPN's current value\n               shall  be captured and stored.",
    "LLR.PLAT.PFF.STORE.019": "When a DTC which has a J1939 expanded freeze frame associated with it changes state from the\n              'Pending' state to the 'Previously Active' state, then if a freeze frame instance has been\n              stored as a result of the previous transition from 'Previously Active' to 'Pending' then that\n              freeze frame instance  shall  be erased.\n            Rationale: \n              See LLR.PLAT.PFF.STORE.005.",
    "LLR.PLAT.PFF.STORE.049": "When a J1939 freeze frame (DM4 or DM25) is captured and stored to NVM, the platform  shall  also\n              capture and store to NVM the SPN, FMI, SPN Conversion Method and Occurrence Count of the DTC that\n              caused the freeze frame to be captured.",
    "LLR.PLAT.PFF.STORE.021": "The capi file  shall  be used to specify freeze-frame settings in the following format within the ff-data section:\n            \nfreeze-frame\n{\n  name = identifier;\n  protocol j1939 | j1979 | uds\n  {\n    type = dm4 | dm25 | snapshot;\n    dde-entry = identifier;\n    length    = number;\n  }\n}",
    "LLR.PLAT.PFF.STORE.022": "The interface  shall  use the name string to associate the freeze frame with DTCs which reference\n              this string in the freeze-frame-name statement of the dtc section.",
    "LLR.PLAT.PFF.STORE.023": "The interface  shall  use the protocol string to determine which communications protocol\n              the freeze frame should be associated with.",
    "LLR.PLAT.PFF.STORE.024": "Within a protocol section, if the protocol string is j1939, then the interface\n               shall  use the type string to determine whether the freeze frame is a standard (DM4) freeze frame\n              or an expanded (DM25) freeze frame.",
    "LLR.PLAT.PFF.STORE.025": "If the protocol string is j1979 , then within the\n              protocol section, the interface  shall  use the dde-entry\n              string to identify the entry in the data-dictionary that provides the calibratable vector list\n              of PIDs for this freeze frame.",
    "LLR.PLAT.PFF.STORE.073": "If the protocol string is j1939 and the type\n              is dm4, then within the protocol section, the interface  shall \n              use the dde-entry string to identify the entry in the data-dictionary that\n              provides the calibratable vector list of SPNs for this freeze frame.",
    "LLR.PLAT.PFF.STORE.074": "If the protocol string is uds and the type\n              is snapshot, then within the protocol section, the interface  shall \n              use the dde-entry string to identify the entry in the data-dictionary that\n              provides the calibratable vector list of PIDs for this freeze frame.",
    "LLR.PLAT.PFF.STORE.026": "If the protocol string is j1979 or if the protocol string is\n              j1939 and the type is dm4, then\n              within the protocol section, the interface  shall  use the length value\n              to identify the number of PIDs\/SPNs in this freeze frame.",
    "LLR.PLAT.PFF.STORE.027": "The platform shall provide a Simulink interface block named\n                pff_FreezeFrame that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionFreeze Frame nameParamString\n        \n          A unique freeze frame name is required in this field.\n          The freeze frame name is referenced in the Simulink block of the DTC\n          (see pdtc_DiagnosticTroubleCodeExt)\n          that triggers the freeze frame.\n        \n        \n          Note the freeze frame name is used in the generated C code and as such should follow the C variable naming convention.\n        \n      \n                Calibratable: no.\n              J1979 (service $02)ParamBoolean\n        \n          If ticked indicates the freeze frame complies with the J1979 standard.\n        \n      \n                Calibratable: no.\n              PID(s) to captureParamString\n        \n          A vector calibration giving the list of PID identifiers for a J1979 freeze frame is placed in this field.\n          The vector calibration needs to be defined in the data dictionary.\n          The value field of the vector calibration in the data dictionary defines the PID identifers for the named freeze frame.\n          However, all freeze frames should be cleared and the ECU power cycled after changing this calibration.\n        \n        \n          The vector calibration should be of type uint8_T.\n        \n        \n          The vector calibration should not have in excess of 255 elements.\n        \n        \n          Note a PID which is not present in an application will not be reported when supported PIDs for a freeze frame is requested.\n        \n        \n          Note that although no restriction is placed on when one may change this calibration, the correct procedure is to\n          clear all freeze frame information and power cycle the ECU after any such change. Failure to follow this procedure\n          could lead to anomalies in the freeze frame handling.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              J1939 (DM4)ParamBoolean\n        \n          If ticked indicates the freeze frame complies with J1939's DM4 freeze frame definition.\n        \n        \n          DM4 is composed of a list of mandatory SPNs and a manufacturer's list of SPN(s).\n        \n        \n          The mandatory SPNs are given by J1939-73 (FEB2010) as 899, 102, 190, 92, 110 and 84.\n          The mandatory SPNs for DM4 have been hardcoded into the platform.\n          As such when the OpenECU platform captures a DM4 freeze frame it always attempts to capture the mandatory SPN(s)\n          regardless of the presence or absence of the SPN in the application.\n          A mandatory SPN absent from the application will result in 0xFF(s) populating the data field allocated\n          for the absent mandatory SPN in the returned DM4 message.\n        \n      \n                Calibratable: no.\n              Manufacturer SPN(s)ParamString\n        \n          The manufacturer's list of SPNs for a DM4 freeze frame are placed in this field.\n          To enter the list of manufacturer SPNs use a vector calibration.\n          The values of the SPNs are calibratable.\n          However, all freeze frames should be cleared and the ECU power cycled after changing this calibration.\n        \n        \n          The vector calibration should be of type uint32_T.\n        \n        \n          The vector calibration should not have in excess of 255 elements.\n        \n        \n          A manufacturer SPN absent from the application will be ignored.\n          The SPN will not be saved to non-volatile memory when the DM4 freeze frame is captured.\n          The SPN's data will not appear in the returned DM message\n          and no data fields within the returned DM4 are allocated to denote its presence.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              J1939 (DM25)ParamBoolean\n        \n          If ticked indicates the freeze frame complies with J1939's DM25 freeze frame definition.\n        \n        \n          As per J1939-73 only a single freeze frame definition can exist for DM25.\n          The parameter list is specified by pff_Dm25FreezeFrame.\n        \n      \n                Calibratable: no.\n              UDS (Snapshot)ParamBoolean\n        \n          If ticked indicates the freeze frame complies with the ISO 14229-1 (UDS) snapshot definition.\n        \n      \n                Calibratable: no.\n              ISO PID(s)ParamString\n        \n          A vector calibration giving the list of ISO PID identifiers for a snapshot is placed in this field.\n          The vector calibration needs to be defined in the data dictionary.\n          The value field of the vector calibration in the data dictionary defines the ISO PID identifiers for the named freeze frame.\n          However, all freeze frames should be cleared and the ECU power cycled after changing this calibration.\n        \n        \n          The vector calibration should be of type uint16_T.\n        \n        \n          The vector calibration should not have in excess of 255 elements.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.",
    "LLR.PLAT.PFF.STORE.127": "The block pff_FreezeFrame shall support the targets:\n            All targets.",
    "LLR.PLAT.PFF.STORE.227": "The block pff_FreezeFrame shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PFF.STORE.056": "If the mask tick box\n              J1979 (service $02) is enabled the block  shall \n              display mask parameter PID(s) to capture.",
    "LLR.PLAT.PFF.STORE.034": "If the mask tick box\n              J1939 (DM4) is enabled the block  shall \n              display mask parameter Manufacturer SPN(s).",
    "LLR.PLAT.PFF.STORE.075": "If the mask tick box\n              UDS (Snapshot) is enabled the block  shall \n              display mask parameter ISO PID(s).",
    "LLR.PLAT.PFF.STORE.028": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.053": "The block  shall  raise an error if no pff_Configuration block is present in the model.",
    "LLR.PLAT.PFF.STORE.029": "If none of the tickbox parameters J1979 (service $02),\n                J1939 (DM4) or\n                J1939 (DM25) or\n                UDS (Snapshot)\n                are ticked, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.030": "If the parameter PID(s) to capture is not of type\n                uint8_T in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.050": "If the parameter PID(s) to capture has a length\n                greater than 255 in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.031": "If the parameter Manufacturer SPN(s) is not of type\n                uint32_T in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.051": "If the parameter Manufacturer SPN(s) has a length\n                greater than 255 in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.076": "If the parameter ISO PID(s) is not of type\n                uint16_T in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.077": "If the parameter ISO PID(s) has a length\n                greater than 255 in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.060": "If the mask tick box J1939 (DM25) is enabled\n                the block  shall  raise an error if no pff_Dm25FreezeFrame block is present in the model.",
    "LLR.PLAT.PFF.STORE.033": "The block  shall  run once at initialisation on the target.",
    "LLR.PLAT.PFF.STORE.036": "The block  shall  use the mask parameter\n                Freeze Frame name\n                to set the Freeze Frame block name for reference by a pdtc_DiagnosticTroubleCodeExt\n                block's Freeze frame associated with this DTC\n                mask parameter.",
    "LLR.PLAT.PFF.STORE.037": "If the mask tick box\n                J1979 (service $02) is enabled the block  shall \n                associate with that freeze frame set a J1979 freeze frame definition.",
    "LLR.PLAT.PFF.STORE.038": "If the mask tick box\n                J1939 (DM4) is enabled the block  shall \n                associate with that freeze frame set a J1939 DM4 freeze frame definition.",
    "LLR.PLAT.PFF.STORE.039": "If the mask tick box\n                J1939 (DM25) is enabled\n                the block  shall  associate with that freeze frame set the J1939 DM25\n                freeze frame definition.",
    "LLR.PLAT.PFF.STORE.078": "If the mask tick box\n                UDS (Snapshot) is enabled\n                the block  shall  associate with that freeze frame set the UDS snapshot\n                freeze frame definition.",
    "LLR.PLAT.PFF.STORE.040": "The block  shall  use the mask parameter\n                PID(s) to capture to specify the name\n                of the data dictionary calibratable vector entry that defines which PIDs are to\n                be associated with this J1979 freeze frame definition.",
    "LLR.PLAT.PFF.STORE.041": "The block  shall  use the mask parameter\n                Manufacturer SPN(s) to specify the name\n                of the data dictionary calibratable vector entry that defines which SPNs are to\n                be associated with the manufacturer-defined section of this J1939 standard freeze\n                frame definition (DM4).",
    "LLR.PLAT.PFF.STORE.079": "The block  shall  use the mask parameter\n                ISO PID(s) to capture to specify the name\n                of the data dictionary calibratable vector entry that defines which PIDs are to\n                be associated with this UDS snapshot freeze frame definition.",
    "LLR.PLAT.PFF.STORE.057": "The block  shall  determine the number of PIDs or SPNs (as appropriate) in a given\n                freeze frame definition from the length of the corresponding vector entry in the\n                data dictionary.",
    "LLR.PLAT.PFF.STORE.058": "The platform shall provide a Simulink interface block named\n                pff_Dm25FreezeFrame that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionDM25 list of SPN(s)ParamString\n        \n          The list of SPN(s) for a DM25 freeze frame are placed in this field.\n          To enter the list of SPN(s) use a vector calibration.\n          The values of the SPN(s) are calibratable.\n        \n        \n          The vector calibration should be of type uint32_T.\n        \n        \n          The vector calibration should not have in excess of 255 elements.\n        \n        \n          A SPN absent from the application will be ignored.\n          No data fields within the returned DM25 are allocated to denote its presence.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.",
    "LLR.PLAT.PFF.STORE.158": "The block pff_Dm25FreezeFrame shall support the targets:\n            All targets.",
    "LLR.PLAT.PFF.STORE.258": "The block pff_Dm25FreezeFrame shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PFF.STORE.059": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.061": "The block  shall  raise an error if multiple pff_Dm25FreezeFrame blocks exist in the model.",
    "LLR.PLAT.PFF.STORE.062": "If the parameter DM25 list of SPN(s) is not of type\n                uint32_T in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.063": "If the parameter DM25 list of SPN(s) has a length\n                greater than 255 in data dictionary, then the block  shall  raise an error.",
    "LLR.PLAT.PFF.STORE.064": "The block  shall  use the mask parameter\n                DM25 list of SPN(s) to specify the name\n                of the data dictionary calibratable vector entry that defines which SPN(s) are to\n                be associated with the DM25 freeze frame definition.",
    "LLR.PLAT.PFS.FWRITE.001": "The platform shall provide a C interface function named\n                pfs_fwrite_queue() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_file_id\n          in\n        PFS_FILE_ID_T\nID of file to write (numeric equivalent of filename)\n Range: [0, 65535]pfsf_src_ptr\n          in\n        const U8 *\nFirst byte location containing data to be written to filepfsf_byte_len\n          in\n        S32\nNumber of bytes to write\n Range: [0, 16777215]pfsf_user_data\n          in\n        U16\nUser-specific data to store as part of file metadata; for example, this might convey format information relating to the content of the file. It can be retrieved using pfs_fstat(). This is separate from the actual file content, so that the latter can consist of equal-sized records (where appropriate) for coherent writing.\n Range: [0, 65535]pfsf_coherent_copy_size\n          in\n        S16\nThe filesystem will copy the provided data in multiples of this size, and prevent execution of the client task during the copy operation. For example, if the data to be saved consists of an array of structures each of 6 bytes in size, set this to 6 to ensure the filesystem always reads a whole struct at a time. A value of zero means \"don't care\".\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, otherwise one of PFS_RC_T constants indicating an error occurred",
    "LLR.PLAT.PFS.FWRITE.101": "The function pfs_fwrite_queue() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FWRITE.201": "The function pfs_fwrite_queue() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FWRITE.002": "The interface function  shall  return PFS_RC_OK if\n              the file was successfully queued or one of the\n              other PFS_RC_T return codes otherwise.",
    "LLR.PLAT.PFS.FWRITE.003": "The function  shall  reject an attempt to write a\n              file with an ID reserved for platform use.",
    "LLR.PLAT.PFS.FWRITE.004": "The function  shall  reject an attempt to write a\n              file for which there is insufficient free space\n              in the filesystem.",
    "LLR.PLAT.PFS.FWRITE.005": "The function  shall  reject an attempt to write a\n              file for which the write process has already been\n              queued by the client, but not yet completed.\n            Note: \n              This specifically does not disallow the client\n              from successfully queueing a file for writing\n              where that file is being internally copied by\n              the filesystem itself. Such operations are internal\n              to the filesystem and not specified here.",
    "LLR.PLAT.PFS.FWRITE.006": "The platform  shall  copy the source data provided by\n              the client to non-volatile storage such that it can\n              be subsequently retreived using pfs_fread() and its\n              statistics obtained using pfs_fstat().",
    "LLR.PLAT.PFS.FWRITE.007": "The platform  shall  write the supplied data to\n              non-volatile storage without interrupting any normal\n              operation or consuming more than 5% of\n              CPU time.\n            Rationale: \n              The CPU time is an arbitrary target but was found to be\n              easily achievable in prototyping work. The important\n              aspect is that application tasks continue to run in\n              real time and that other platform functions still run\n              successfully (e.g. processing of interrupts).",
    "LLR.PLAT.PFS.FWRITE.008": "The platform  shall  validate that the file has been\n              correctly written to storage using a checksum and\n              allow the client to determine if the store operation\n              has completed successfully via pfs_fstat().",
    "LLR.PLAT.PFS.FWRITE.009": "The platform  shall  write data to storage such that\n              if the process is interrupted at any time leaving\n              incomplete or otherwise invalid data stored, a subsequent\n              attempt to retrieve that file can and will instead access\n              the previous successfully saved copy of the file with\n              the same ID (if one exists).",
    "LLR.PLAT.PFS.FWRITE.010": "The platform  shall  copy the application-specified\n              data to storage in multiples of the coherent copy (record)\n              size specified by the client within a critical section,\n              such that if the client also uses a critical section\n              when updating their data, an incoherent copy of\n              a record is never stored.\n            Rationale: \n              The client can use pfs_lock_filesystem() and\n              pfs_unlock_filesystem() to enter the required critical section.\n              Client data often consists of a (possibly large) array of structures of modest\n              size, where the contents of each struct need to be kept consistent,\n              but individual structs can be saved at different times without\n              any coherency problems.\n            \n              This mechanism allows the storage of such arrays without\n              the entire array having to be buffered separately in precious RAM. However,\n              the client may choose instead to copy their whole data to a\n              second RAM area, and request that to be stored instead, if this\n              mechanism is inadequate to meet their coherency requirements.",
    "LLR.PLAT.PFS.FWRITE.011": "The platform  shall  write the build timestamp, application version\n              number and user-supplied metadata to the file. (This allows\n              subsequent client logic to decide how this file should be\n              used depending on the software version that wrote it.)",
    "LLR.PLAT.PFS.FREAD.001": "The platform shall provide a C interface function named\n                pfs_fread() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_file_id\n          in\n        PFS_FILE_ID_T\nID of file to read (numeric equivalent of filename)\n Range: [0, 65535]pfsf_byte_offset\n          in\n        U32\nByte offset from start of file at which to start reading; zero to start from beginning of file\n Range: [0, 16777215]pfsf_dest_ptr\n          in\/out\n        U8 *\nLocation to write the file data to; cannot be NULL\npfsf_max_bytes\n          in\n        U32\nMaximum size of data to read from file, or zero to read whole file\n Range: [0, 16777215]pfsf_actual_bytes\n          in\/out\n        U32 *\nPointer to location in which to place the number of bytes that were read from the file; can be NULL\n Range: [0, 16777215]\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, otherwise one of PFS_RC_T constants indicating an error occurred",
    "LLR.PLAT.PFS.FREAD.101": "The function pfs_fread() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FREAD.201": "The function pfs_fread() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FREAD.002": "The interface function  shall  return PFS_RC_OK if\n              the requested data was successfully retrieved or one of the\n              other PFS_RC_T return codes otherwise.",
    "LLR.PLAT.PFS.FREAD.003": "The interface function  shall  interpret zero as the value\n              of the pfsf_max_bytes parameter to mean \"all data in the\n              file\".",
    "LLR.PLAT.PFS.FREAD.004": "The function  shall  return an error code if the file ID\n              supplied does not correspond to a validated, completely\n              stored file currently existing in the filesystem.",
    "LLR.PLAT.PFS.FREAD.005": "The function  shall  return an error code if the supplied\n              offset into the file at which reading should begin is\n              actually beyond the last byte of data in the file.",
    "LLR.PLAT.PFS.FREAD.011": "The function  shall  return an error code if the supplied\n              pointer to the destination client buffer is NULL.",
    "LLR.PLAT.PFS.FREAD.006": "The platform  shall  retrieve data from the most recent\n              version of the file specified that is completely written\n              and validated in the filesystem at the time of the call.",
    "LLR.PLAT.PFS.FREAD.007": "The platform  shall  copy data from the stored file to\n              the specified destination before returning to the caller.",
    "LLR.PLAT.PFS.FREAD.008": "The platform  shall  begin copying from the stored file\n              at the byte offset specified by the caller.\n            Rationale: \n              This provides clients with random access to any small\n              part of a file. This avoids the need to buffer entire\n              files in precious RAM when they are required only for\n              read access.",
    "LLR.PLAT.PFS.FREAD.009": "The platform  shall  copy pfsf_max_bytes from the file\n              to the client location or until the end of the file,\n              whichever is smaller. (But note special case of pfsf_max_bytes = 0\n              above.)\n            Rationale: \n              Again this allows small parts of files to be read\n              as and when required.",
    "LLR.PLAT.PFS.FREAD.010": "The platform  shall  ensure that the file data returned\n              to the client consists of a valid, coherent image of\n              the saved file as it existed at the start of the read\n              operation.\n            Rationale: \n              We know that internally, we have to avoid copying part\n              of an old file and then the remainder from an updated copy\n              whose write might be completed during a read operation; and\n              also we must avoid returning garbage data from flash which\n              would be read if the memory was accessed during a program\n              or erase operation.",
    "LLR.PLAT.PFS.FSTAT.001": "The platform shall provide a C interface function named\n                pfs_fstat() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_file_id\n          in\n        PFS_FILE_ID_T\nID of file of interest (numeric equivalent of filename)\n Range: [0, 65535]pfsf_file_stats\n          in\/out\n        PFS_FILE_STATS_T *\nPointer to structure provided by caller into which the statistics should be placed. Cannot be NULL.\n\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, otherwise one of PFS_RC_T constants indicating an error occurred",
    "LLR.PLAT.PFS.FSTAT.101": "The function pfs_fstat() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FSTAT.201": "The function pfs_fstat() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FSTAT.002": "The interface function  shall  return PFS_RC_OK if\n              the requested file exists already as a saved file\n              or is queued for writing, and PFS_RC_ERROR otherwise.",
    "LLR.PLAT.PFS.FSTAT.003": "The function  shall  write data to the structure pointed\n              to by pfsf_file_stats if it is non-NULL, or otherwise\n              write nothing. (The return code can still be used in that\n              case.)",
    "LLR.PLAT.PFS.FSTAT.004": "The platform  shall  set pfsf_file_stats.on_disk to TRUE\n              if the file identified already exists in a completely\n              written and validated form in the filesystem or FALSE\n              otherwise.",
    "LLR.PLAT.PFS.FSTAT.005": "The platform  shall  set pfsf_file_stats.write_queued to TRUE\n              if any queued operation (file write, file delete, or\n              internal copy of the file from one place to another) is\n              in progress or FALSE otherwise. (A file may be both queued and\n              present on disk.)",
    "LLR.PLAT.PFS.FSTAT.006": "If the platform writes pfsf_file_stats.on_disk FALSE then\n              it writes the remaining elements of pfsf_file_stats to zero\n              or FALSE as appropriate.",
    "LLR.PLAT.PFS.FSTAT.007": "If the platform writes pfsf_file_stats.on_disk TRUE then\n              it writes the remaining elements of pfsf_file_stats with\n              the corresponding information read from the most recent\n              version of the completely stored, validated file as it\n              currently exists on disk.",
    "LLR.PLAT.PFS.FSTAT.008": "Where a file exists, this function  shall  include in the\n              data returned the application version, build timestamp\n              value and user metadata value which were written when the file\n              was created. (This allows the client to decide how to use\n              the file, depending on the version of software used to write\n              it.)",
    "LLR.PLAT.PFS.FDEL.001": "The platform shall provide a C interface function named\n                pfs_fdelete_queue() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_file_id\n          in\n        PFS_FILE_ID_T\nID of file to delete (numeric equivalent of filename)\n Range: [0, 65535]\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, otherwise one of PFS_RC_T constants indicating an error occurred",
    "LLR.PLAT.PFS.FDEL.101": "The function pfs_fdelete_queue() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FDEL.201": "The function pfs_fdelete_queue() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FDEL.002": "The interface function  shall  return PFS_RC_OK if\n              the delete request was accepted for processing or one of the other\n              PFS_RC_T error codes otherwise.",
    "LLR.PLAT.PFS.FDEL.003": "The function  shall  reject an attempt to delete a\n              file with an ID reserved for platform use.",
    "LLR.PLAT.PFS.FDEL.004": "The function  shall  reject an attempt to delete a\n              file which is not already completely stored and\n              validated in the filesystem.",
    "LLR.PLAT.PFS.FDEL.005": "The function  shall  reject an attempt to delete a\n              file for which a write or delete operation requested by\n              the client is already in progress.\n            Note: \n              This specifically does not disallow the client\n              from successfully queueing a file for deletion\n              where that file is being internally copied by\n              the filesystem itself. Such operations are internal\n              to the filesystem and not specified here.",
    "LLR.PLAT.PFS.FDEL.006": "The platform  shall  write a non-volatile record\n              that the file identified no longer exists, and then update the\n              filesystem statistics consistent with its removal.",
    "LLR.PLAT.PFS.FDEL.007": "If the ECU is de-powered and re-powered after the successful\n              completion of a delete operation, the filesystem  shall  continue to report\n              data consistent with the deleted file not existing.",
    "LLR.PLAT.PFS.FSSTATS.001": "The platform shall provide a C interface function named\n                pfs_get_filesystem_stats() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_stats\n          in\/out\n        PFS_FILESYS_STATS_T *\nPointer to structure provided by caller into which the statistics should be placed. Cannot be NULL.\n\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, otherwise one of PFS_RC_T constants indicating an error occurred",
    "LLR.PLAT.PFS.FSSTATS.101": "The function pfs_get_filesystem_stats() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FSSTATS.201": "The function pfs_get_filesystem_stats() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FSSTATS.002": "The interface function  shall  return PFS_RC_OK if\n              the operation is completed successfully or another\n              PFS_RC_T code otherwise.",
    "LLR.PLAT.PFS.FSSTATS.003": "The function  shall  reject a NULL pointer argument.",
    "LLR.PLAT.PFS.FSSTATS.004": "The platform  shall  fill the PFS_FILESYS_STATS_T structure\n              provided via the pointer argument with the current filesystem\n              data. (See PFS_FILESYS_STATS_T documentation for details.)",
    "LLR.PLAT.PFS.FLUSH.001": "The platform shall provide a C interface function named\n                pfs_flush_all() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PFS.FLUSH.101": "The function pfs_flush_all() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.FLUSH.201": "The function pfs_flush_all() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.FLUSH.002": "The platform  shall  complete all pending write and\n              delete operations before returning control to the\n              caller, such that the ECU can be depowered without\n              any loss of file data immediately after return\n              from this function. (Note: this implies that real-time\n              scheduling must be suspended while the operation completes.)\n            Rationale: \n              This will be required so that a typical managed power-down\n              sequence (at the ignition off event) can be performed,\n              where the ECU has control over its own power.",
    "LLR.PLAT.PFS.BYIDX.001": "The platform shall provide a C interface function named\n                pfs_get_file_id_by_idx() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionMISSING PARAMETER!PLEASEFIXME!MISSING PARAMETER!PLEASEFIXME!\n                The function returns a value of type\n                PFS_RC_T\n                with a value of:\n              PFS_RC_OK if successful, PFS_RC_OUT_OF_RANGE if no file exists at that index in the list, or another PFS_RC_T value for other error conditions.",
    "LLR.PLAT.PFS.BYIDX.101": "The function pfs_get_file_id_by_idx() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.BYIDX.201": "The function pfs_get_file_id_by_idx() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.BYIDX.002": "The interface function  shall  return PFS_RC_OK if\n              a file at the supplied index exists and any other\n              interface checks passed, or one of the other PFS_RC_T\n              codes otherwise.",
    "LLR.PLAT.PFS.BYIDX.003": "The function  shall  reject a NULL pfsf_file_id_ptr value.",
    "LLR.PLAT.PFS.BYIDX.004": "The function  shall  return PFS_RC_OUT_OF_RANGE if there\n              is no file at the specified position in the list, where\n              the first entry in the list is numbered zero.",
    "LLR.PLAT.PFS.BYIDX.005": "If the checks detailed previously passed, this function\n               shall  return the file ID of the file currently listed at\n              the supplied index position by the filesystem. (Note:\n              this position may change due to subsequent write or delete\n              operations.)",
    "LLR.PLAT.PFS.NEWER.001": "The platform shall provide a C interface function named\n                pfs_is_newer() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_old_revision\n          in\n        PFS_REVISION_T\nThe revision number which is expected to be newer.\n Range: [0, 65535]pfsf_new_revision\n          in\n        PFS_REVISION_T\nThe revision number which is expected to be older.\n Range: [0, 65535]\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE if the expected newer revision was indeed newer than the expected older revision, otherwise FALSE.",
    "LLR.PLAT.PFS.NEWER.101": "The function pfs_is_newer() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.NEWER.201": "The function pfs_is_newer() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.NEWER.002": "The interface function  shall  return TRUE if pfsf_new_revision\n              is indeed a more recent revision number than pfsf_old_revision\n              or FALSE otherwise. (Note: revision numbers are subject to\n              integer wraparound, hence this utility.)",
    "LLR.PLAT.PFS.LOCK.001": "The platform shall provide a C interface function named\n                pfs_lock_filesystem() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PFS.LOCK.101": "The function pfs_lock_filesystem() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.LOCK.201": "The function pfs_lock_filesystem() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.LOCK.002": "The platform  shall  suspend any ongoing filesystem operations\n              by the time this function returns. (Note: this opens a critical\n              section affecting operating system scheduling of other tasks.)\n            Rationale: \n              The client code can call this function to open a critical section.\n              Within the critical section, the client may safely update any\n              memory it is having written to a file without that data being\n              copied by the filesystem. The filesystem will respect the\n              coherent copy size specified by the client (see pfs_fwrite_queue())\n              so overall this provides a means for clients to ensure\n              that any one record is written to storage coherently.",
    "LLR.PLAT.PFS.UNLOCK.001": "The platform shall provide a C interface function named\n                pfs_unlock_filesystem() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PFS.UNLOCK.101": "The function pfs_unlock_filesystem() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.UNLOCK.201": "The function pfs_unlock_filesystem() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.UNLOCK.002": "The platform  shall  return the operating system to the normal state\n              by the time this function returns. (In particular this allows any\n              pending filesystem operations to resume subsequently.)\n            Rationale: \n              See pfs_lock_filesystem().",
    "LLR.PLAT.PFS.ENCTIME.001": "The platform shall provide a C interface function named\n                pfs_encode_time() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpfsf_sec\n          in\n        U16\nSeconds value of time to encode\n Range: [0, 59]pfsf_min\n          in\n        U16\nMinutes value of time to encode\n Range: [0, 59]pfsf_hour\n          in\n        U16\nHour value (in 24 hour system) of time to encode\n Range: [0, 23]pfsf_day\n          in\n        U16\nDay of month of date to encode\n Range: [1, 31]pfsf_month\n          in\n        U16\nMonth of date to encode\n Range: [1, 12]pfsf_year\n          in\n        U16\nYear value of date to encode\n Range: [2010, 2099]\n                The function returns a value of type\n                U32\n                with a value of:\n              Encoded compact timestamp. Always succeeds, as all input values are forced to comply with their allowed range.",
    "LLR.PLAT.PFS.ENCTIME.101": "The function pfs_encode_time() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PFS.ENCTIME.201": "The function pfs_encode_time() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PFS.ENCTIME.002": "The interface function  shall  return a time value with\n              a resolution of PFS_DATESTAMP_SEC_PER_BIT where zero\n              corresponds to 00:00 hours on 1st January PFS_ORIGIN_YEAR.\n            \n          \n            It would be adequate to use simpler processing to create\n            a monotonically increasing build timestamp compact value without\n            the complications of date calculations. However, using a well-defined\n            form makes it simpler to perform the reverse operation in future\n            (i.e. compute a calendar time\/date from the compact timestamp\n            attached to a file) should that be desired.",
    "LLR.PLAT.PFS.ENCTIME.003": "The function  shall  saturate (clip) all input parameters prior\n              to their use in the calculation to valid values with the year\n              in the range PFS_ORIGIN_YEAR to PFS_MAX_YEAR. (Hence there is\n              no error reporting from this function.)",
    "LLR.PLAT.PFS.INIT.001": "The platform  shall  implement a C function named pfs_pre_initialise() with no parameters and\n              no return value. The function shall be called at platform initialisation and will not be\n              available through the C-API.",
    "LLR.PLAT.PFS.INIT.002": "The filesystem  shall  make the most recent version of a\n              file which has passed checksum validation available for\n              client code to read. (Hence if a part-written file is\n              encountered, the client will instead be directed to any\n              previous intact copy of the same file.)",
    "LLR.PLAT.PFS.BGCHECK.001": "The platform  shall  continually re-checksum all files currently\n              present in the filesystem and mark any that fail validation as\n              invalid (no longer available for read), unless the C-API option\n              to disable all background memory checks is set.\n            Rationale: \n              The contents of a file may be repeatedly read by application code\n              and it is conceivable that flash memory can be corrupted by\n              software errors or cosmic ray damage. The client code is forced\n              to take alternative action if the file is no longer treated as\n              available, e.g. resorting to default data, just as it must do if\n              the file is unavailable because the ECU has never run before.\n            \n              See also [LLR.PLAT.PSC.BGRAM.007] concerning opt-out from memory checks.",
    "LLR.PLAT.PISO.001": "The timeout for transmission of a CAN frame by the platform  shall  be 25ms.\n            Rationale: \n              This is the standard timeout defined in ISO15765-4. Parameter\n              N_As in table \u201cNetwork layer timeout and performance requirement\n              values\u201d.",
    "LLR.PLAT.PISO.002": "The platform  shall  abort transmission if it cannot transmit a CAN frame within\n              the timeouts defined in LLR.PLAT.PISO.001 or\n              LLR.PLAT.PISO.007.\n            \n              Note: CR 5175 has been raised for these postponed requirements.",
    "LLR.PLAT.PISO.003": "The platform  shall  abort reception if a FlowControl Frame (FC)\n              is received after a timeout period of 75ms.\n            Rationale: \n              This is the standard timeout defined\n              in ISO15765-4. Parameter N_Bs in table \u201cNetwork layer timeout and performance\n              requirement values\u201d.",
    "LLR.PLAT.PISO.004": "The platform  shall  transmit the FlowControl Frame (FC) within\n              25ms of the reception of the first CAN frame.\n            Rationale: \n              This is the standard timeout defined in ISO15765-4. Parameter N_Br\n              in table \u201cNetwork layer timeout and performance requirement values\u201d.",
    "LLR.PLAT.PISO.005": "The platform  shall  abort reception and indicate an error to the client if it\n              cannot transmit a CAN frame within the timeout defined in\n              LR.PLAT.PISO.004.",
    "LLR.PLAT.PISO.006": "When the platform aborts reception of a message as per LR.PLAT.PISO.005,\n              it  shall  discard all the frames received and await start of a new message.\n            \n              Note: CR 5175 has been raised for these postponed requirements.",
    "LLR.PLAT.PISO.007": "The platform  shall  transmit each Consecutive Frame (CF) within 50ms of the\n              preceding CF or FF.\n            Rationale: \n              This is the standard timeout defined in ISO15765-4. Parameter N_Cs in table\n              \u201cNetwork layer timeout and performance requirement values\u201d.",
    "LLR.PLAT.PISO.008": "The platform  shall  abort reception of a multiframe message if the CF is\n              received after a timeout period of 150ms after the preceding CF or FF.\n            Rationale: \n              This is the standard timeout defined in ISO15765-4. Parameter N_Cr in\n              table \u201cNetwork layer timeout and performance requirement values\u201d.",
    "LLR.PLAT.PISO.009": "When the platform aborts reception of a multiframe message as per\n              LLR.PLAT.PISO.003 or\n              LLR.PLAT.PISO.008, it  shall  discard all\n              the further CFs until a new FF or Single Frame (SF)\n              is received.",
    "LLR.PLAT.PISO.047": "The platform  shall  ignore unexpected CAN packets with the\n              exception of: a) a new SF or FF packet received during multipacket reception \n              or b) a CF packet with an unexpected sequence number.\n              Hence in general, any segmented message transmission or\n              reception in progress shall continue if an unexpected packet\n              is received.\n            Rationale: \n              See \"Unexpected arrival of N_PDU\" in ISO 15765-2. Our\n              implementation does not really support full-duplex operation,\n              so the assumption is that the half-duplex requirements apply.",
    "LLR.PLAT.PISO.048": "If the platform receives a new SF or FF packet \n              during multipacket reception it  shall  abandon the reception\n              previously in progress and process the new packet instead.\n            Rationale: \n              See \"Unexpected arrival of N_PDU\" in ISO 15765-2 for\n              SF and FF N_PDU with \"Segmented receive in progress\".",
    "LLR.PLAT.PISO.049": "If the platform receives a CF packet with an unexpected\n              sequence number\n              during multipacket reception it  shall  abandon the reception\n              in progress and signal an error to the client.\n            Rationale: \n              See \"SequenceNumber (SN) error handling\" in ISO 15765-2.",
    "LLR.PLAT.PISO.010": "The platform  shall  handle requests with both physical and functional addressing\n              for ISO diagnostics.",
    "LLR.PLAT.PISO.011": "Only Single Frame (SF) messages  shall  be received under\n              functional addressing.\n            \n              Source: ISO 15765-2 section 6.3.2.3\n            Rationale: \n               The CANoe.DiVa test run by Eaton interpreted this as including\n               aborting a segmented (physically-requested) transmit in progress\n               if a functionally-addressed FC is received from the test tool.\n               However, the \"Unexpected arrival of N_PDU\" in ISO 15765-2\n               suggests such a packet should just be ignored (so transmit should\n               continue, should a physically-addressed valid FC follow).",
    "LLR.PLAT.PISO.012": "The platform  shall  provide an optional can-bus\n                assignment statement that identifies the CAN bus to use for ISO diagnostics.\n                If no assignment is made then the first bus is used.",
    "LLR.PLAT.PISO.013": "The platform  shall  provide an optional can-rx-id\n                assignment statement that identifies the receive CAN identifier to be used\n                for ISO diagnostic communications with the external tool. The\n                integer for each statement must be in the range [0, 2047]\n                for standard (11 bit) CAN identifiers or [0,536870911] for extended (29 bit)\n                CAN identifiers. The integer must not be the same as\n                can-func-rx-id or can-tx-id.",
    "LLR.PLAT.PISO.014": "The platform  shall  provide an optional can-func-rx-id\n                assignment statement that identifies the functional receive CAN identifier\n                to be used for ISO diagnostic communications with the external tool. The\n                integer for each statement must be in the range [0, 2047]\n                for standard (11 bit) CAN identifiers or [0,536870911] for extended (29 bit)\n                CAN identifiers. The integer must not be the same as\n                can-rx-id or can-tx-id.",
    "LLR.PLAT.PISO.015": "The platform  shall  provide an optional can-tx-id\n                assignment statement that identifies the transmit CAN identifier to be used for\n                ISO diagnostic communications with the external tool. The\n                integer for each statement must be in the range [0, 2047]\n                for standard (11 bit) CAN identifiers or [0,536870911] for extended (29 bit)\n                CAN identifiers. The integer must not be the same as\n                can-func-rx-id or can-func-rx-id.",
    "LLR.PLAT.PISO.016": "The platform  shall  disable ISO dignostics if any of the assignments for\n                can-func-rx-id, can-tx-id and\n                can-rx-id are not all present.",
    "LLR.PLAT.PISO.017": "The platform  shall  provide an optional can-rx-id-extd\n                assignment statement that specifies whether extended (29 bit) format CAN\n                identifiers are to be used instead of the default 11 bit format identifiers\n                for ISO diagnostic communications. It is possible to transmit using\n                an 11 bit identifier and receive using a 29 bit identifier and vice versa.\n              \n                Allowed values are true or false.",
    "LLR.PLAT.PISO.018": "The platform  shall  provide an optional can-tx-id-extd\n                assignment statement that specifies whether extended (29 bit) format CAN\n                identifiers are to be used instead of the default 11 bit format identifiers\n                for ISO diagnostic communications. It is possible to transmit using\n                an 11 bit identifier and receive using a 29 bit identifier and vice versa.\n              \n                Allowed values are true or false.",
    "LLR.PLAT.PISO.019": "The platform  shall  provide an optional size-of-rx-buffer\n                assignment statement that specifies how large, in bytes, the space reserved\n                for the longest diagnostic request message. The integer\n                for each statement must be in the range [1, 4095]. If omitted, a default is\n                used.\n              \n                \n                  Note: Applications which need to accept a long series of\n                  inputOutputControlByIdentifier bytes to override a PID\n                  value  will  need a large receive buffer. Otherwise, smaller values can be\n                  used to save RAM.",
    "LLR.PLAT.PISO.020": "The platform  shall  provide an optional size-of-tx-buffer\n                assignment statement that specifies how large, in bytes, the space reserved\n                for the longest response message. The integer for each\n                statement must be in the range [1, 4095]. If omitted, a default is used.\n              \n                \n                  Note: Applications which need to support the transmission of a long list of\n                  supported DTCs  will  need a large transmit buffer. Otherwise, smaller values\n                  can be used to save RAM.",
    "LLR.PLAT.PISO.021": "The platform  shall  provide an optional emissions-report-min-severity\n                assignment statement that specifies the severity level at (or above) which\n                DTCs  will  be reported in emissions-related diagnostic services.\n              \n                The value of emissions-severity must be one of following:\n                sev-a (highest - least errors reported)\n                  sev-b1sev-b2sev-c (default)\n                  sev-none (lowest - all errors reported)\n                  \n              \n                \n                  Note: To emit all DTCs regardless of their emissions severity level,\n                  use sev-none.\n                .",
    "LLR.PLAT.PISO.022": "The platform  shall  set the severity level,\n                emissions-report-min-severity to sev-c\n                if it is ommitted by the application",
    "LLR.PLAT.PISO.030": "The platform shall provide a Simulink interface block named\n                piso_Configuration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionEnable ISO diagnosticsParamBoolean\n        \n          Enables\/disables ISO messaging.\n        \n      \n                Calibratable: no.\n              Transmit message IDParamInteger\n        \n          The unique CAN identifier for the ISO messages transmitted by the system.\n        \n        \n          For standard OBD, ISO 15765-4 requires a value in the hex range 7E8 to\n          7EF for 11-bit IDs (the value being the physical receive ID plus 8),\n          or 18DAF1xx for 29-bit IDs, where xx is the ECU 'source\n          address' in J1939 terms.\n        \n        \n          Range: [0, 2047] if standard identifier\n        \n        \n          Range: [0, 536870911] if extended identifier\n        \n      \n                Calibratable: no.\n              Extended transmit IDParamBoolean\n        \n          Enables\/disables the use of an extended ISO transmit message CAN identifier.\n        \n      \n                Calibratable: no.\n              Receive message IDParamInteger\n        \n          The unique CAN identifier for the ISO messages received by the system.\n        \n        \n          For standard OBD, ISO 15765-4 requires a value in the hex range 7E0 to\n          7E7 for 11-bit IDs (the value being the physical response ID minus 8),\n          or 18DAxxF1 for 29-bit IDs, where xx is the ECU 'node\n          address' in J1939 terms.\n        \n        \n          Range: [0, 2047] if standard identifier\n        \n        \n          Range: [0, 536870911] if extended identifier\n        \n      \n                Calibratable: no.\n              Extended receive IDParamBoolean\n        \n          Enables\/disables the use of an extended ISO receive message CAN identifier.\n        \n      \n                Calibratable: no.\n              Functional receive message IDParamInteger\n        \n          The global CAN identifier for ISO messages received by all participating\n          ECUs in the vehicle.\n        \n        \n          For standard OBD, ISO 15765-4 requires a value of 7DF hex\n          for an 11-bit ID system\n          or 18DB33F1 for a 29-bit ID system.\n        \n        \n          Range: [0, 2047] if standard identifier\n        \n        \n          Range: [0, 536870911] if extended identifier\n        \n      \n                Calibratable: no.\n              CAN bus identifierParamList\n        \n          A drop-down\n          selection of CAN buses available for ISO messaging.\n        \n      \n                Calibratable: no.\n              Size of ISO receive message bufferParamInteger\n        \n          The number\n          of bytes for the ISO receive message buffer. This parameter allows the modeller to\n          reduce the amount of RAM allocated to ISO messages, and therefore increase\n          the RAM allocated to other functions of the ECU.\n        \n        \n          Range: [1, 4095]\n        \n      \n                Calibratable: no.\n              Size of ISO transmit message bufferParamInteger\n        \n          The number\n          of bytes for the ISO transmit message buffer. This parameter allows the modeller to\n          reduce the amount of RAM allocated to ISO messages, and therefore increase\n          the RAM allocated to other functions of the ECU.\n        \n        \n          Range: [1, 4095]\n        \n      \n                Calibratable: no.\n              Tolerate short CAN frames?ParamBoolean\n        \n          Diagnostic messages are segmented into individual CAN frames according to\n          the ISO 15765-2 protocol. ISO 15765-4:2011 requires that full-length\n          (8 byte) CAN frames are used even if the message data does not require all\n          of the data bytes in a frame, and shorter frames should be ignored by the\n          receiver. This is the default platform behaviour.\n        \n        \n          In practice however, some manufacturer's tools may send shorter CAN frames.\n          If required for compatibility with such tools, enable this option to have\n          the platform accept diagnostic messages packed into CAN frames of less\n          than 8 bytes. (Such frames will still be ignored if they are too short\n          to contain the message data, however.)\n        \n        \n          Note that the platform always transmits full 8-byte frames with unused \n          bytes filled with 0 as padding, regardless of this option, in accordance\n          with the standard.\n        \n      \n                Calibratable: no.\n              Emissions severity levelParamList\n        \n          A drop-down\n          selection of the emissions severity level at which a DTC should be\n          considered \"emissions related\". This allows the modeller to combine\n          \"emissions related\" and other DTCs within the same system.\n        \n      \n                Calibratable: no.\n              Number of periodic identifiersParamInteger\n        \n          PIDs for automatic periodic sending must be in the 0xF2nn identifier\n          range. Of those, this parameter is the maximum number that the platform\n          will allow to be simultaneously requested by the test tool for automatic periodic\n          transmission while the application is running via UDS service $2A.\n          Leave at zero if service $2A support is not required, to save RAM.\n        \n        \n          Range: [0, 254]\n        \n      \n                Calibratable: no.\n              Periodic identifier transmission base periodParamInteger\n        \n          The \"fast\" target rate for PIDs requested for automatic transmission\n          via UDS service $2A in milliseconds. The \"medium\" rate is 2x this period, and\n          the \"slow\" rate is 4x this period. The platform will send PIDs\n          more slowly than the target rate if this target cannot be met\n          due to the PID size and transport protocol delays.\n        \n        \n          Range: [20, 65530]\n        \n      \n                Calibratable: no.\n              Number of dynamically defined identifier buffersParamInteger\n        \n          The number of internal buffer slots allocated for the construction\n          of dynamically-defined PIDs via UDS service $2C. If necessary one\n          large PID definition may straddle several internal buffers. Leave at zero\n          if service $2C support is not required, to save RAM.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Override J1979 standard?ParamBoolean\n        \n          If checked, this option allows the user to override the standard message response to\n          J1979 service requests $03, $07 and $0A.  Note that this override option should only be used\n          in exceptional circumstances where it is understood that the resultant message responses will deviate\n          from the J1979 standard.\n        \n      \n                Calibratable: no.\n              Service$03 responseParamList\n        \n          A drop-down\n          selection of the override to apply to a J1979 service request $03 response.  Only available if the\n          Override J1979 standard? parameter is checked.  Note that the platform\n          also provides a calibration to override the response at runtime.\n        \n      \n                Calibratable: no.\n              Service$07 responseParamList\n        \n          A drop-down\n          selection of the override to apply to a J1979 service request $07 response.  Only available if the\n          Override J1979 standard? parameter is checked.  Note that the platform\n          also provides a calibration to override the response at runtime.\n        \n      \n                Calibratable: no.\n              Service$0A responseParamList\n        \n          A drop-down\n          selection of the override to apply to a J1979 service request $0A response.  Only available if the\n          Override J1979 standard? parameter is checked.  Note that the platform\n          also provides a calibration to override the response at runtime.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PISO.130": "The block piso_Configuration shall support the targets:\n            All targets.",
    "LLR.PLAT.PISO.230": "The block piso_Configuration shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PISO.031": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PISO.032": "If the parameter Transmit message ID is outside its\n                range then the block  shall  raise an error.",
    "LLR.PLAT.PISO.033": "If the parameter Receive message ID is outside its\n                range then the block  shall  raise an error.",
    "LLR.PLAT.PISO.034": "If the parameter Size of ISO receive message buffer is outside its\n                range then the block  shall  raise an error.",
    "LLR.PLAT.PISO.035": "If the parameter Size of ISO transmit message buffer is outside its\n                range then the block  shall  raise an error.",
    "LLR.PLAT.PISO.045": "If there is more than one block of type piso_configuration\n                in the model then the block  shall  raise an error.",
    "LLR.PLAT.PISO.046": "If there is no block of type pcx_can_config in the model\n                then the block  shall  raise an error.",
    "LLR.PLAT.PISO.036": "If the mask parameter Enable ISO diagnostics is checked the block\n                 shall  enable iso diagnostics in the platform via the capi file.",
    "LLR.PLAT.PISO.037": "The block  shall  use the mask parameter Transmit message ID to set the\n                iso-diagnostics can-tx-id in the platform via the capi file.",
    "LLR.PLAT.PISO.038": "If the mask parameter Extended transmit ID is checked the block\n                 shall  enable extended transmit ID's in the platform via the capi file.",
    "LLR.PLAT.PISO.039": "The block  shall  use the mask parameter Receive message ID to set the\n                iso-diagnostics can-rx-id in the platform via the capi file.",
    "LLR.PLAT.PISO.040": "If the mask parameter Extended receive ID is checked the block\n                 shall  enable extended transmit ID's in the platform via the capi file.",
    "LLR.PLAT.PISO.041": "The block  shall  use the mask parameter CAN bus identifier\n                to set the iso-diagnostics can-bus in the platform via the capi file.",
    "LLR.PLAT.PISO.042": "The block  shall  use the mask parameter Size of ISO receive message buffer\n                to set the iso-diagnostics size-of-rx-buffer in the platform via the capi file.",
    "LLR.PLAT.PISO.043": "The block  shall  use the mask parameter Size of ISO transmit message buffer\n                to set the iso-diagnostics size-of-tx-buffer in the platform via the capi file.",
    "LLR.PLAT.PISO.044": "The block  shall  use the mask parameter Emissions severity level\n                to set the iso-diagnostics emissions-report-min-severity in the platform via the capi file.",
    "LLR.PLAT.J1939.21.DLL.001": "The J1939 feature  shall  use the Extended Frame CAN format.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.1",
    "LLR.PLAT.J1939.21.DLL.002": "All CAN Data Frames associated with a particular multi-packet response  shall \n              have a DLC of 8.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.2.7.2",
    "LLR.PLAT.J1939.21.DLL.003": "All unused data bytes in a CAN Data Frame associated with a multi-packet\n              response  shall  be set to \"not available\" (ref. SAE J1939-71).\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.2.7.2",
    "LLR.PLAT.J1939.21.DLL.004": "Multi-byte parameters that appear in the data field of a CAN Data Frame\n               shall  be placed Least Significant Byte (LSB) first.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4",
    "LLR.PLAT.J1939.21.DLL.005": "The platform  shall  not transmit a Negative Acknowledgement (NACK) as a response to\n              a global request.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4.2",
    "LLR.PLAT.J1939.21.DLL.006": "The platform  shall  always respond to a request directed at the node address.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4.2",
    "LLR.PLAT.J1939.21.DLL.007": "The platform  shall  support requests using PGN 59904, used to query whether\n              a specific Parameter Group is supported.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4.2",
    "LLR.PLAT.J1939.21.DLL.008": "If a requested Parameter Group is supported, the platform  shall  respond with\n              the Acknowledgement PGN and its control byte set to 0 for Positive Acknowledgement.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4.2",
    "LLR.PLAT.J1939.21.DLL.010": "If a requested Parameter Group is not supported, the platform  shall  respond\n              with the Acknowledgement PGN and its control byte set to 1 for Negative\n              Acknowledgement.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.4.2",
    "LLR.PLAT.J1939.21.DLL.011": "The platform  shall  break up J1939 messages greater than 8 bytes into several\n              smaller packets, which are transmitted in separated message frames.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.1",
    "LLR.PLAT.J1939.21.DLL.012": "Individual J1939 packets  shall  be numbered and transmitted sequentially, in\n              ascending order, starting with packet 1.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.1.2",
    "LLR.PLAT.J1939.21.DLL.013": "The platform  shall  support messages with a data length up to\n              pj1939_size_j1939_rx_buf bytes long, where the absolute\n              maximum size of pj1939_size_j1939_rx_buf is 1785.\n            Rationale: \n              Maximum size of messages specified in SAE J1939-21 (rev. 1998-07) Section 5.10.1.1\n              is 1785, however the implementation allows users to specify a shorter maximum size\n              in order to save RAM space.",
    "LLR.PLAT.J1939.21.DLL.015": "The platform  shall  transmit successive frames of Multipacket Broadcast\n              messages with a 50ms to 200ms gap between them.\n            Rationale: \n              The minimum gap of 50ms assures the responder has time to pull the message from the\n              CAN hardware. SAE J1939-21 (rev. 1998-07) Section 5.10.1.3 and 5.12.3",
    "LLR.PLAT.J1939.21.DLL.016": "Each Data Transfer packet other than the last packet in the transmission\n              sequence  shall  include 7 bytes of the original large message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.1.3",
    "LLR.PLAT.J1939.21.DLL.017": "The last packet in the transmission sequence  shall  include the sequence\n              number, at least one byte of data related to the Parameter Group and\n              any remaining unused bytes set to 0xFF.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.1.3",
    "LLR.PLAT.J1939.21.DLL.018": "The platform  shall  transmit a Broadcast Announce Message (BAM) before\n              broadcasting a multi-packet message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.1",
    "LLR.PLAT.J1939.21.DLL.019": "To reject a connection following the reception of a Request to Send (RTS)\n              message, the platform  shall  respond with a Connection Abort message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.2 and 5.10.3.4",
    "LLR.PLAT.J1939.21.DLL.020": "To accept and establish a connection following the reception of a Request\n              to Send (RTS) message, the platform  shall  respond with a Clear to Send (CTS)\n              message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.2",
    "LLR.PLAT.J1939.21.DLL.021": "The platform  shall  momentarily stop the flow of data if it receives the\n              Clear to Send message with the number of packets to send set to 0, at\n              least once every 0.5s (Th).\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.3",
    "LLR.PLAT.J1939.21.DLL.022": "In case of a destination specific transfer, the platform  shall  transmit\n              an end of message acknowledgement upon the reception of the last packet\n              in the message stream.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.023": "The platform  shall  close out a connection prior to completing the data\n              transfer, if it receives the connection abort message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.024": "The platform  shall  close the connection if more than 750ms\n              (T1)elapse after the receipt of the last packet, when\n              more packets are still expected.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.025": "The platform  shall  close the connection when the originator fails to\n              transmit data within 1250ms (T2) following the CTS\n              message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.026": "The platform  shall  close the connection when it fails to receive a CTS\n              or ACK from the responder within 1250ms (T3) of the\n              last packet transmission.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.027": "The platform  shall  close the connection when it fails to receive a CTS within\n              1050ms (T4)after a CTS (0) message to \"hold the connection open\".\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.2.4",
    "LLR.PLAT.J1939.21.DLL.028": "When the platform receives multiple RTSs (Requests to Send) from the same\n              source address for the same PGN, it  shall  only act upon the most recent RTS\n              and ignore the others.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.1",
    "LLR.PLAT.J1939.21.DLL.029": "The platform  shall  close out a connection if it received multiple CTSs\n              (Clear to Send) after a connection is already established.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.2",
    "LLR.PLAT.J1939.21.DLL.030": "The platform  shall  ignore any CTSs received while a connection is\n              not established.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.2",
    "LLR.PLAT.J1939.21.DLL.031": "The platform  shall  ignore an End of Message Acknowledgement received\n              prior to the final data transfer.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.3",
    "LLR.PLAT.J1939.21.DLL.032": "The process to stop transmitting data packets  shall  take no more than\n              32 data packets.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.4",
    "LLR.PLAT.J1939.21.DLL.033": "The process to stop transmitting data packets  shall  not exceed 50ms.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.3.4",
    "LLR.PLAT.J1939.21.DLL.034": "A node  shall  support one RTS\/CTS and one BAM session concurrently from\n              the same source address.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.10.5.1",
    "LLR.PLAT.J1939.21.DLL.035": "The platform  shall  respond within 200ms\n              (Tr) to a data or flow control message.\n            Rationale: \n              SAE J1939-21 (rev. 1998-07) Section 5.12.3\n            Note: \n              The response time is considerably less than the various timeout periods\n              specified in this section. This provides a large tolerance for networks with\n              multiple bridges that can introduce significant delays between the source\n              and destination nodes.",
    "LLR.PLAT.J1939.81.NML.001": "The platform  shall  provide a mechanism allowing each node to have a unique\n              64-bit NAME (ref. SAE J1939-81 (rev.2003-05) Section 4.1.1).\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.1",
    "LLR.PLAT.J1939.81.NML.002": "The platform  shall  report the node's unique 64-bit NAME when requested.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4",
    "LLR.PLAT.J1939.81.NML.003": "The platform  shall  set the Reserved bit of the NAME\n              identifier to 0.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.1.1.6",
    "LLR.PLAT.J1939.81.ADDR.001": "The platform  shall  handle the network management J1939 messages (including\n              claiming an address on startup, handling claims on that address, etc.).",
    "LLR.PLAT.J1939.81.ADDR.015": "The platform  shall  use a calibration parameter to intialise its preferred\n              node address at start-up time.\n            Rationale: \n              Requested by Torchwood customer and likely to be useful to others.",
    "LLR.PLAT.J1939.81.ADDR.002": "If the preferred address from the configuration interface cannot be claimed,\n              the software  shall  claim the NULL network address.",
    "LLR.PLAT.J1939.81.ADDR.003": "The platform  shall  not transmit normal network messages prior to the node\n              successfully claiming an address.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.1",
    "LLR.PLAT.J1939.81.ADDR.004": "The platform  shall  report a node's inability to successfully claim an address in a\n              standard manner (ref. SAE J1939-81 (rev.2003-05) section 4.3).\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4",
    "LLR.PLAT.J1939.81.ADDR.006": "If a node loses address arbitration whilst in the process of sending a transport\n              protocol message, the platform  shall  immediately cease transmitting the transport\n              protocol message.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.2.2",
    "LLR.PLAT.J1939.81.ADDR.007": "If a node loses address arbitration whilst in the process of sending a transport\n              protocol message and ceases transmitting the transport protocol message, the\n              platform  shall  not send a Transport Protocol Abort message.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.2.2",
    "LLR.PLAT.J1939.81.ADDR.008": "If a node has successfully claimed an address, the platform  shall  respond to a Request\n              for Address Claimed message with the Address Claimed message directed to the Global\n              Address (255).\n            Rationale: \n              Sending the address claimed message to the global address allows all ECUs on the\n              network to maintain the current address to NAME correspondence. SAE J1939-81 (rev.2003-05)\n              Section 4.2.1, 4.2.2, 4.4.3.1 and 4.4.3.2",
    "LLR.PLAT.J1939.81.ADDR.009": "If a node was unable to claim an address, the platform  shall  respond to a Request for\n              Address Claimed message directed at the Global Address (255) with\n              the Cannot Claim Address message.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.2.1 and 4.4.3.1",
    "LLR.PLAT.J1939.81.ADDR.010": "The platform  shall  insert a pseudo-random delay of 0ms to 153ms between the reception\n              message triggering the response and the Cannot Claim Address response.\n            Rationale: \n              This delay minimises the possibility of a bus error, caused by two nodes sending the\n              same message with identical message IDs. SAE J1939-81 (rev.2003-05) Section 4.2.2.3",
    "LLR.PLAT.J1939.81.ADDR.012": "When a node receives a competing claim for its address, the platform  shall  transmit\n              an address claim if the node's NAME is of lower value (higher priority).\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.4.3.3",
    "LLR.PLAT.J1939.81.ADDR.013": "When a node receives a competing claim for its address, the platform  shall  stop\n              using that address if the node's NAME is of higher value (lower priority).\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.4.3.3",
    "LLR.PLAT.J1939.81.ADDR.014": "If a node cannot use an address due to a higher priority competing claim, the platform\n               shall  transmit the Cannot Claim Address message.\n            Rationale: \n              SAE J1939-81 (rev.2003-05) Section 4.4.3.4\n            Note: \n              Our platform does not support dynamic addressing hence the ECU cannot attempt to\n              claim another address.",
    "LLR.PLAT.J1939.21.PGRQ.001": "If the node address for the ECU cannot be claimed, then the software  shall  ignore\n                any received PG request messages.\n              Rationale: \n                Although a network address has not been claimed, a request for PG message broadcast to\n                all J1939 nodes could still be received. Regardless, the software must ignore the\n                request as there is no claimed address to use for a reply message.",
    "LLR.PLAT.J1939.21.PGRQ.002": "If a PG request message is received (addressed globally or not) and the requested PG\n                matches an application declared PGN, then the platform  shall  remember that the PG\n                request has been made.",
    "LLR.PLAT.J1939.21.PGRQ.003": "If a PG request message is received (not addressed globally) but the requested PG\n                does not match an application declared PGN, then the platform  shall  respond with a\n                NACK to the sender of the PG request message.",
    "LLR.PLAT.J1939.21.PGRQ.004": "If a PG request message is received (addressed globally) but the requested PG does\n                not match an application declared PGN, then the platform  shall  not respond with a NACK\n                to the sender of the PG request message.\n              Rationale: \n                This behaviour matches J1939-21 and avoids a burst of NACK messages from multiple nodes\n                which might adversely affect the delivery timing of other CAN frames to be transmitted on\n                the CAN bus.",
    "LLR.PLAT.J1939.21.PGRQ.005": "The platform shall provide a C interface function named\n                pj1939_was_pgn_requested() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn_idx\n          in\n        const U32\nThe index into the pj1939_pgn_requested_table[] array, thus identifying the requested PGN to work with.\n Use the macros included by the header file generated from the interface tool, of the form PJ1939_PGN_TABLE_IDX_[PGN-NUMBER].\n Range: [0, pj1939_num_requested_pgns - 1]pj1939f_timestamp\n          out\n        U32 *\nA pointer to the location to write the timestamp of the received message.\n Cannot be NULL.\n Range: [0, 4294967295] uspj1939f_requested\n          out\n        U8 *\nA pointer to the location to write the result of searching for the PGN. Written true if the PGN has been requested, written false otherwise. The request status is cleared after the search.\n Cannot be NULL.pj1939f_source_addr\n          out\n        U8 *\nA pointer to the location to write the source address of the J1939 message requesting the PGN.\n Cannot be NULL.\n Range of source address: [0, 253]pj1939f_dest_addr\n          out\n        U8 *\nA pointer to the location to write the destination address of the J1939 message requesting the PGN.\n Cannot be NULL.\n Range of destination address: [0, 253 or 255]\n                The function returns void.",
    "LLR.PLAT.J1939.21.PGRQ.105": "The function pj1939_was_pgn_requested() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.21.PGRQ.205": "The function pj1939_was_pgn_requested() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.21.PGRQ.006": "The platform  shall  reject calls where any of the input parameters are\n                pointers to NULL, by raising  a recoverable error\n                PSY_PJ1939\/PJ1939_WAS_REQ_PGN_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PGRQ.007": "The platform  shall  reject calls where the parameter\n                 pj1939f_pgn_idx is too large an index, by raising a\n                recoverable error PSY_PJ1939\/PJ1939_WAS_REQ_PGN_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PGRQ.008": "If the sub-parts of a requested PG message match the \u201cPDU datapage\u201d,\n                \u201cPDU format\u201d and \u201cPDU specific\u201d indexed by\n                pj1939_pgn_requested_table[pj1939f_pgn_idx], then the platform\n                 shall  set pj1939f_source_addr to the message's SA field,\n                set pj1939f_dest_addr to the message's DA field, set\n                pj1939f_requested to true, and forget that the PG request has\n                been made.",
    "LLR.PLAT.J1939.21.PGRQ.009": "Otherwise, the requested PG message does not match the block,\n                and the platform  shall  set pj1939f_source_addr and\n                pj1939f_dest_addr to zero and pj1939f_requested to false\n                (indicating that the PG was not requested).",
    "LLR.PLAT.J1939.21.PGRQ.010": "The platform shall provide a Simulink interface block named\n                pj1939_PgRequested that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_requestedInportBoolean\n        \n          Simulation value for the\n          inport requested.\n        \n      sim_source_addrInportInteger\n        \n          Simulation value for the\n          inport source_addr.\n        \n      sim_dest_addrInportInteger\n        \n          Simulation value for the\n          inport dest_addr. Available only if the parameter PDU format is less than 240.\n        \n      sim_timestampInportInteger\n        \n          The simulation\n          value for the outport timestamp.\n          Available only if the mask parameter\n          Provide timestamp is selected.\n        \n      requestedOutportBoolean\n        \n          Set to 1 if the pgn\n          defined by the parameters PDU datapage, PDU format and PDU specific\n          matches a request message.\n        \n        \n          Range: 0 or 1\n        \n      source_addrOutportInteger\n        \n          The source J1939 network address\n          of the request message.\n        \n        \n          Range: [0, 253] or 255\n        \n      dest_addrOutportInteger\n        \n          The destination J1939 network address\n          of the request message. Available only if the parameter PDU format is less than 240.\n        \n        \n          Range: [0, 253] or 255\n        \n      timestampOutportInteger\n        \n          The time when the last\n          valid message was received. Strictly this gives the time when the message\n          was assembled from the possibly multiple CAN packets, and has a resolution\n          of 50 ms. The timestamp is a free-running microsecond timer that wraps to\n          zero approximately every 70 minutes. Available only if the mask parameter\n          Provide timestamp is selected.\n        \n        \n          Range: [0, 4294967295] us\n        \n      PDU datapageParamInteger\n        \n          The pdu datapage value\n          of the PGN to match against a J1939 request message.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              PDU formatParamInteger\n        \n          The pdu format value\n          of the PGN to match against a J1939 request message.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              PDU specificParamInteger\n        \n          The pdu specific value\n          of the PGN to match against a J1939 request message. If the PDU format parameter\n          is less than 240, then this parameter is not available for editing and does\n          not form part of the PGN.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of\n          the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide timestampParamBoolean\n        \n          If selected then inport sim_timestamp\n          and outport timestamp are made available.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.21.PGRQ.110": "The block pj1939_PgRequested shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.21.PGRQ.210": "The block pj1939_PgRequested shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.21.PGRQ.011": "The block  shall  raise an error if the model does not contain the pj1939_Configuration block.",
    "LLR.PLAT.J1939.21.PGRQ.012": "If the parameter PDU datapage is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PGRQ.013": "If the parameter PDU format is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PGRQ.014": "The block  shall  raise an error if the value of PDU format\n                is greater than or equal to 240 and the parameter PDU specific\n                is outside its range.",
    "LLR.PLAT.J1939.21.PGRQ.016": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PGRQ.017": "If the value of PDU format is less than 240, then the\n                block  shall  raise an error if another pj1939_pg_requested block with identical\n                PDU datapage and\n                PDU format parameters exists in the model.",
    "LLR.PLAT.J1939.21.PGRQ.018": "If the value of PDU format is greater than or equal to 240,\n                then the block  shall  raise an error if another pj1939_PgRequested block with\n                identical PDU datapage,\n                PDU format and\n                PDU specific parameters exists in the model.",
    "LLR.PLAT.J1939.21.PGRQ.019": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.21.PGRQ.020": "The block  shall  set the value of outports, requested,\n                source_addr and\n                dest_addr to the value of inports,\n                sim_requested,\n                sim_source_addr and\n                sim_dest_addr respectively.\n              Rationale: \n                The Simulink simulation environment does not easily allow the construction of CAN\n                messages, so a simulation of the outports allows the user to construct a test\n                framework for the model by emulating requests for PGs.",
    "LLR.PLAT.J1939.21.PGRQ.021": "If the sub-parts of a requested PG message matches the respective block parameters,\n                PDU datapage,\n                PDU format and\n                PDU specific, then the block  shall \n                set the outport source_addr\n                to the message's SA field, set the outport\n                dest_addr to the message's\n                DA field, set the outport requested true, and forget that the PG\n                request has been made.",
    "LLR.PLAT.J1939.21.PGRQ.022": "Otherwise, the requested PG message does not match, and the block  shall \n                set the outports, source_addr,\n                dest_addr and\n                requested to zero.",
    "LLR.PLAT.J1939.21.PG-RX.001": "The platform  shall  signal an error condition if the PG receive interface is called\n                whilst the associated J1939 CAN bus is unavailable.",
    "LLR.PLAT.J1939.21.PG-RX.002": "The platform  shall  signal an error condition if the PG receive interface is called\n                when the node has been assigned the NULL address.",
    "LLR.PLAT.J1939.21.PG-RX.003": "The platform  shall  buffer those PGNs that have been declared by the application\n                and ignore all others.",
    "LLR.PLAT.J1939.21.PG-RX.004": "The platform  shall  buffer only the most recent message for a given PGN, overwriting\n                previous data whether it has been processed or not.",
    "LLR.PLAT.J1939.21.PG-RX.005": "The platform  shall  indicate an overflow, when a new PG message is received whilst\n                the previous message has not yet been processed.",
    "LLR.PLAT.J1939.21.PG-RX.006": "The platform  shall  ignore PG messages whose length does not match the length\n                defined by the application for that PGN.",
    "LLR.PLAT.J1939.21.PG-RX.007": "The interface  shall  unpack the PG message data based on the start position, size,\n                sign and packing parameters.",
    "LLR.PLAT.J1939.21.PG-RX.008": "The platform  shall  reset the \"received\" status of the given PG message once the\n                PG receive interface processes that message.",
    "LLR.PLAT.J1939.21.PG-RX.009": "The platform shall provide a C interface function named\n                pj1939_pg_receive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn_idx\n          in\n        const U32\nThe index into the _pgn_table[] and pj1939_rx_buf[] arrays, thus identifying the received PGN message to work with.\n Use the macros included by the header file generated from the interface tool, of the form PJ1939_PGN_TABLE_IDX_[PGN-NUMBER].\n Range: [0, pj1939_num_pgns - 1]pj1939f_timestamp\n          out\n        U32 *\nA pointer to the location to write the timestamp of the received message.\n Cannot be NULL.\n Range: [0, 4294967295] uspj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write the error status of receiving the J1939 message. Written true if there was an error when receiving the message last time, written false otherwise. An error occurs if the length of the J1939 message data contents does not match pj1939f_message_len, or if this node has lost its address claim, or if this node is currently bus-off.\n Cannot be NULL.pj1939f_rx_trig_flag\n          out\n        U8 *\nA pointer to the location to write the status of receiving the J1939 message. Written true if the message was received since the last call, written false otherwise.\n Cannot be NULL.pj1939f_overrun_flag\n          out\n        U8 *\nA pointer to the location to write the status of receiving the J1939 message. Written true if the message was received more than once since the last call, written false otherwise.\n Cannot be NULL.pj1939f_source_addr\n          out\n        U8 *\nA pointer to the location to write the source address of the received J1939 message. Range of source address: [0, 253] Cannot be NULL.pj1939f_dest_addr\n          out\n        U8 *\nA pointer to the location to write the destination address of the received J1939 message.\n Can be NULL (in which case, it is not written).\n Range of destination address: [0, 253 or 255]pj1939f_message_len\n          in\n        const U16\nThe expected length of the data contents of the received J1939 message.\n Range: [0, 1785] bytespj1939f_num_fields\n          in\n        const U16\nNumber of fields in each of pj1939f_item_ptr, pj1939f_field_start_pos, pj1939f_field_width, pj1939f_field_sign, and pj1939f_field_packing. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument. \n Range: [0, 65535] fieldspj1939f_item_ptr\n          in\n        void *const *\nPointer to array of pointers to data to be unpacked from the receive buffer. Each item in this array should point to 32-bit signed or unsigned integer.\n Cannot be NULL.pj1939f_field_start_pos\n          in\n        const U16 *\nPointer to array of field start bit numbers. For each item to unpack from the J1939 message, the function determines where to retrieve the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 0 of the message, 15 to the most significant bit of data byte 2 of the message, and so on, assuming these exist.\n Cannot be NULL.pj1939f_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from the J1939 message, the function determines how many bits to retrieve from the array using the corresponding element from this array.\n Cannot be NULL.\n Range: [1, 32]pj1939f_field_sign\n          in\n        const U8 *\nPointer to array of sign flags (flag set true if signed, false otherwise). For each item to unpack from the J1939 message, the function determines whether to use the MSB of the packed data as a sign bit or not.\n Cannot be NULL.pj1939f_field_packing\n          in\n        const U8 *\nPointer to array of byte ordering flags (flag set true if field's data bytes are ordered most significant byte first, false if field's data bytes are ordered least significant byte first (as is typical for J1939 data)). For each item to unpack from the J1939 message, the function determines whether to unpack MSB or LSB.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.21.PG-RX.109": "The function pj1939_pg_receive() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.21.PG-RX.209": "The function pj1939_pg_receive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.21.PG-RX.010": "The platform  shall  reject calls with a NULL pointer in any of\n                the following parameters pj1939f_error_flag,\n                pj1939f_rx_trig_flag, pj1939f_overrun_flag,\n                pj1939f_source_addr, pj1939f_item_ptr,\n                pj1939f_field_start_pos, pj1939f_field_width\n                or pj1939f_field_sign by raising a recoverable error\n                PSY_PJ1939\/PJ1939_PG_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PG-RX.011": "The platform  shall  reject calls where the parameter\n                 pj1939f_pgn_idx is too large an index, by raising a\n                recoverable error PSY_PJ1939\/PJ1939_PG_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PG-RX.012": "The platform  shall  reject calls with the message length parameter\n                pj1939f_message_len greater than the corresponding buffer size\n                defined in pj1939f_rx_buf_data_size, by raising a recoverable\n                error PSY_PJ1939\/PJ1939_PG_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PG-RX.013": "The platform  shall  reject calls with the message length parameter\n                pj1939f_message_len greater than 1785, by raising a recoverable\n                error PSY_PJ1939\/PJ1939_PG_RECEIVE_INVALID_ARG.\n              Rationale: \n              1785 is the maximum size of messages specified in SAE J1939-21 (rev. 1998-007)\n              Section 5.10.1.1.",
    "LLR.PLAT.J1939.21.PG-RX.014": "If a new PG message indexed by pj1939_rx_buf[pj1939f_pgn_idx]\n                has been received, then the platform  shall  set pj1939f_source_addr\n                to the message's SA field, set pj1939f_item_ptr to the unpacked\n                message data, set pj1939f_rx_trig_flag to true and set\n                pj1939f_error_flag to false.",
    "LLR.PLAT.J1939.21.PG-RX.015": "If a new PG message indexed by pj1939_rx_buf[pj1939f_pgn_idx]\n                has not been received or an error occurred, the platform  shall  set\n                pj1939f_source_addr and pj1939f_item_ptr to\n                0, set pj1939f_rx_trig_flag to false and\n                pj1939f_error_flag to true.",
    "LLR.PLAT.J1939.21.PG-RX.016": "If a new PG message has been received, no error occurred and\n                pj1939f_dest_addr is not NULL, the platform\n                 shall  set pj1939f_dest_addr to the received PG message's DA\n                field, or 0 otherwise.",
    "LLR.PLAT.J1939.21.PG-RX.017": "The platform  shall  set the pj1939f_overrun_flag to true if\n                a message with the specified PGN has been received more than once since the\n                last call, and false otherwise.",
    "LLR.PLAT.J1939.21.PG-RX.018": "The platform shall provide a Simulink interface block named\n                pj1939_PgReceive that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          Simulation value for the\n          outport error_flag.\n        \n      sim_rx_trig_flagInportBoolean\n        \n          Simulation value for the\n          outport rx_trig_flag.\n        \n      sim_overrun_flagInportBoolean\n        \n          Simulation value for the\n          outport overrun_flag.\n        \n      sim_source_addrInportInteger\n        \n          Simulation value for the\n          outport source_addr.\n        \n      sim_dest_addrInportInteger\n        \n          Simulation value for the\n          outport dest_addr. Available only if the parameter PDU format is less than 240.\n        \n      sim_timestampInportInteger\n        \n          The simulation\n          value for the outport timestamp.\n          Available only if the mask parameter\n          Provide timestamp is selected.\n        \n      sim_fieldsInportInteger\n        \n          A set of simulation inports\n          for the corresponding outports fields. Available if there is at least one field and the parameter\n          Provide simulation input? is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if some error has\n          occurred which prevents CAN reception, or 0 otherwise. Errors which prevent\n          reception are: CAN bus detected as bus-off, or the length of the received\n          J1939 message does not match the Message length parameter.\n        \n        \n          Range: 0 or 1\n        \n      rx_trig_flagOutportBoolean\n        \n          Set to 1 if the block\n          has detected reception of the J1939 message since the last iteration of this\n          block, set to zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      overrun_flagOutportBoolean\n        \n          Set to 1 if the block\n          has detected reception of the same J1939 message more than once between\n          iterations of this block.\n        \n        \n          Range: 0 or 1\n        \n      source_addrOutportInteger\n        \n          The source J1939 network address\n          of the message.\n        \n        \n          Range: [0, 253] or 255\n        \n      dest_addrOutportInteger\n        \n          The destination J1939 network address\n          of the message. Available only if the parameter PDU format is less than 240.\n        \n        \n          Range: [0, 253] or 255\n        \n      timestampOutportInteger\n        \n          The time when the last\n          valid message was received. Strictly this gives the time when the message\n          was assembled from the possibly multiple CAN packets, and has a resolution\n          of 50 ms. The timestamp is a free-running microsecond timer that wraps to\n          zero approximately every 70 minutes. Available only if the mask parameter\n          Provide timestamp is selected.\n        \n        \n          Range: [0, 4294967295] us\n        \n      fieldsOutportReal\n        \n          An outport for each field specified\n          in the block.\n        \n      PDU datapageParamInteger\n        \n          The pdu datapage value\n          of the PGN of the J1939 message to receive.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              PDU formatParamInteger\n        \n          The pdu format value\n          of the PGN of the J1939 message to receive.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              PDU specificParamInteger\n        \n          The pdu specific value\n          of the PGN of the J1939 message to receive. If the PDU format parameter\n          is less than 240, then this parameter is not available for editing and does\n          not form part of the PGN.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Message lengthParamInteger\n        \n          The length of the data bytes\n          in the message to be received.\n        \n        \n          Range: [0, 1785]\n        \n      \n                Calibratable: no.\n              Field start positionsParamInteger\n        \n          A vector of bit\n          numbers indicating the start position of each field in the CAN message.\n        \n        \n            Field start positions correspond to the message data bytes as follows:\n          Data byteBit numberLSMS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LS1876543212161514131211109......17851428014279142781427714276142751427414273MSMS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LS\n            where byte 1 corresponds to the first received data byte in the\n            first CAN message for the J1939 message. This numbering scheme\n            matches the J1939 specification but differs from the existing CAN\n            blocks. Although this may cause some confusion when both blocks\n            are used in the same model, it will help reduce mistakes when\n            using the J1939 blockset with the J1939 specification of message\n            contents.\n          \n      \n                Calibratable: no.\n              Field widthsParamInteger\n        \n          A vector of bit lengths\n          indicating the number of bits allocated to each field.\n        \n        \n          Range: [1, 32] bits\n        \n        \n            A field which starts at bit 5 and has 10 bits of width is identified as\n            follows:\n          Data byteBit number18765----2--14131211109\n      \n                Calibratable: no.\n              Field signsParamInteger\n        \n          A vector of zero or one\n          values, corresponding to each field. Fields for which this is set 1 are received\n          as twos-complement signed numbers, or unsigned numbers otherwise.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Field packingParamInteger\n        \n          A vector of zero or one\n          values, corresponding to each field. Fields for which this is set 1 are received\n          as MS packing, or LS packing otherwise.\n        \n        \n          Range: 0 or 1\n        \n        \n            J1939 message fields are generally packed LS byte first, so the field which starts at bit\n            5 and has 10 bits of width, would be interpreted as:\n          MSLSData byte 2Data byte 1------141312111098765ssssssxxxxxxxxxx\n            where 'x' is the corresponding bit taken from the J1939\n            message data bytes, and 's' is the sign extension of the\n            data. In this case, bit 14 may be considered the sign bit, if the data in the\n            J1939 message data is signed.\n          \n            However, if the J1939 message field was packed MS byte first, the bits would be\n            interpreted as:\n          MSLSData byte 1Data byte 2------651413121110987ssssssxxxxxxxxxx\n            where 'x' is the corresponding bit taken from the J1939\n            message data bytes, and 's' is the sign extension of the\n            data. In this case, bit 6 may be considered the sign bit, if the data in the\n            J1939 message data is signed.\n          \n      \n                Calibratable: no.\n              Field mnemonicsParamString\n        \n          A string containing a\n          comma-separated list of names with which to label the simulation field inports and\n          message field outports.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Provide simulation input?ParamBoolean\n        \n          If selected then create simulation inports (sim_fields) for each of the outport\n          message signals (fields).\n        \n      \n                Calibratable: no.\n              Provide timestampParamBoolean\n        \n          If selected then inport sim_timestamp\n          and outport timestamp are made available.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of\n          the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.21.PG-RX.118": "The block pj1939_PgReceive shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.21.PG-RX.218": "The block pj1939_PgReceive shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.21.PG-RX.019": "The block  shall  raise an error if the model does not contain the pj1939_Configuration block.",
    "LLR.PLAT.J1939.21.PG-RX.020": "If the parameter PDU datapage is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.021": "If the parameter PDU format is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.022": "If the parameter PDU specific is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.024": "If the parameter Message Length is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.051": "If the parameter Message Length is not within the\n                Size of J1939 message buffers\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.025": "If the following mask arrays are not all the same length then the block  shall  raise an error:\n                Field start positionsField widthsField signsField packing",
    "LLR.PLAT.J1939.21.PG-RX.026": "The block  shall  raise an error if any fields overlap.",
    "LLR.PLAT.J1939.21.PG-RX.027": "The block  shall  raise an error if the number of used bits exceeds the message bit length.",
    "LLR.PLAT.J1939.21.PG-RX.028": "If any of the elements in the Field widths array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.029": "If any of the elements in the Field signs array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.030": "If any of the elements in the Field start positions array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.031": "If any of the elements in the Field packing array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.032": "The block  shall  raise an error if any field with a bit width of 1, as specified in the parameter\n                Field widths, is declared as signed in the corresponding parameter\n                Field signs.",
    "LLR.PLAT.J1939.21.PG-RX.033": "If Message Length is exceeded then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.034": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-RX.052": "If any of the following arrays are undefined then the block  shall  raise an error:\n                Field start positions,\n                  Field widths,\n                  Field signsField packing",
    "LLR.PLAT.J1939.21.PG-RX.050": "If the value of parameter PDU format is less than 240,\n                then the block  shall  raise an error if another pj1939_PgReceive block with identical\n                PDU datapage and\n                PDU format parameters exists in the model.",
    "LLR.PLAT.J1939.21.PG-RX.053": "If the value of parameter PDU format is greater than or equal to 240,\n                then the block  shall  raise an error if another pj1939_PgReceive block with identical\n                PDU datapage,\n                PDU format and\n                PDU specific parameters exists in the model.",
    "LLR.PLAT.J1939.21.PG-RX.035": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.21.PG-RX.060": "If Provide simulation input? is false then all of the block\n                outports  shall  be zero, otherwise the inports shall be copied as follows.",
    "LLR.PLAT.J1939.21.PG-RX.036": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.21.PG-RX.037": "The value of the inport sim_rx_trig_flag\n                is written to the outport rx_trig_flag.",
    "LLR.PLAT.J1939.21.PG-RX.038": "The value of the inport sim_overrun_flag\n                is written to the outport overrun_flag.",
    "LLR.PLAT.J1939.21.PG-RX.039": "The value of the inport sim_source_addr\n                is written to the outport source_addr.",
    "LLR.PLAT.J1939.21.PG-RX.040": "The value of the inport sim_dest_addr\n                is written to the outport dest_addr.",
    "LLR.PLAT.J1939.21.PG-RX.041": "The value of the inport(s), sim_fields\n                are written to the corresponding outport(s), fields.",
    "LLR.PLAT.J1939.21.PG-RX.055": "If the value of parameter PDU format is less than 240,\n                then the block  shall  disable the parameter PDU specific.",
    "LLR.PLAT.J1939.21.PG-RX.048": "If the value of parameter PDU format is less than 240,\n                then the block  shall  add the following ports (if not already available) after the\n                sim_source_addr and\n                source_addr inport and outport:\n                sim_dest_addrdest_addr",
    "LLR.PLAT.J1939.21.PG-RX.042": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.21.PG-RX.043": "The block  shall  write the status of the PGN request to the outport\n                rx_trig_flag.",
    "LLR.PLAT.J1939.21.PG-RX.044": "The block  shall  write the buffer overrun status to the outport\n                overrun_flag.",
    "LLR.PLAT.J1939.21.PG-RX.045": "The block  shall  write the source address of the PGN request to the outport\n                source_addr.",
    "LLR.PLAT.J1939.21.PG-RX.046": "If PDU format is less than 240 then the block  shall  write the\n                destination address of the PGN request to the outport\n                dest_addr.",
    "LLR.PLAT.J1939.21.PG-RX.047": "The block  shall  detect messages on the J1939 bus specified by\n                PDU datapage,\n                PDU format,\n                and\n                PDU specific.",
    "LLR.PLAT.J1939.21.PG-RX.049": "The block  shall  unpack the detected messages with the field positions,\n                widths, signs and packing specified by\n                Field start positions,\n                Field widths,\n                Field signs,\n                and\n                Field packing.",
    "LLR.PLAT.J1939.21.PG-RX.054": "The block  shall  update the outports specified by\n                Field Mnemonics\n                with the unpacked data.",
    "LLR.PLAT.J1939.21.PG-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.21.PG-TX.002": "The platform  shall  signal an error condition if the PG transmit interface is called\n                whilst the associated J1939 CAN bus is unavailable.",
    "LLR.PLAT.J1939.21.PG-TX.003": "The platform  shall  signal an error condition if the PG transmit interface is\n                called when the node has been assigned the NULL address.",
    "LLR.PLAT.J1939.21.PG-TX.004": "The platform  shall  signal an error condition if there is no available transmit\n                buffer for the PG message.",
    "LLR.PLAT.J1939.21.PG-TX.005": "The platform  shall  accumulate the number of transmit errors encountered by the\n                transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.21.PG-TX.006": "The platform  shall  pack data into the PG message based on the start position,\n                size and packing order parameters.",
    "LLR.PLAT.J1939.21.PG-TX.007": "The platform  shall  restrict data values to their predefined sizes by applying\n                a bit mask based on the field width parameter.",
    "LLR.PLAT.J1939.21.PG-TX.008": "When queueing new PG messages, the platform  shall  drop older messages with the\n                same PGN that have not yet been transmitted.",
    "LLR.PLAT.J1939.21.PG-TX.009": "The platform shall provide a C interface function named\n                pj1939_pg_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn\n          in\n        const U32\nThe PGN value of the J1939 transmit message including the PS field. The PS field of the PGN must represent the destination address for PDU1 format. If the PS field is zero, the message will be broadcasted globally (PDU2 format). Range: [0, 131071]pj1939f_priority\n          in\n        U8\nThe priority of the J1939 message to transmit. The lower the priority value, the higher the message priority. \n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the error status of transmitting the J1939 message. Written true if there was an error when transmitting the message this time, written false otherwise. An error occurs if there are no free buffers to store the transmit message, or if the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off. \n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA saturated count of the transport transmit errors encountered while transmitting a J1939 message. The transport layer is only involved if the message must be broken into more than one CAN message (i.e., the data content of the message exceeds 8 data bytes). \n Cannot be NULL. \n Range: [0, 255] errorspj1939f_message_len\n          in\n        const U16\nThe length of the data contents of the J1939 transmit message.\n Range: [0, 1785] bytespj1939f_num_fields\n          in\n        const U16\nNumber of fields in each of pj1939f_item_ptr, pj1939f_field_start_pos, pj1939f_field_width and pj1939f_field_packing. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument. \n Range: [0, 65535] fieldspj1939f_item_ptr\n          in\n        void *const *\nPointer to array of pointers to data to be packed into the transmit buffer.\n Cannot be NULL.pj1939f_field_start_pos\n          in\n        const U16 *\nPointer to array of field start bit numbers. For each item to unpack from the J1939 message, the function determines where to retrieve the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 1 of the message, 15 to the most significant bit of data byte 2 of the message, and so on, assuming these exist.\n Cannot be NULL.pj1939f_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from the J1939 message, the function determines how many bits to retrieve from the array using the corresponding element from this array.\n Cannot be NULL.\n Range: [1, 32]pj1939f_field_packing\n          in\n        const U8 *\nPointer to array of byte ordering flags (flag set true if field's data bytes are ordered most significant byte first, false if field's data bytes are ordered least significant byte first (as is typical for J1939 data)). For each item to unpack from the J1939 message, the function determines whether to unpack MSB or LSB.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.21.PG-TX.109": "The function pj1939_pg_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.21.PG-TX.209": "The function pj1939_pg_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.21.PG-TX.044": "The platform shall provide a C interface function named\n                pj1939_pdu1_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn\n          in\n        const U32\nThe PGN value of the J1939 transmit message. Range: [0, 130816]pj1939f_dest_addr\n          in\n        const U8\nThe destination address for the J1939 transmit message. Range: [0, 255]pj1939f_priority\n          in\n        U8\nThe priority of the J1939 message to transmit. The lower the priority value, the higher the message priority. \n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the error status of transmitting the J1939 message. Written true if there was an error when transmitting the message this time, written false otherwise. An error occurs if there are no free buffers to store the transmit message, or if the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off. \n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA saturated count of the transport transmit errors encountered while transmitting a J1939 message. The transport layer is only involved if the message must be broken into more than one CAN message (i.e., the data content of the message exceeds 8 data bytes). \n Cannot be NULL. \n Range: [0, 255] errorspj1939f_message_len\n          in\n        const U16\nThe length of the data contents of the J1939 transmit message.\n Range: [0, 1785] bytespj1939f_num_fields\n          in\n        const U16\nNumber of fields in each of pj1939f_item_ptr, pj1939f_field_start_pos, pj1939f_field_width and pj1939f_field_packing. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument. \n Range: [0, 65535] fieldspj1939f_item_ptr\n          in\n        void *const *\nPointer to array of pointers to data to be packed into the transmit buffer.\n Cannot be NULL.pj1939f_field_start_pos\n          in\n        const U16 *\nPointer to array of field start bit numbers. For each item to unpack from the J1939 message, the function determines where to retrieve the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 1 of the message, 15 to the most significant bit of data byte 2 of the message, and so on, assuming these exist.\n Cannot be NULL.pj1939f_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from the J1939 message, the function determines how many bits to retrieve from the array using the corresponding element from this array.\n Cannot be NULL.\n Range: [1, 32]pj1939f_field_packing\n          in\n        const U8 *\nPointer to array of byte ordering flags (flag set true if field's data bytes are ordered most significant byte first, false if field's data bytes are ordered least significant byte first (as is typical for J1939 data)). For each item to unpack from the J1939 message, the function determines whether to unpack MSB or LSB.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.21.PG-TX.144": "The function pj1939_pdu1_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.21.PG-TX.244": "The function pj1939_pdu1_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.21.PG-TX.045": "The platform shall provide a C interface function named\n                pj1939_pdu2_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn\n          in\n        const U32\nThe PGN value of the J1939 transmit message. Range: [0, 130816]pj1939f_priority\n          in\n        U8\nThe priority of the J1939 message to transmit. The lower the priority value, the higher the message priority. \n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the error status of transmitting the J1939 message. Written true if there was an error when transmitting the message this time, written false otherwise. An error occurs if there are no free buffers to store the transmit message, or if the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off. \n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA saturated count of the transport transmit errors encountered while transmitting a J1939 message. The transport layer is only involved if the message must be broken into more than one CAN message (i.e., the data content of the message exceeds 8 data bytes). \n Cannot be NULL. \n Range: [0, 255] errorspj1939f_message_len\n          in\n        const U16\nThe length of the data contents of the J1939 transmit message.\n Range: [0, 1785] bytespj1939f_num_fields\n          in\n        const U16\nNumber of fields in each of pj1939f_item_ptr, pj1939f_field_start_pos, pj1939f_field_width and pj1939f_field_packing. The function does not check that all arrays have the same length. The results of the function are undefined if the length of each differs from this function argument. \n Range: [0, 65535] fieldspj1939f_item_ptr\n          in\n        void *const *\nPointer to array of pointers to data to be packed into the transmit buffer.\n Cannot be NULL.pj1939f_field_start_pos\n          in\n        const U16 *\nPointer to array of field start bit numbers. For each item to unpack from the J1939 message, the function determines where to retrieve the data using the corresponding element from this array. 0 corresponds to the least significant bit of data byte 1 of the message, 15 to the most significant bit of data byte 2 of the message, and so on, assuming these exist.\n Cannot be NULL.pj1939f_field_width\n          in\n        const U8 *\nPointer to array of field bit widths. For each item to unpack from the J1939 message, the function determines how many bits to retrieve from the array using the corresponding element from this array.\n Cannot be NULL.\n Range: [1, 32]pj1939f_field_packing\n          in\n        const U8 *\nPointer to array of byte ordering flags (flag set true if field's data bytes are ordered most significant byte first, false if field's data bytes are ordered least significant byte first (as is typical for J1939 data)). For each item to unpack from the J1939 message, the function determines whether to unpack MSB or LSB.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.21.PG-TX.145": "The function pj1939_pdu2_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.21.PG-TX.245": "The function pj1939_pdu2_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.21.PG-TX.010": "The platform  shall  reject calls with a NULL pointer in any of\n                the following parameters pj1939f_error_flag,\n                pj1939f_transport_error, pj1939f_item_ptr,\n                pj1939f_field_start_pos, pj1939f_field_width\n                or pj1939f_field_packing by raising a recoverable error\n                PSY_PJ1939\/PJ1939_PG_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.21.PG-TX.011": "The platform  shall  reject calls with the message length parameter\n                pj1939f_message_len greater than 1785, by raising a recoverable\n                error PSY_PJ1939\/PJ1939_PG_TRANSMIT_INVALID_ARG.\n              Rationale: \n                This is the maximum size of messages specified by the J1939 standard. SAE J1939-21\n                (rev. 1998-07) Section 5.10.1. 1",
    "LLR.PLAT.J1939.21.PG-TX.012": "The platform  shall  clip the pj1939f_priority parameter to the\n                range 0 to 7.",
    "LLR.PLAT.J1939.21.PG-TX.013": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.21.PG-TX.014": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.21.PG-TX.015": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.21.PG-TX.016": "The platform shall provide a Simulink interface block named\n                pj1939_PgTransmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          Simulation value\n          of the outport error_flag.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      priorityInportInteger\n        \n          The priority of the\n          J1939 message to transmit.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when there an\n          a problem transmitting the message, set to zero otherwise.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      PDU datapageParamInteger\n        \n          The pdu datapage value\n          of the PGN of the J1939 message to transmit.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              PDU formatParamInteger\n        \n          The pdu format value\n          of the PGN of the J1939 message to transmit.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              PDU specificParamInteger\n        \n          The pdu specific value\n          of the PGN of the J1939 message to transmit. If the PDU format parameter\n          is less than 240, then this parameter is not available for editing and does\n          not form part of the PGN.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Message lengthParamInteger\n        \n          The length of the data bytes\n          in the message to transmit.\n          Maximum size is the smaller of maximum range or buffer size.\n        \n        \n          Range: [0, 1785]\n        \n      \n                Calibratable: no.\n              Field start positionsParamInteger\n        \n          A vector of bit\n          numbers indicating the start position of each field in the CAN message.\n        \n        \n            Field start positions correspond to the message data bytes as follows:\n          Data byteBit numberLSMS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LS1876543212161514131211109......17851427914278142771427614275142741427314272MSMS\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0LS\n            where byte 1 corresponds to the first received data byte in the\n            first CAN message for the J1939 message. This numbering scheme\n            matches the J1939 specification but differs from the existing CAN\n            blocks. Although this may cause some confusion when both blocks\n            are used in the same model, it will help reduce mistakes when\n            using the J1939 blockset with the J1939 specification of message\n            contents.\n          \n      \n                Calibratable: no.\n              Field widthsParamInteger\n        \n          A vector of bit lengths\n          indicating the number of bits allocated to each field.\n        \n        \n          Range: [1, 32] bits\n        \n        \n            A field which starts at bit 5 and has 10 bits of width is identified as\n            follows:\n          Data byteBit number18765----2--14131211109\n      \n                Calibratable: no.\n              Field packingParamInteger\n        \n          A vector of zero or one\n          values, corresponding to each field. Fields for which this is set 1 are transmitted\n          as MS packing, or LS packing otherwise.\n        \n        \n          Range: 0 or 1\n        \n        \n            J1939 message fields are generally packed LS byte first, so the field which starts at bit\n            5 and has 10 bits of width, would be interpreted as:\n          MSLSData byte 2Data byte 1------141312111098765ssssssxxxxxxxxxx\n            where 'x' is the corresponding bit taken from the J1939\n            message data bytes, and 's' is the sign extension of the\n            data. In this case, bit 14 may be considered the sign bit, if the data in the\n            J1939 message data is signed.\n          \n            However, if the J1939 message field was packed MS byte first, the bits would be\n            interpreted as:\n          MSLSData byte 1Data byte 2------651413121110987ssssssxxxxxxxxxx\n            where 'x' is the corresponding bit taken from the J1939\n            message data bytes, and 's' is the sign extension of the\n            data. In this case, bit 6 may be considered the sign bit, if the data in the\n            J1939 message data is signed.\n          \n      \n                Calibratable: no.\n              Field mnemonicsParamString\n        \n          A string containing a\n          comma-separated list of names with which to label the message field inports.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.21.PG-TX.116": "The block pj1939_PgTransmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.21.PG-TX.216": "The block pj1939_PgTransmit shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.21.PG-TX.017": "The block  shall  raise an error if this block is present in a model but a\n                pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.21.PG-TX.018": "If the parameter PDU datapage is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.019": "If the parameter PDU format is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.020": "The mask PDU specific is checked by the interface when\n                PDU format is greater or equal to 240, if it is\n                out of range, the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.021": "If another pj1939_PgTransmit block with same PDUs exists in the model, then the block  shall  raise an error",
    "LLR.PLAT.J1939.21.PG-TX.022": "If the parameter Message Length is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.043": "If the parameter Message Length is not within the\n                Size of J1939 message buffers\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.023": "If the following mask arrays are not all the same length then the block  shall  raise an error:\n                Field start positions,\n                  Field widths,\n                  Field packing,\n                  Field mnemonics,",
    "LLR.PLAT.J1939.21.PG-TX.024": "The elements in the following arrays are checked to see that they are all\n                integers by the interface, if they are not then the block  shall  raise an error:\n                Field start positions,\n                  Field widths,\n                  Field packing,",
    "LLR.PLAT.J1939.21.PG-TX.025": "If the Field start positions parameter does not lie within\n                the message, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.026": "The block  shall  raise an error if any fields overlap.",
    "LLR.PLAT.J1939.21.PG-TX.027": "The block  shall  raise an error if any of used bits overflow the message bit length.",
    "LLR.PLAT.J1939.21.PG-TX.028": "If any of the elements in the Field widths array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.030": "If any of the elements in the Field packing array\n                are out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.21.PG-TX.032": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.J1939.21.PG-TX.033": "The block  shall  write the value of the inport sim_error_flag\n                to the outport error_flag.",
    "LLR.PLAT.J1939.21.PG-TX.034": "The block  shall  write the value of the inport sim_transport_errors\n                to the outport transport_errors.",
    "LLR.PLAT.J1939.21.PG-TX.040": "The block  shall  pack the data present on the inports defined by\n                Field mnemonics prior to transmission.",
    "LLR.PLAT.J1939.21.PG-TX.041": "The block  shall  use the mask parameters\n                Field start positions,\n                Field widths,\n                Field packing and\n                Message length for the parameters specifying the\n                field start position, width, type and length for packing the data into a CAN message.",
    "LLR.PLAT.J1939.21.PG-TX.042": "The packed data should be transmitted on the J1939 bus according to the mask parameters\n                PDU datapage,\n                PDU format and\n                PDU specific.",
    "LLR.PLAT.J1939.21.PG-TX.036": "The block  shall  use the inport priority value to set the priority\n                bits in the message PGN.",
    "LLR.PLAT.J1939.21.PG-TX.037": "The block  shall  write the value of the error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.21.PG-TX.038": "The block  shall  write the transport error count to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.FUNC.006": "When the platform is initialised, the platform  shall  set the error\n              counts for all diagnostic messages to zero.",
    "LLR.PLAT.J1939.73.FUNC.001": "The following additional DMs to those specified elsewhere  shall  be supported by the platform:\n              DM3DM11DM29DM41 - DM52",
    "LLR.PLAT.J1939.73.FUNC.013": "The platform  shall  implement an algorithm to avoid a high message\n              rate if DTCs change state at a high frequency.",
    "LLR.PLAT.J1939.73.FUNC.004": "When the application requests that a message be transmitted, it\n               shall  be transmitted when possible.",
    "LLR.PLAT.J1939.73.FUNC.007": "When constructing diagnostic messages, the platform  shall  set the\n              message's P field from the priority passed by the application.",
    "LLR.PLAT.J1939.73.FUNC.008": "When constructing diagnostic messages, the platform  shall  set the\n              message's reserved field to zero.",
    "LLR.PLAT.J1939.73.FUNC.009": "When constructing diagnostic messages, the platform  shall  set the\n              message's DP, DF and PS fields as specified for that message in\n              J1939\/73 FEB2010.",
    "LLR.PLAT.J1939.73.FUNC.010": "When constructing diagnostic messages, the platform  shall  set the\n              message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.FUNC.011": "When constructing diagnostic messages related to DTCs, the platform\n               shall  construct the message from the list of DTCs in the table\n              specified by the application.",
    "LLR.PLAT.J1939.73.FUNC.012": "When constructing diagnostic messages related to Diagnostic Monitor\n              Entities (DMEs), the platform  shall  construct the message from the\n              data held within the ppr object.",
    "LLR.PLAT.J1939.73.DM1REC.045": "The platform  shall  provide DM1 receive error status information for\n              any error that propagates up to the message polling layer.",
    "LLR.PLAT.J1939.73.DM1REC.002": "The platform  shall  reset the received status of the DM1 message once it has\n              been processed.",
    "LLR.PLAT.J1939.73.DM1REC.025": "The platform  shall  provide the DM1 message received status information.",
    "LLR.PLAT.J1939.73.DM1REC.026": "The platform  shall  signal active diagnostics trouble codes.",
    "LLR.PLAT.J1939.73.DM1REC.027": "The platform  shall  obtain an occurrence count for each DM1 diagnostics trouble code\n              of interest.",
    "LLR.PLAT.J1939.73.DM1REC.031": "The platform  shall  provide the lamp malfunction status for the received\n              DM1 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM1REC.028": "The platform  shall  provide the lamp red status for the received\n              DM1 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM1REC.029": "The platform  shall  provide the lamp amber status for the received\n              DM1 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM1REC.030": "The platform  shall  provide the lamp protect status for the received\n              DM1 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM1REC.040": "If a DM1 message has never been received, the platform  shall  set the lamp malfunction, lamp red, lamp amber and\n              lamp protect status to LAMP OFF.",
    "LLR.PLAT.J1939.73.DM1REC.003": "The platform shall provide a C interface function named\n                pj1939_dm1_receive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_dm1_idx\n          in\n        U8\nIndex into pj1939_dm1_rx_buf, pj1939_dm1_rx_buf_data and pj1939_dm1_rx_counters, thus identifying the DM1 message to work with (i.e., a DM1 message from a specific address).\n Range: [0, pj1939_dm1_source_addr_num - 1]pj1939f_lamp_malfunction\n          out\n        U8 *\nPointer to location to write the 'lamp malfunction' status for the source transmitting DM1. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_red\n          out\n        U8 *\nPointer to location to write the 'lamp red' status for the source transmitting DM1. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_amber\n          out\n        U8 *\nPointer to location to write the 'lamp amber' status for the source transmitting DM1. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_protect\n          out\n        U8 *\nPointer to location to write the 'lamp protect' status for the source transmitting DM1. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_timestamp\n          out\n        U32 *\nA pointer to the location to write with the timestamp of the received message.\n Cannot be NULL.\n Range: [0, 4294967295] us\n                The function returns a value of type\n                U8\n                with a value of:\n              One or more flags may be set in the return value to indicate:whether a fresh message was received since the last poll (PJ1939_RX_DATA);whether more than one message was received since the last poll (PJ1939_RX_OVERRUN);whether a receive error occurred for this message (PJ1939_RX_ERROR).",
    "LLR.PLAT.J1939.73.DM1REC.103": "The function pj1939_dm1_receive() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM1REC.203": "The function pj1939_dm1_receive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM1REC.004": "The platform  shall  reject calls with a NULL value in\n                any of the pointer parameters by\n                raising a recoverable error PSY_PJ1939\/PJ1939_DM1_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM1REC.005": "The platform  shall  reject calls where the parameter pj1939f_dm1_idx\n                is too large an index, by raising a recoverable error\n                PSY_PJ1939\/PJ1939_DM1_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM1REC.006": "When a new DM1 is received, the platform  shall  set bit\n                PJ1939_RX_DATAin the return value and\n                to true  and\n                output the lamp information into variables pointed to by pj1939f_lamp_malfunction,\n                pj1939f_lamp_red, pj1939f_lamp_amber and\n                pj1939f_lamp_protect.",
    "LLR.PLAT.J1939.73.DM1REC.007": "If a new DM1 message has not been received since the last call of pj1939_dm1_receive,\n                the platform  shall  write the last received lamp parameters else LAMP OFF if\n                there are no last good values (never received or error).",
    "LLR.PLAT.J1939.73.DM1REC.044": "When a DM1 message is received, the platform  shall  set pj1939f_timestamp\n                to the time stamp of the received message.",
    "LLR.PLAT.J1939.73.DM1REC.047": "If an error occurs during DM1 message reception, the platform  shall  set\n                PJ1939_RX_ERROR in the return value\n                and write LAMP OFF through all of the lamp state pointers.",
    "LLR.PLAT.J1939.73.DM1DEC.046": "The platform shall provide a C interface function named\n                pj1939_dm1_decode_dtc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_dm1_idx\n          in\n        U8\nIndex into pj1939_dm1_rx_buf and pj1939_dm1_rx_buf_data, thus identifying the DM1 message to work with (i.e., a DM1 message from a specific address).\n Range: [0, pj1939_dm1_source_addr_num - 1]pj1939f_spn\n          in\n        U32\nThe 'suspect parameter number' value to search for.\n Range: [0, 524287]pj1939f_fmi\n          in\n        U8\nThe SPN 'failure mode indicator' value to search for.\n Range: [0, 31]pj1939f_cm\n          in\n        U8\nThe SPN 'conversion method' value to search for.\n Range: [0, 1]pj1939f_active\n          out\n        U8 *\nPointer to location to write the status of the SPN\/FMI\/CM diagnostic trouble code. Written TRUE if the diagnostic trouble code is reported in the message (i.e. Active, for DM1), or written FALSE otherwise.\n Cannot be NULL.pj1939f_oc\n          out\n        U8 *\nPointer to the location to write the occurrence count of the diagnostic trouble code.\n Cannot be NULL.\n Range: [0, 127]\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM1DEC.146": "The function pj1939_dm1_decode_dtc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM1DEC.246": "The function pj1939_dm1_decode_dtc() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM1DEC.047": "The platform  shall  reject calls with a NULL pointer in any of the\n                following parameters pj1939f_active or pj1939f_oc by\n                raising a recoverable error PSY_PJ1939\/PJ1939_DM1_DECODE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM1DEC.048": "The platform  shall  reject calls where the parameter pj1939f_dm1_idx\n                is too large an index, by raising a recoverable error\n                PSY_PJ1939\/PJ1939_DM1_DECODE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM1DEC.008": "If the last received DM1 message contained an active diagnostics trouble code, the\n                platform  shall  set pj1939f_active to true and output the\n                trouble code occurrence count into pj1939f_oc.",
    "LLR.PLAT.J1939.73.DM1DEC.009": "If the last received DM1 message did not contain an active diagnostics trouble code,\n                the platform  shall  set pj1939f_active to false and\n                pj1939f_oc to 0.",
    "LLR.PLAT.J1939.73.DM1REC.010": "The platform shall provide a Simulink interface block named\n                pj1939_Dm1Receive that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_rx_trig_flagInportBoolean\n        \n          The simulation\n          value for the outport rx_trig_flag.\n        \n      sim_error_flagInportBoolean\n        \n          The simulation\n          value for the outport error_flag.\n        \n      sim_overrun_flagInportBoolean\n        \n          The simulation\n          value for the outport overrun_flag.\n        \n      sim_lamp_malfunctionInportInteger\n        \n          The simulation\n          value for the outport lamp_malfunction.\n        \n      sim_lamp_redInportInteger\n        \n          The simulation\n          value for the outport lamp_red.\n        \n      sim_lamp_amberInportInteger\n        \n          The simulation\n          value for the outport lamp_amber.\n        \n      sim_lamp_protectInportInteger\n        \n          The simulation\n          value for the outport lamp_protect.\n        \n      sim_timestampInportInteger\n        \n          The simulation\n          value for the outport timestamp.\n          Available only if the mask parameter\n          Provide timestamp is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if an error in receive processing relevant to this\n          message has occurred.\n        \n      rx_trig_flagOutportBoolean\n        \n          Set to 1 if a DM1 message matching\n          the source address has been received since the last time the block was\n          evaluated, 0 otherwise.\n        \n      overrun_flagOutportBoolean\n        \n          Set to 1 if more than one DM1 messages matching\n          the source address have been received since the last time the block was\n          evaluated, 0 otherwise.\n        \n      lamp_malfunctionOutportInteger\n        \n          The state value of the malfunction lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_redOutportInteger\n        \n          The state value of the red lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_amberOutportInteger\n        \n          The state value of the amber lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_protectOutportInteger\n        \n          The state value of the protect lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      timestampOutportInteger\n        \n          The time when the last\n          valid message was received. Strictly this gives the time when the message\n          was assembled from the possibly multiple CAN packets, and has a resolution\n          of 50 ms. The timestamp is a free-running microsecond timer that wraps to\n          zero approximately every 70 minutes. Available only if the mask parameter\n          Provide timestamp is selected.\n        \n        \n          Range: [0, 4294967295] us\n        \n      Source addressParamInteger\n        \n          The source J1939 network address of the message to be received.\n        \n        \n          Range: 0 or 253\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide timestampParamBoolean\n        \n          If selected then inport sim_timestamp\n          and outport timestamp are made available.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM1REC.110": "The block pj1939_Dm1Receive shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM1REC.210": "The block pj1939_Dm1Receive shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM1REC.011": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1REC.012": "If the parameter Suspect parameter number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1REC.016": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1REC.017": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.DM1REC.051": "The value of the inport sim_error_flag\n                 shall  be written to the outport sim_error_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.018": "The value of the inport sim_rx_trig_flag\n                 shall  be written to the outport rx_trig_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.049": "The value of the inport sim_overrun_flag\n                 shall  be written to the outport overrun_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.021": "The value of the inport sim_lamp_malfunction\n                 shall  be written to the outport lamp_malfunction\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.022": "The value of the inport sim_lamp_red\n                 shall  be written to the outport lamp_red\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.023": "The value of the inport sim_lamp_amber\n                 shall  be written to the outport lamp_amber\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.024": "The value of the inport sim_lamp_protect\n                 shall  be written to the outport lamp_protect\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.042": "The value of the inport sim_timestamp\n                 shall  be written to the outport timestamp\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1REC.052": "The block  shall  write 1 to the\n                error_flag outport\n                if an error available at the message polling layer was confirmed or 0 otherwise.",
    "LLR.PLAT.J1939.73.DM1REC.032": "The block  shall  write the DM1 message received status to the outport\n                rx_trig_flag.",
    "LLR.PLAT.J1939.73.DM1REC.050": "If a DM1 message was received more than once since the last time the block was evaluated,\n                the block  shall  write a value of 1 to the outport\n                overrun_flag otherwise it  shall  write a\n                value of 0.",
    "LLR.PLAT.J1939.73.DM1REC.035": "The block  shall  write the 'lamp malfunction' status to the outport\n                lamp_malfunction.",
    "LLR.PLAT.J1939.73.DM1REC.036": "The block  shall  write the 'lamp red' status to the outport\n                lamp_red.",
    "LLR.PLAT.J1939.73.DM1REC.037": "The block  shall  write the 'lamp amber' status to the outport\n                lamp_amber.",
    "LLR.PLAT.J1939.73.DM1REC.038": "The block  shall  write the 'lamp protect' status to the outport\n                lamp_protect.",
    "LLR.PLAT.J1939.73.DM1REC.039": "The block  shall  process DM1 messages from the J1939 node defined by\n                Source address.",
    "LLR.PLAT.J1939.73.DM1REC.043": "The block  shall  write the time when the last valid message was received to the outport\n                timestamp.",
    "LLR.PLAT.J1939.73.DM1DEC.051": "The platform shall provide a Simulink interface block named\n                pj1939_Dm1DecodeDtc that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_activeInportBoolean\n        \n          The simulation\n          value for the outport active.\n        \n      sim_ocInportInteger\n        \n          The simulation\n          value for the outport oc.\n        \n      activeOutportBoolean\n        \n          Set to 1 if the DTC is active, 0 otherwise.\n        \n      ocOutportInteger\n        \n          The occurrence count of the DTC\n          (as specified by the parameters Suspect parameter number, Failure mode indicator\n          and Conversion method).\n        \n        \n          Range: [0, 127]\n        \n      Suspect parameter numberParamInteger\n        \n          The value\n          of the SPN for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              Failure mode indicatorParamInteger\n        \n          The value\n          of the FMI for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: no.\n              Conversion methodParamInteger\n        \n          The value\n          of the CM for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Source addressParamInteger\n        \n          The source J1939 network address of the message.\n        \n        \n          Range: 0 or 253\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The\n          periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM1DEC.151": "The block pj1939_Dm1DecodeDtc shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM1DEC.251": "The block pj1939_Dm1DecodeDtc shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM1DEC.052": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.053": "If the parameter Source address is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.054": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.012": "If the parameter Suspect parameter number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.013": "If the parameter Failure mode indicator is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.014": "If the parameter Conversion method is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1DEC.055": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.DM1DEC.019": "The value of the inport sim_active\n                 shall  be written to the outport active\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1DEC.020": "The value of the inport sim_oc\n                 shall  be written to the outport oc\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM1DEC.033": "The block  shall  write the result of the diagnostic trouble code status to the outport\n                active.",
    "LLR.PLAT.J1939.73.DM1DEC.034": "The block  shall  write the 'occurrence count' to the outport oc.",
    "LLR.PLAT.J1939.73.DM1DEC.056": "The block  shall  process DM1 messages from the J1939 node defined by\n                Source address.",
    "LLR.PLAT.J1939.73.DM1DEC.041": "The block  shall  decode DM1 messages for the unique DTC identified by the SPN\/FMI\/CN parameters,\n                Suspect parameter number\/\n                Failure mode indicator\/\n                Conversion method.",
    "LLR.PLAT.J1939.73.DM2REC.045": "The platform  shall  provide DM2 receive error status information for\n              any error that propagates up to the message polling layer.",
    "LLR.PLAT.J1939.73.DM2REC.002": "The platform  shall  reset the received status of the DM2 message once it has\n              been processed.",
    "LLR.PLAT.J1939.73.DM2REC.025": "The platform  shall  provide the DM2 message received status information.",
    "LLR.PLAT.J1939.73.DM2REC.026": "The platform  shall  signal previously active diagnostics trouble codes.",
    "LLR.PLAT.J1939.73.DM2REC.027": "The platform  shall  obtain an occurrence count for each DM2 diagnostics trouble code\n              of interest.",
    "LLR.PLAT.J1939.73.DM2REC.031": "The platform  shall  provide the lamp malfunction status for the received\n              DM2 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM2REC.028": "The platform  shall  provide the lamp red status for the received\n              DM2 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM2REC.029": "The platform  shall  provide the lamp amber status for the received\n              DM2 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM2REC.030": "The platform  shall  provide the lamp protect status for the received\n              DM2 message from a source address of interest.",
    "LLR.PLAT.J1939.73.DM2REC.040": "If a DM2 message has never been received, the platform  shall  set the lamp malfunction, lamp red, lamp amber and\n              lamp protect status to LAMP OFF.",
    "LLR.PLAT.J1939.73.DM2REC.003": "The platform shall provide a C interface function named\n                pj1939_dm2_receive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_dm2_idx\n          in\n        U8\nIndex into pj1939_dm2_rx_buf, pj1939_dm2_rx_buf_data and pj1939_dm2_rx_counters, thus identifying the DM2 message to work with (i.e., a DM2 message from a specific address).\n Range: [0, pj1939_dm2_source_addr_num - 1]pj1939f_lamp_malfunction\n          out\n        U8 *\nPointer to location to write the 'lamp malfunction' status for the source transmitting DM2. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_red\n          out\n        U8 *\nPointer to location to write the 'lamp red' status for the source transmitting DM2. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_amber\n          out\n        U8 *\nPointer to location to write the 'lamp amber' status for the source transmitting DM2. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_lamp_protect\n          out\n        U8 *\nPointer to location to write the 'lamp protect' status for the source transmitting DM2. Once a valid message has been received, only updated if a new message is received or an error occurs.\n Cannot be NULL.\n Range: [0, 3]\n One of PIO_DTC_LAMP_SLOW_FLASH, PIO_DTC_LAMP_FAST_FLASH, PIO_DTC_LAMP_ON or PIO_DTC_LAMP_OFF (default if no valid reception).pj1939f_timestamp\n          out\n        U32 *\nA pointer to the location to write with the timestamp of the received message.\n Cannot be NULL.\n Range: [0, 4294967295] us\n                The function returns a value of type\n                U8\n                with a value of:\n              One or more flags may be set in the return value to indicate:whether a fresh message was received since the last poll (PJ1939_RX_DATA);whether more than one message was received since the last poll (PJ1939_RX_OVERRUN);whether a receive error occurred for this message (PJ1939_RX_ERROR).",
    "LLR.PLAT.J1939.73.DM2REC.103": "The function pj1939_dm2_receive() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM2REC.203": "The function pj1939_dm2_receive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM2REC.004": "The platform  shall  reject calls with a NULL value in\n                any of the pointer parameters by\n                raising a recoverable error PSY_PJ1939\/PJ1939_DM2_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM2REC.005": "The platform  shall  reject calls where the parameter pj1939f_dm2_idx\n                is too large an index, by raising a recoverable error\n                PSY_PJ1939\/PJ1939_DM2_RECEIVE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM2REC.006": "When a new DM2 is received, the platform  shall  set bit\n                PJ1939_RX_DATAin the return value and\n                to true  and\n                output the lamp information into variables pointed to by pj1939f_lamp_malfunction,\n                pj1939f_lamp_red, pj1939f_lamp_amber and\n                pj1939f_lamp_protect.",
    "LLR.PLAT.J1939.73.DM2REC.007": "If a new DM2 message has not been received since the last call of pj1939_dm2_receive,\n                the platform  shall  write the last received lamp parameters else LAMP OFF if\n                there are no last good values (never received or error).",
    "LLR.PLAT.J1939.73.DM2REC.044": "When a DM2 message is received, the platform  shall  set pj1939f_timestamp\n                to the time stamp of the received message.",
    "LLR.PLAT.J1939.73.DM2REC.047": "If an error occurs during DM2 message reception, the platform  shall  set\n                PJ1939_RX_ERROR in the return value\n                and write LAMP OFF through all of the lamp state pointers.",
    "LLR.PLAT.J1939.73.DM2DEC.046": "The platform shall provide a C interface function named\n                pj1939_dm2_decode_dtc() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_dm2_idx\n          in\n        U8\nIndex into pj1939_dm2_rx_buf and pj1939_dm2_rx_buf_data, thus identifying the DM2 message to work with (i.e., a DM2 message from a specific address).\n Range: [0, pj1939_dm2_source_addr_num - 1]pj1939f_spn\n          in\n        U32\nThe 'suspect parameter number' value to search for.\n Range: [0, 524287]pj1939f_fmi\n          in\n        U8\nThe SPN 'failure mode indicator' value to search for.\n Range: [0, 31]pj1939f_cm\n          in\n        U8\nThe SPN 'conversion method' value to search for.\n Range: [0, 1]pj1939f_previously_active\n          out\n        U8 *\nPointer to location to write the status of the SPN\/FMI\/CM diagnostic trouble code. Written TRUE if the diagnostic trouble code is reported in the message (i.e. Previously Active, for DM2), or written FALSE otherwise.\n Cannot be NULL.pj1939f_oc\n          out\n        U8 *\nPointer to the location to write the occurrence count of the diagnostic trouble code.\n Cannot be NULL.\n Range: [0, 127]\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM2DEC.146": "The function pj1939_dm2_decode_dtc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM2DEC.246": "The function pj1939_dm2_decode_dtc() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM2DEC.047": "The platform  shall  reject calls with a NULL pointer in any of the\n                following parameters pj1939f_previously_active or pj1939f_oc by\n                raising a recoverable error PSY_PJ1939\/PJ1939_DM2_DECODE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM2DEC.048": "The platform  shall  reject calls where the parameter pj1939f_dm2_idx\n                is too large an index, by raising a recoverable error\n                PSY_PJ1939\/PJ1939_DM2_DECODE_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM2DEC.008": "If the last received DM2 message contained a previously active diagnostics\n                trouble code, the platform  shall  set pj1939f_previously_active to true\n                and output the trouble code occurrence count into pj1939f_oc.",
    "LLR.PLAT.J1939.73.DM2DEC.009": "If the last received DM2 message did not contain a previously active diagnostics\n                trouble code, the platform  shall  set pj1939f_previously_active to false and\n                pj1939f_oc to 0.",
    "LLR.PLAT.J1939.73.DM2REC.010": "The platform shall provide a Simulink interface block named\n                pj1939_Dm2Receive that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation\n          value for the outport error_flag.\n        \n      sim_rx_trig_flagInportBoolean\n        \n          The simulation\n          value for the outport rx_trig_flag.\n        \n      sim_overrun_flagInportBoolean\n        \n          The simulation\n          value for the outport overrun_flag.\n        \n      sim_lamp_malfunctionInportInteger\n        \n          The simulation\n          value for the outport lamp_malfunction.\n        \n      sim_lamp_redInportInteger\n        \n          The simulation\n          value for the outport lamp_red.\n        \n      sim_lamp_amberInportInteger\n        \n          The simulation\n          value for the outport lamp_amber.\n        \n      sim_lamp_protectInportInteger\n        \n          The simulation\n          value for the outport lamp_protect.\n        \n      sim_timestampInportInteger\n        \n          The simulation\n          value for the outport timestamp.\n          Available only if the mask parameter\n          Provide timestamp is selected.\n        \n      error_flagOutportBoolean\n        \n          Set to 1 if an error in receive processing relevant to this\n          message has occurred.\n        \n      rx_trig_flagOutportBoolean\n        \n          Set to 1 if a DM2 message matching\n          the source address has been received since the last time the block was\n          evaluated, 0 otherwise.\n        \n      overrun_flagOutportBoolean\n        \n          Set to 1 if more than one DM2 messages matching\n          the source address have been received since the last time the block was\n          evaluated, 0 otherwise.\n        \n      lamp_malfunctionOutportInteger\n        \n          The state value of the malfunction lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_redOutportInteger\n        \n          The state value of the red lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_amberOutportInteger\n        \n          The state value of the amber lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      lamp_protectOutportInteger\n        \n          The state value of the protect lamp.\n        \n        \n          Range: [0, 3] (0 is Slow Flash, 1 is Fast Flash, 2 is On, 3 is Off)\n        \n      timestampOutportInteger\n        \n          The time when the last\n          valid message was received. Strictly this gives the time when the message\n          was assembled from the possibly multiple CAN packets, and has a resolution\n          of 50 ms. The timestamp is a free-running microsecond timer that wraps to\n          zero approximately every 70 minutes. Available only if the mask parameter\n          Provide timestamp is selected.\n        \n        \n          Range: [0, 4294967295] us\n        \n      Source addressParamInteger\n        \n          The source J1939 network address of the message to be received.\n        \n        \n          Range: 0 or 253\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide timestampParamBoolean\n        \n          If selected then inport sim_timestamp\n          and outport timestamp are made available.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM2REC.110": "The block pj1939_Dm2Receive shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM2REC.210": "The block pj1939_Dm2Receive shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM2REC.011": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2REC.015": "If the parameter Suspect parameter number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2REC.016": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2REC.017": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.DM2REC.051": "The value of the inport sim_error_flag\n                 shall  be written to the outport sim_error_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.018": "The value of the inport sim_rx_trig_flag\n                 shall  be written to the outport rx_trig_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.049": "The value of the inport sim_overrun_flag\n                 shall  be written to the outport overrun_flag\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.021": "The value of the inport sim_lamp_malfunction\n                 shall  be written to the outport lamp_malfunction\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.022": "The value of the inport sim_lamp_red\n                 shall  be written to the outport lamp_red\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.023": "The value of the inport sim_lamp_amber\n                 shall  be written to the outport lamp_amber\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.024": "The value of the inport sim_lamp_protect\n                 shall  be written to the outport lamp_protect\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.042": "The value of the inport sim_timestamp\n                 shall  be written to the outport timestamp\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2REC.052": "The block  shall  write 1 to the\n                error_flag outport\n                if an error available at the message polling layer was confirmed or 0 otherwise.",
    "LLR.PLAT.J1939.73.DM2REC.032": "The block  shall  write the DM2 message received status to the outport\n                rx_trig_flag.",
    "LLR.PLAT.J1939.73.DM2REC.050": "If a DM2 message was received more than once since the last time the block was evaluated,\n                the block  shall  write a value of 1 to the outport\n                overrun_flag otherwise it  shall  write a\n                value of 0.",
    "LLR.PLAT.J1939.73.DM2REC.035": "The block  shall  write the 'lamp malfunction' status to the outport\n                lamp_malfunction.",
    "LLR.PLAT.J1939.73.DM2REC.036": "The block  shall  write the 'lamp red' status to the outport\n                lamp_red.",
    "LLR.PLAT.J1939.73.DM2REC.037": "The block  shall  write the 'lamp amber' status to the outport\n                lamp_amber.",
    "LLR.PLAT.J1939.73.DM2REC.038": "The block  shall  write the 'lamp protect' status to the outport\n                lamp_protect.",
    "LLR.PLAT.J1939.73.DM2REC.039": "The block  shall  process DM2 messages from the J1939 node defined by\n                Source address.",
    "LLR.PLAT.J1939.73.DM2REC.043": "The block  shall  write the time when the last valid message was received to the outport\n                timestamp.",
    "LLR.PLAT.J1939.73.DM2DEC.051": "The platform shall provide a Simulink interface block named\n                pj1939_Dm2DecodeDtc that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_activeInportBoolean\n        \n          The simulation\n          value for the outport previously_active.\n        \n      sim_ocInportInteger\n        \n          The simulation\n          value for the outport oc.\n        \n      previously_activeOutportBoolean\n        \n          Set to 1 if the DTC was\n          previously active, 0 otherwise.\n        \n      ocOutportInteger\n        \n          The occurrence count of the DTC\n          (as specified by the parameters Suspect parameter number, Failure mode indicator\n          and Conversion method).\n        \n        \n          Range: [0, 127]\n        \n      Suspect parameter numberParamInteger\n        \n          The value\n          of the SPN for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              Failure mode indicatorParamInteger\n        \n          The value\n          of the FMI for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: no.\n              Conversion methodParamInteger\n        \n          The value\n          of the CM for this DTC. The parameters Suspect parameter number,\n          Failure mode indicator and Conversion method uniquely identify the\n          DTC.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Source addressParamInteger\n        \n          The source J1939 network address of the message.\n        \n        \n          Range: 0 or 253\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The\n          periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM2DEC.151": "The block pj1939_Dm2DecodeDtc shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM2DEC.251": "The block pj1939_Dm2DecodeDtc shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM2DEC.052": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.053": "If the parameter Source address is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.054": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.012": "If the parameter Suspect parameter number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.013": "If the parameter Failure mode indicator is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.014": "If the parameter Conversion method is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2DEC.055": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.DM2DEC.019": "The value of the inport sim_previously_active\n                 shall  be written to the outport previously_active\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2DEC.020": "The value of the inport sim_oc\n                 shall  be written to the outport oc\n                when run in simulation.",
    "LLR.PLAT.J1939.73.DM2DEC.033": "The block  shall  write the result of the diagnostic trouble code status to the outport\n                previously_active.",
    "LLR.PLAT.J1939.73.DM2DEC.034": "The block  shall  write the 'occurrence count' to the outport oc.",
    "LLR.PLAT.J1939.73.DM2DEC.056": "The block  shall  process DM2 messages from the J1939 node defined by\n                Source address.",
    "LLR.PLAT.J1939.73.DM2DEC.041": "The block  shall  decode DM2 messages for the unique DTC identified by the SPN\/FMI\/CN parameters,\n                Suspect parameter number\/\n                Failure mode indicator\/\n                Conversion method.",
    "LLR.PLAT.J1939.73.DM1-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM1-TX.002": "DM1 messages  shall  be sent periodically at 1Hz (1 message per second), regardless of the presence or\n              absence of active DTCs.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1, Figure 5-1",
    "LLR.PLAT.J1939.73.DM1-TX.003": "For each DTC specified in the DTC table, the first state change since the previous DM1 transmission\n               shall  cause an immediate transmission of a DM1 message.  This shall be in addition to 1Hz transmission\n              of DM1 (see LLR.PLAT.J1939.73.DM1-TX.002) and shall not affect the time of the next 1Hz transmission of DM1.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1, Figure 5-1",
    "LLR.PLAT.J1939.73.DM1-TX.004": "For each DTC specified in the DTC table, any additional state change of the same DTC\n               shall  not trigger an immediate transmission of a DM1 message.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1, Figure 5-1",
    "LLR.PLAT.J1939.73.DM1-TX.005": "If requested by a suitable flag the platform  shall  force the DM1 message transmission.",
    "LLR.PLAT.J1939.73.DM1-TX.006": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM1 message for transmission.",
    "LLR.PLAT.J1939.73.DM1-TX.007": "If a request to transmit a DM1 message is made, then the platform  shall  construct a DM1 message and attempt to\n              buffer the DM1 message for transmission.",
    "LLR.PLAT.J1939.73.DM1-TX.008": "If the DM1 message cannot be buffered, or if the previously buffered DM1 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM1-TX.009": "The platform  shall  set the DM1 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM1-TX.010": "The platform  shall  set the DM1 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM1-TX.011": "The platform  shall  set the DM1 message's DP, PF, R\/EDP and PS\n              fields as appropriate for DM1's PGN.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1",
    "LLR.PLAT.J1939.73.DM1-TX.012": "The platform  shall  set the DM1 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM1-TX.013": "The platform  shall  construct the data portion of the DM1 message, from the list of active DTCs in the DTC table\n              as specified by J1939-73 section 5.7.1.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1",
    "LLR.PLAT.J1939.73.DM1-TX.014": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.1.12",
    "LLR.PLAT.J1939.73.DM1-TX.015": "The platform shall provide a C interface function named\n                pj1939_dm1_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM1 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_force_transmission\n          in\n        const U8\nSet true if the DM1 message should be transmitted regardless of DTC state changes, set false if the DM1 message should be transmitted according to the general guidelines laid out in SAE J1939-73.pj1939f_priority\n          in\n        const U8\nThe priority of the DM1 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM1 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM1-TX.115": "The function pj1939_dm1_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM1-TX.215": "The function pj1939_dm1_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM1-TX.016": "The platform  shall  reject calls with a NULL pointer in any of the parameters\n                pj1939f_table, pj1939f_error_flag or pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM1_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM1-TX.017": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM1 messages.",
    "LLR.PLAT.J1939.73.DM1-TX.018": "The value of pj1939f_force_transmission  shall  be used to determine\n                if a DM1 transmission should be forced.",
    "LLR.PLAT.J1939.73.DM1-TX.019": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false, otherwise it  shall  be set to true.",
    "LLR.PLAT.J1939.73.DM1-TX.020": "The platform  shall  report the number of transport protocol errors encountered\n                during this power cycle in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM1-TX.021": "The platform shall provide a Simulink interface block named\n                pj1939_Dm1Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      force_transmissionInportBoolean\n        \n          Set to 1 to\n          force the transmission of a DM1 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM1\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM1 message\n          could not be buffered for transmission, or if a previous request to send a DM1\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM1-TX.121": "The block pj1939_Dm1Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM1-TX.221": "The block pj1939_Dm1Transmit shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM1-TX.022": "The model  shall  be checked by the interface to see if it contains the block pj1939_Configuration.\n                If it does not then the block shall raise an error.",
    "LLR.PLAT.J1939.73.DM1-TX.023": "If the parameter DTC table identifier\n                is empty, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1-TX.024": "If the parameter DTC table identifier does not match\n                that defined in a pdtc_Table block, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM1-TX.025": "The mask parameter DTC table identifier  shall  be checked by the interface\n                to ensure that it is only referenced in one pj1939_dm1_transmit block.  If it is referenced in multiple\n                pj1939_dm1_transmit blocks, the block shall raise an error.",
    "LLR.PLAT.J1939.73.DM1-TX.033": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM1-TX.026": "The value of the inport sim_error_flag\n                 shall  be written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM1-TX.027": "The value of the inport sim_transport_errors\n                 shall  be written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM1-TX.028": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM1 table.",
    "LLR.PLAT.J1939.73.DM1-TX.029": "The block  shall  use the inport value force_transmission\n                to set the DM1 force transmission flag.",
    "LLR.PLAT.J1939.73.DM1-TX.030": "The block  shall  use the inport value priority\n                to set the DM1 message priority.",
    "LLR.PLAT.J1939.73.DM1-TX.031": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM1-TX.032": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM2-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM2-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM2 message for transmission.",
    "LLR.PLAT.J1939.73.DM2-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM2-TX.004": "If a request to transmit a DM2 message is made, then the platform  shall  construct a DM2 message and attempt to\n              buffer the DM2 message for transmission.",
    "LLR.PLAT.J1939.73.DM2-TX.005": "If the DM2 message cannot be buffered, or if the previously buffered DM2 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM2-TX.006": "The platform  shall  set the DM2 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM2-TX.007": "The platform  shall  set the DM2 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM2-TX.008": "The platform  shall  set the DM2 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.2.",
    "LLR.PLAT.J1939.73.DM2-TX.009": "The platform  shall  set the DM2 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM2-TX.010": "The platform  shall  construct the data portion of the DM2 message, from the list of previously active DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d as specified by J1939\/73 section 5.7.2.",
    "LLR.PLAT.J1939.73.DM2-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM2-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm2_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM2 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM2 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM2 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM2 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM2-TX.112": "The function pj1939_dm2_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM2-TX.212": "The function pj1939_dm2_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.73.DM2-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM2_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM2-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM2 messages.",
    "LLR.PLAT.J1939.73.DM2-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM2 transmission should be made.",
    "LLR.PLAT.J1939.73.DM2-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM2-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM2-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM2-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm2Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM2 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM2\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM2 message\n          could not be buffered for transmission, or if a previous request to send a DM2\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM2-TX.118": "The block pj1939_Dm2Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM2-TX.218": "The block pj1939_Dm2Transmit shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.73.DM2-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm2_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM2-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM2-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM2-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM2-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM2 table.",
    "LLR.PLAT.J1939.73.DM2-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM2 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM2-TX.027": "The block  shall  use the inport value priority\n                to set the DM2 message priority.",
    "LLR.PLAT.J1939.73.DM2-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM2-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM4-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM4-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off,\n              then the software  shall  set the error_flag state to true and not attempt to buffer a DM4\n              message for transmission.",
    "LLR.PLAT.J1939.73.DM4-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict),\n              then the ECU  shall  participate in all communications.",
    "LLR.PLAT.J1939.73.DM4-TX.004": "If a request to transmit a DM4 message is made, then the software  shall  construct a DM4\n              message and attempt to buffer the DM4 message for transmission.",
    "LLR.PLAT.J1939.73.DM4-TX.005": "If the DM4 message cannot be buffered, or if the previously buffered DM4 message has not\n              been completely transmitted, then the software  shall  discard the message and set the error\n              state to true, otherwise it shall set it to false.",
    "LLR.PLAT.J1939.73.DM4-TX.006": "The platform  shall  set the DM4 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM4-TX.007": "The platform  shall  set the DM4 message's R\/EDP field to zero.",
    "LLR.PLAT.J1939.73.DM4-TX.008": "The platform  shall  set the DM4 message's DP, PF and PS fields to be 0, 254 and 205\n              respectively.",
    "LLR.PLAT.J1939.73.DM4-TX.009": "The platform  shall  set the DM4 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM4-TX.010": "If no J1939 standard (DM4) freeze frames have been captured, then the platform  shall  send\n              8 bytes of data, of which the first 5 bytes shall be zero, and the last 3 bytes shall all\n              be 255.",
    "LLR.PLAT.J1939.73.DM4-TX.012": "Otherwise the platform  shall  send the following information for each J1939 standard (DM4)\n              freeze frame that has been captured:\n            a. freeze frame lengthb. required parametersc. manufacturer specific information\n              sequentially in the order a,b,c,a,b,c, etc., where freeze frame length means the number\n              of bytes in the required parameters and the manufacturer specific freeze frame data taken\n              together, and the required parameters are defined in J1939-73 FEB2010 Section 5.7.4.\n            Note\n                Further requirements relating to the required parameters and manufacturer specific\n                information can be found in the \"Freeze frame storage\" section.",
    "LLR.PLAT.J1939.73.DM4-TX.013": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM4-TX.014": "The platform shall provide a C interface function named\n                pj1939_dm4_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the DM4 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM4 message for transmission,written false otherwise.\n Cannot be NULL.\npj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM4-TX.114": "The function pj1939_dm4_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM4-TX.214": "The function pj1939_dm4_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM4-TX.015": "The platform  shall  reject calls with a NULL pointer in either of the\n                parameters pj1939f_error_flag and pj1939f_transport_error\n                by raising the recoverable error PJ1939_DM4_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM4-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority and set\n                pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM4-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM4-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm4Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM4 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM4 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM4 message could not be buffered for transmission,\n          or if a previous request to send a DM4 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM4-TX.118": "The block pj1939_Dm4Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM4-TX.218": "The block pj1939_Dm4Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM4-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM4-TX.020": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM4-TX.021": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM4-TX.022": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM4-TX.023": "If the inport transmit is set to 1 (TRUE)\n                then the block  shall  cause a DM4 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM4-TX.024": "The block  shall  use the inport value priority\n                to set the DM4 message priority.",
    "LLR.PLAT.J1939.73.DM4-TX.025": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM4-TX.026": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM5-TX.001": "When requested by the application, the platform  shall  construct the required\n            DM5 response and attempt to pass the message to the transport layer for transmission.",
    "LLR.PLAT.J1939.73.DM5-TX.002": "If the DM5 message cannot be transmitted (unlikely for 'short' messages\n            of 8 bytes or less) then the platform  shall  discard the message and set the\n            error state to true, in order to indicate to the application that\n            there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM5-TX.003": "Otherwise, the message was successfully processed by the transport layer,\n            and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM5-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm5_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM5 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_obd_compliance\n          in\n        U8\nThe OBD compliance to be reported in DM5 byte 3.\n Range: [0, 255]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM5-TX.104": "The function pj1939_dm5_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM5-TX.204": "The function pj1939_dm5_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM5-TX.005": "The platform  shall  reject calls with a NULL pointer in either of the following parameters, pj1939f_table\n              and pj1939f_error_flag, by raising a recoverable error PJ1939_DM5_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM5-TX.006": "The platform  shall  use the DTC table defined by pj1939f_table when\n              sending DM5 messages.",
    "LLR.PLAT.J1939.73.DM5-TX.007": "If a message has been successfully queued, the platform  shall  set\n              pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM5-TX.021": "The platform  shall  set the message priority to pj1939f_priority when the message has been successfully queued.",
    "LLR.PLAT.J1939.73.DM5-TX.008": "The platform  shall  report the number of transport protocol errors encountered\n              thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM5-TX.009": "The platform shall provide a Simulink interface block named\n                pj1939_Dm5Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM5 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM5 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      obd_complianceInportInteger\n        \n          The OBD compliance that this controller\/software combination meets (see J1939-73 section 5.7.5.3).\n        \n        \n          Range: [0, 255]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM5 message could not be buffered for transmission,\n          or if a previous request to send a DM5 message has not completed.\n        \n      DTC table identifierParamString\n        \n          The name of the DTC table to act on (there must be a corresponding\n          named table specified in a pdtc_Table\n          block in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM5-TX.109": "The block pj1939_Dm5Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM5-TX.209": "The block pj1939_Dm5Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM5-TX.010": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM5-TX.011": "The interface  shall  raise an error if the parameter DTC table identifier\n              does not contain at least one character.",
    "LLR.PLAT.J1939.73.DM5-TX.012": "The interface  shall  raise an error if the parameter DTC table identifier\n              does not have a corresponding pdtc_table block, in the model, with the same DTC table identifier.",
    "LLR.PLAT.J1939.73.DM5-TX.013": "The interface  shall  raise an error if another instance of the pj1939_dm5_transmit\n              block has an identical DTC table identifier parameter.",
    "LLR.PLAT.J1939.73.DM5-TX.014": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM5-TX.015": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n            Rationale: \n                  The Simulink simulation environment does not easily allow the construction of CAN\n                  messages, so a simulation of the outports allows the user to construct a test\n                  framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM5-TX.016": "The block  shall  use the mask value DTC table identifier\n              to set the relevant DM5 table.",
    "LLR.PLAT.J1939.73.DM5-TX.017": "If the inport transmit is set to 1 (TRUE) then the block  shall \n              cause a DM5 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM5-TX.018": "The block  shall  use the inport value priority\n              to set the DM5 message priority.",
    "LLR.PLAT.J1939.73.DM5-TX.019": "The block  shall  use the inport value obd_compliance\n              to set the DM5 message obd compliance status.",
    "LLR.PLAT.J1939.73.DM5-TX.020": "If an error occurred when attempting to transmit the DM5 message then the\n              outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM6-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM6-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM6 message for transmission.",
    "LLR.PLAT.J1939.73.DM6-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM6-TX.004": "If a request to transmit a DM6 message is made, then the platform  shall  construct a DM6 message and attempt to\n              buffer the DM6 message for transmission.",
    "LLR.PLAT.J1939.73.DM6-TX.005": "If the DM6 message cannot be buffered, or if the previously buffered DM6 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM6-TX.006": "The platform  shall  set the DM6 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM6-TX.007": "The platform  shall  set the DM6 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM6-TX.008": "The platform  shall  set the DM6 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.6.",
    "LLR.PLAT.J1939.73.DM6-TX.009": "The platform  shall  set the DM6 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM6-TX.010": "The platform  shall  construct the data portion of the DM6 message, from the list of pending DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d as specified by J1939\/73 section 5.7.6.",
    "LLR.PLAT.J1939.73.DM6-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM6-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm6_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM6 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM6 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM6 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM6 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM6-TX.112": "The function pj1939_dm6_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM6-TX.212": "The function pj1939_dm6_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM6-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM6_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM6-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM6 messages.",
    "LLR.PLAT.J1939.73.DM6-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM6 transmission should be made.",
    "LLR.PLAT.J1939.73.DM6-TX.016": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM6-TX.031": "The platform  shall  set the message priority to pj1939f_priority when the message has been successfully queued.",
    "LLR.PLAT.J1939.73.DM6-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM6-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm6Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM6 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM6\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM6 message\n          could not be buffered for transmission, or if a previous request to send a DM6\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM6-TX.118": "The block pj1939_Dm6Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM6-TX.218": "The block pj1939_Dm6Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM6-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM6-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM6-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM6-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm6_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM6-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM6-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM6-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM6-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM6 table.",
    "LLR.PLAT.J1939.73.DM6-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM6 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM6-TX.027": "The block  shall  use the inport value priority\n                to set the DM6 message priority.",
    "LLR.PLAT.J1939.73.DM6-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM6-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM7-RX.001": "On receipt of a DM7 message, the platform  shall  queue the requested\n              Test identifier (TID), Suspect paramater number (SPN) and Failure mode indication (FMI),\n              in accordance with requirements LLR.PLAT.J1939.73.DM7-RX.002, LLR.PLAT.J1939.73.DM7-RX.022 and LLR.PLAT.J1939.73.DM7-RX.003",
    "LLR.PLAT.J1939.73.DM7-RX.002": "If the received DM7 message contains a TID that is specified as Reserved for SAE Assignment, the platform  shall \n              discard the DM7 message and immediately send a NACK.",
    "LLR.PLAT.J1939.73.DM7-RX.022": "If the received DM7 message contains a TID value of either 246 or 247 and an FMI value that is not 31,\n              the platform  shall  discard the DM7 message and immediately send a NACK.",
    "LLR.PLAT.J1939.73.DM7-RX.024": "If the received DM7 message contains a TID value of 246 and a SPN value that is not 5846,\n              the platform  shall  discard the DM7 message and immediately send a NACK.",
    "LLR.PLAT.J1939.73.DM7-RX.023": "If the received DM7 message contains a TID value that is not supported,\n              the platform  shall  discard the DM7 message and immediately send a NACK.",
    "LLR.PLAT.J1939.73.DM7-RX.003": "If the buffer of received DM7 commanded tests is full (see requirement LLR.PLAT.J1939.CONFIG.032 for\n              the DM7 test request buffer size), the platform  shall  discard the DM7 message, flush the DM7 test request buffer\n              and immediately send a NACK.\n            Note: \n                If test requests are not being picked up by the application, there could be a problem\n                with the application.  The buffer will eventually fill up, should the test tool\n                repeatedly send test requests, so a NACK response is transmitted.",
    "LLR.PLAT.J1939.73.DM7-RX.004": "The platform shall provide a C interface function named\n                pj1939_check_dm7_commanded_test() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_tid\n          in\n        U8\nThe J1939 'test identifier' value to match.\n Range: [0, 255]pj1939f_spn\n          in\n        U32\nThe 'suspect parameter number' value to match (when a DM30 response is required).\n Range: [0, 524287]pj1939f_fmi\n          in\n        U8\nThe 'failure mode indicator' value to match (when a DM30 response is required).\n Range: [0, 31]pj1939f_source_addr\n          out\n        U8 *\nThe source address for the DM7 request message requesting this test. May be NULL.pj1939f_dest_addr\n          out\n        U8 *\nThe destination address for the DM7 request message requesting this test. May be NULL.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - if the requested test is to be run. FALSE - if no request was received for the specified test.",
    "LLR.PLAT.J1939.73.DM7-RX.104": "The function pj1939_check_dm7_commanded_test() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM7-RX.204": "The function pj1939_check_dm7_commanded_test() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM7-RX.005": "If the pj1939f_tid parameter is in the range 246 to 250, the function  shall \n                search the DM7 test request buffer for an entry which matches the pj1939f_tid\n                 and pj1939f_spn\n                 and pj1939f_fmi parameters.\n                Otherwise, if the pj1939f_tid parameter is in the range 1 to 64,\n                the function  shall  search the DM7 test request buffer for an entry which matches the\n                pj1939f_tid parameter only .\n                Otherwise, no action.",
    "LLR.PLAT.J1939.73.DM7-RX.006": "If the function finds a matching entry in the DM7 test request buffer, in accordance with requirement\n                LLR.PLAT.J1939.73.DM7-RX.005, the function  shall  clear the entry in the DM7 test request buffer and\n                return TRUE.  Otherwise, the function shall return FALSE.",
    "LLR.PLAT.J1939.73.DM7-RX.019": "The platform  shall  reject calls with a NULL pointer in the parameter\n                pj1939f_test\n                by raising a recoverable error PJ1939_DM7_COMMANDED_TEST_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM7-RX.018": "The platform shall provide a C interface function named\n                pj1939_get_dm7_commanded_test() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_test\n          out\n        PJ1939_DM7_BUFFER_T *\nPointer to structure which will be populated with details of the test requested, if a DM7 request has been received.\n Must not be NULL.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - if a DM7 request has been received. FALSE - if no DM7 request requires processing.",
    "LLR.PLAT.J1939.73.DM7-RX.118": "The function pj1939_get_dm7_commanded_test() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM7-RX.218": "The function pj1939_get_dm7_commanded_test() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM7-RX.020": "If one or more requests exists in the DM7 request buffer, the platform  shall  set the contents of\n                pj1939f_test to the first test in the buffer, and  shall  return TRUE.\n              \n            \n              Note that if more DM7 requests are received than the application can clear in one task rate, and\n              further DM7 requests are then received, the first test in the buffer may no longer be the oldest\n              DM7 request in the buffer.  It does not seem likely that this would happen, since typically there\n              is only one diagnostic test tool connected to the module, and diagnostic test tools will usually\n              wait for a reply before sending another request.  Nor does it seem likely that even if the test\n              tool was to send multiple DM7 requests at once, the DM7 request buffer would be large enough that\n              the delay in processing requests could cause a timeout.",
    "LLR.PLAT.J1939.73.DM7-RX.021": "If no requests exists in the DM7 request buffer, the platform  shall  leave the contents of\n                pj1939f_test unchanged, and  shall  return FALSE.",
    "LLR.PLAT.J1939.73.DM7-RX.007": "The platform shall provide a Simulink interface block named\n                pj1939_Dm7Decode that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_test_commandedInportBoolean\n        \n          The simulation\n          value for the outport test_commanded.\n        \n      test_commandedOutportBoolean\n        \n          Set to 1 (true) if a DM7 message has been received containing a commanded test which matches the\n          Test identifier only \n          (when parameter Test identifier is in the range [1, 64])\n          or if a DM7 message has been received containing a commanded test which matches the Test identifier\n           and Suspect parameter number\n           and Failure mode indicator parameters\n          (when parameter Test identifier is in the range [247, 250]).\n          Note that this is a one-shot pulse which will remain high only until the next block iteration.\n        \n      source_addrOutportInteger\n        \n          The source address of the DM7 message received.\n        \n      dest_addrOutportInteger\n        \n          The destination address of the DM7 message received.\n        \n      Test identifierParamInteger\n        \n          The value\n          of the TID of the commanded test to match against.  In the case where a DM30 response is required,\n          the parameters Suspect parameter number,\n          Failure mode indicator and Test identifier uniquely identify the\n          commanded test.  If a DM8 response is required then only the Test identifier is needed.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Suspect parameter numberParamInteger\n        \n          The value\n          of the SPN of the commanded test to match against.  The parameters Suspect parameter number,\n          Failure mode indicator and Test identifier uniquely identify the\n          commanded test.  Only applicable if the Test identifier parameter is in the range [247, 250].\n          A DM30 response is required when the requested DM7 test consists of a valid SPN\/FMI\/TID combination.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              Failure mode indicatorParamInteger\n        \n          The value\n          of the FMI of the commanded test to match against.  The parameters Suspect parameter number,\n          Failure mode indicator and Test identifier uniquely identify the\n          commanded test.  Only applicable if the Test identifier parameter is in the range [247, 250].\n          A DM30 response is required when the requested DM7 test consists of a valid SPN\/FMI\/TID combination.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The\n          periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM7-RX.107": "The block pj1939_Dm7Decode shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM7-RX.207": "The block pj1939_Dm7Decode shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM7-RX.008": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-RX.009": "If the parameter Test identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-RX.010": "If the parameter Suspect parameter number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-RX.011": "If the parameter Failure mode indicator is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-RX.012": "If the parameter Sample time is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-TX.013": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM7-RX.014": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.DM7-RX.015": "The value of the inport sim_test_commanded\n                is written to the outport test_commanded.",
    "LLR.PLAT.J1939.73.DM7-RX.016": "If the Test identifier parameter is in the range 247 to 250,\n                the block  shall  search the DM7 test request buffer for an entry which matches the\n                Test identifier and \n                Suspect parameter number\n                 and Failure mode indicator parameters.\n                Otherwise, if the Test identifier parameter is in the range\n                1 to 64, the block  shall \n                search the DM7 test request buffer for an entry which matches the\n                Test identifier parameter only .\n                Otherwise, no action.",
    "LLR.PLAT.J1939.73.DM7-RX.017": "If the block finds a matching entry in the DM7 test request buffer, in accordance with requirement\n                LLR.PLAT.J1939.73.DM7-RX.016, the block  shall  clear the entry in the DM7 test request buffer and\n                set parameter test_commanded to TRUE (1).  Otherwise, the function  shall \n                set parameter test_commanded to FALSE (0).",
    "LLR.PLAT.J1939.73.DM8-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM8 response and attempt to pass the message to the transport layer for transmission.",
    "LLR.PLAT.J1939.73.DM8-TX.002": "If the DM8 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM8-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM8-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm8_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_tid\n          in\n        U8\nThe test identifier for which the results are to be transmitted.\npj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission or there is a problem in transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM8-TX.104": "The function pj1939_dm8_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM8-TX.204": "The function pj1939_dm8_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM8-TX.005": "The platform  shall  reject calls with a NULL pointer in either of the following parameters, pj1939f_error_flag\n              and pj1939f_transport_error, by raising a recoverable error PJ1939_DM8_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM8-TX.006": "The platform  shall  use the test identifier defined by pj1939f_tid when\n                sending DM8 messages.",
    "LLR.PLAT.J1939.73.DM8-TX.008": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM8-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM8-TX.009": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM8-TX.010": "The platform shall provide a Simulink interface block named\n                pj1939_Dm8Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM8 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM8 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      test_idInportInteger\n        \n          The J1939 test identifier to use for obtaining test results to be transmitted in the\n          DM8 message.\n        \n        \n          Range: [0, 255]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM8 message could not be buffered for transmission,\n          or if a previous request to send a DM8 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM8-TX.110": "The block pj1939_Dm8Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM8-TX.210": "The block pj1939_Dm8Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM8-TX.011": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM8-TX.012": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM8-TX.013": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM8-TX.014": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM8-TX.015": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM8 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM8-TX.016": "The block  shall  use the inport value priority\n                to set the DM8 message priority.",
    "LLR.PLAT.J1939.73.DM8-TX.017": "The block  shall  use the inport value test_id\n                to set the DM8 test id.",
    "LLR.PLAT.J1939.73.DM8-TX.018": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM8-TX.019": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM10-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM10 response and attempt to pass the message to the transport layer for transmission.",
    "LLR.PLAT.J1939.73.DM10-TX.002": "If the DM10 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM10-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM10-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm10_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there is a problem in transmission. Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM10-TX.104": "The function pj1939_dm10_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM10-TX.204": "The function pj1939_dm10_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM10-TX.005": "The platform  shall  reject calls with a NULL pointer in the parameters, pj1939f_error_flag\n              by raising a recoverable error PJ1939_DM10_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM10-TX.007": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM10-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM10-TX.009": "The platform shall provide a Simulink interface block named\n                pj1939_Dm10Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM10 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM10 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM10 message could not be buffered for transmission,\n          or if a previous request to send a DM10 message has not completed.",
    "LLR.PLAT.J1939.73.DM10-TX.109": "The block pj1939_Dm10Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM10-TX.209": "The block pj1939_Dm10Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM10-TX.010": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM10-TX.011": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM10-TX.012": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM10-TX.013": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM10 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM10-TX.014": "The block  shall  use the inport value priority\n                to set the DM10 message priority.",
    "LLR.PLAT.J1939.73.DM10-TX.015": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM12-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM12-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM12 message for transmission.",
    "LLR.PLAT.J1939.73.DM12-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM12-TX.004": "If a request to transmit a DM12 message is made, then the platform  shall  construct a DM12 message and attempt to\n              buffer the DM12 message for transmission.",
    "LLR.PLAT.J1939.73.DM12-TX.005": "If the DM12 message cannot be buffered, or if the previously buffered DM12 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM12-TX.006": "The platform  shall  set the DM12 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM12-TX.007": "The platform  shall  set the DM12 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM12-TX.008": "The platform  shall  set the DM12 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.12.",
    "LLR.PLAT.J1939.73.DM12-TX.009": "The platform  shall  set the DM12 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM12-TX.010": "The platform  shall  construct the data portion of the DM12 message, from the list of confirmed active DTCs\n              in the DTC table specified by parameter 'DTC Table Identifier' as specified by J1939\/73 section 5.7.12.",
    "LLR.PLAT.J1939.73.DM12-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM12-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm12_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM12 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM12 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM12 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM12 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM12-TX.112": "The function pj1939_dm12_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM12-TX.212": "The function pj1939_dm12_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM12-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM12_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM12-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM12 messages.",
    "LLR.PLAT.J1939.73.DM12-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM12 transmission should be made.",
    "LLR.PLAT.J1939.73.DM12-TX.031": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM12-TX.016": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM12-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM12-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm12Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM12 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM12\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM12 message\n          could not be buffered for transmission, or if a previous request to send a DM12\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM12-TX.118": "The block pj1939_Dm12Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM12-TX.218": "The block pj1939_Dm12Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM12-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM12-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM12-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM12-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm12_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM12-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM12-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM12-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM12-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM12 table.",
    "LLR.PLAT.J1939.73.DM12-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM12 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM12-TX.027": "The block  shall  use the inport value priority\n                to set the DM12 message priority.",
    "LLR.PLAT.J1939.73.DM12-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM12-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM16-TX.001": "The platform  shall  signal an error condition if the DM16 transmit interface is called\n                whilst the associated J1939 CAN bus is unavailable.",
    "LLR.PLAT.J1939.73.DM16-TX.002": "The platform  shall  signal an error condition if the DM16 transmit interface is\n                called when the node has been assigned the NULL address.",
    "LLR.PLAT.J1939.73.DM16-TX.003": "The platform  shall  signal an error condition if there is no available transmit\n                buffer for the DM16 message.",
    "LLR.PLAT.J1939.73.DM16-TX.004": "The platform  shall  accumulate the number of transmit errors encountered by the\n                transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM16-TX.005": "When constructing the DM16 message, the platform  shall  set the\n                message's P field to the priority passed by the application.\n              Rationale: \n                The P field of a J1939 message is the priority as defined in J1939\/21 DEC2010.",
    "LLR.PLAT.J1939.73.DM16-TX.024": "The platform  shall  clip the priority of the DM16 message to the range 0 to 7.",
    "LLR.PLAT.J1939.73.DM16-TX.006": "When constructing diagnostic messages, the platform  shall  set the\n                message's R\/EDP field to zero.\n              Rationale: \n                The EDP field of a J1939 message is the Extended Data Page as defined in J1939\/21 DEC2010.",
    "LLR.PLAT.J1939.73.DM16-TX.007": "When constructing the DM16 message, the platform  shall  set the\n                message's DP, and PF fields as specified for the DM16 message in\n                J1939\/73 FEB2010.\n              Rationale: \n                The DP, and PF fields of a J1939 message are the Data Page and PDU Format fields respectively\n                these combined form the PGN, as defined in J1939\/21 DEC2010.",
    "LLR.PLAT.J1939.73.DM16-TX.008": "When constructing the DM16 message, the platform  shall  set the\n                message's PS field to the destination address passed by the application.\n              Rationale: \n                The PS field of a J1939 message is the PDU Specific field or Destination Address, as defined in J1939\/21 DEC2010.",
    "LLR.PLAT.J1939.73.DM16-TX.009": "When constructing the DM16 message, the platform  shall  set the\n                message's SA field to the current claimed network address.\n              Rationale: \n                The SA field of a J1939 message is the Source Address of the sending node, as defined in J1939\/21 DEC2010.",
    "LLR.PLAT.J1939.73.DM16-TX.010": "When constructing the DM16 message, the platform  shall  set the actual data length of the DM16 message\n                to the data length passed by the application, incremented by one, to account for\n                the Number of Occurrences byte in the data of the message, as specified in J1939\/73 FEB2010,\n                and copy the data length number of bytes from the application supplied data buffer.\n              Rationale: \n                The first byte of a DM16 message must be the Number of Occurrences of raw data bytes sent when sending messages\n                less than or equal to 7 bytes, or 255 when sending messages greater than 7 bytes.  This is\n                because the DM16 message CAN frame DLC must be set to 8, even when the DM16 data length is less than 7.\n                For Transport protocol messages the size of the data can be extracted from the length of the\n                message sent, but for messages less than 8 bytes, the data size must be given.",
    "LLR.PLAT.J1939.73.DM16-TX.011": "When sending a DM16 message with a data length greater than 7 bytes,\n                the platform  shall  use the transport protocol, as specified in J1939\/21 DEC2010,\n                with the Number of Occurrences data byte (i.e. first data byte) set to 255, as specified in J1939\/73 FEB2010.",
    "LLR.PLAT.J1939.73.DM16-TX.012": "When sending a DM16 message with a data length less than or equal to 7 bytes,\n                the platform  shall  send the message using a single CAN frame as specified for\n                the DM16 message in J1939\/73 FEB2010, with the DLC of the CAN frame set to 8 bytes.\n              Rationale: \n                The J1939\/73 FEB2010 spec requires that the DM16 message CAN frame be sent with DLC of 8,\n                even when the DM16 data length is less than 7.",
    "LLR.PLAT.J1939.73.DM16-TX.025": "When sending a DM16 message using a single CAN frame, the platform  shall  set the Number of Occurrences data byte\n                (i.e. first data byte) to the data length of the message, as specified in J1939\/73 FEB2010.",
    "LLR.PLAT.J1939.73.DM16-TX.026": "When sending a DM16 message using a single CAN frame, the platform  shall  fill the remaining unused\n                data bytes in the CAN frame after the application supplied data with the value 0xFF.",
    "LLR.PLAT.J1939.73.DM16-TX.015": "The platform shall provide a C interface function named\n                pj1939_dm16_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        U8\nThe J1939 destination node address for the message. Range: [0, 253] or 255pj1939f_buf_len\n          in\n        U16\nThe length in bytes for the data buffer to send. \n Range: [1, 1785]pj1939f_buf\n          in\n        const U8 *\nPointer to array of bytes to be transmitted. \n Cannot be NULL.pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA saturated count of the transport transmit errors encountered while transmitting a J1939 message. The transport layer is only involved if the message must be broken into more than one CAN message (i.e., the data content of the message exceeds 8 data bytes). \n Cannot be NULL. \n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM16-TX.115": "The function pj1939_dm16_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM16-TX.215": "The function pj1939_dm16_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM16-TX.016": "If any of the input parameters are pointers to NULL then the\n                interface  shall  consider this an error and report this error using fault code\n                PJ1939_DM16_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM16-TX.017": "The platform  shall  use the following C interface parameters to set the corresponding DM16 message parameters as defined in\n                the following table:\n              C Interface parameterDirectionDM16 message parameterpj1939f_priorityinputprioritypj1939f_dest_addrinputdestination addresspj1939f_buf_leninputdata lengthpj1939f_bufinputdata bufferpj1939f_error_flagoutputerrorpj1939f_transport_erroroutputtransmit errors",
    "LLR.PLAT.J1939.73.DM16-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm16Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM16\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address of the DM16\n          message to be transmitted.\n        \n        \n          Range: [0, 253] or 255\n        \n      data_lenInportInteger\n        \n          Variable length number of bytes of data from the inport\n          data buffer to transmit in the\n          DM16 message.\n        \n        \n          Range: [0, 1785]\n        \n      dataInportArray\n        \n          The data buffer to transmit in the DM16 message.\n        \n        \n          Range: [0, 255]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM16 message\n          could not be buffered for transmission, or if a previous request to send a DM16\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM16-TX.118": "The block pj1939_Dm16Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM16-TX.218": "The block pj1939_Dm16Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM16-TX.019": "The block  shall  raise an error if the model does not contain the pj1939_Configuration block.",
    "LLR.PLAT.J1939.73.DM16-TX.020": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM16-TX.021": "The interface  shall  set the value of outport\n                error_flag,\n                to the value of inport\n                sim_error_flag.\n              Rationale: \n                The Simulink simulation environment does not easily allow the construction of CAN\n                messages, so a simulation of the outports allows the user to construct a test\n                framework for the application by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM16-TX.022": "The interface  shall  set the value of outport\n                transport_errors,\n                to the value of inport\n                sim_transport_errors.\n              Rationale: \n                The Simulink simulation environment does not easily allow the construction of CAN\n                messages, so a simulation of the outports allows the user to construct a test\n                framework for the application by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM16-TX.023": "The platform  shall  use the following Simulink block parameters to set the corresponding DM16 message parameters as defined in\n                the following table:\n              Simulink parameterDirectionDM16 message parameterpriorityinputprioritydest_addrinputdestination addressdata_leninputdata lengthdatainputdata buffererror_flagoutputerrortransport_errorsoutputtransmit errors",
    "LLR.PLAT.J1939.73.DM20-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM20 response and attempt to pass the message to the transport layer for transmission.\n            \n              The DM20 response is defined in J1939 Ref: 73, section 5.7.20",
    "LLR.PLAT.J1939.73.DM20-TX.017": "The platform  shall  set the DM20 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM20-TX.035": "The platform  shall  set the DM20 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM20-TX.018": "The platform  shall  set the DM20 message's DP, PF and R\/EDP fields\n              as specified by J1939\/73 FEB2010 section 5.7.20.",
    "LLR.PLAT.J1939.73.DM20-TX.019": "The platform  shall  set the DM20 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM20-TX.020": "The platform  shall  set the DM20 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM20-TX.002": "If the DM20 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM20-TX.003": "Otherwise, the message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM20-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm20_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM20-TX.104": "The function pj1939_dm20_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM20-TX.204": "The function pj1939_dm20_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM20-TX.005": "The platform  shall  reject calls with a NULL pointer in any of the following parameters pj1939f_error_flag\n                and pj1939f_transport_error by raising a recoverable error PJ1939_DM20_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM20-TX.008": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM20-TX.022": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM20-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM20-TX.009": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM20-TX.010": "The platform shall provide a Simulink interface block named\n                pj1939_Dm20Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM20 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM20 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM20 message could not be buffered for transmission,\n          or if a previous request to send a DM20 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM20-TX.110": "The block pj1939_Dm20Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM20-TX.210": "The block pj1939_Dm20Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM20-TX.011": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM20-TX.012": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM20-TX.013": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n            Rationale: \n              The Simulink simulation environment does not easily allow the construction of CAN\n              messages, so a simulation of the outports allows the user to construct a test\n              framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM20-TX.014": "If the inport transmit is set to 1 (TRUE) then the block  shall \n              cause a DM20 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM20-TX.015": "The block  shall  use the inport value priority\n              to set the DM20 message priority.",
    "LLR.PLAT.J1939.73.DM20-TX.021": "The block  shall  use the inport value dest_addr\n                to set the DM20 message destination address.",
    "LLR.PLAT.J1939.73.DM20-TX.016": "If an error occurred when attempting to transmit the DM20 message then the\n              outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM21-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM21 response and attempt to pass the message to the transport layer for transmission.\n            \n              The DM21 response is defined in J1939-73 FEB2010, section 5.7.21",
    "LLR.PLAT.J1939.73.DM21-TX.017": "The platform  shall  set the DM21 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM21-TX.018": "The platform  shall  set the DM21 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM21-TX.019": "The platform  shall  set the DM21 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.21.",
    "LLR.PLAT.J1939.73.DM21-TX.020": "The platform  shall  set the DM21 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM21-TX.021": "The platform  shall  set the DM21 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM21-TX.002": "If the DM21 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM21-TX.003": "Otherwise, the message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM21-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm21_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_time_while_mil_on\n          in\n        U16\nThe accumulated count (in minutes) run by the engine while the MIL is activated. Refer to J1939-73 Feb2010 section 5.7.21.3 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 64255] minutespj1939f_distance_while_mil_on\n          in\n        U16\nThe distance travelled (in kilometres) while the MIL is activated. Refer to J1939-73 Feb2010 section 5.7.21.1 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 64255] kilometrespj1939f_time_since_dtc_clear\n          in\n        U16\nThe engine running time (in minutes) accumulated since emission related DTCs were cleared. Refer to J1939-73 Feb2010 section 5.7.21.4 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 64255] minutespj1939f_distance_since_dtc_clear\n          in\n        U16\nThe distance accumulated (in kilometres) since emission related DTCs were cleared. Refer to J1939-73 Feb2010 section 5.7.21.2 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 64255] kilometrespj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM21-TX.104": "The function pj1939_dm21_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM21-TX.204": "The function pj1939_dm21_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM21-TX.005": "The platform  shall  reject calls with a NULL pointer\n                in the following parameter pj1939f_error_flag\n                by raising a recoverable error PJ1939_DM21_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM21-TX.006": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM21-TX.022": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM21-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM21-TX.009": "The platform shall provide a Simulink interface block named\n                pj1939_Dm21Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM21 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM21 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      mil_on_timeInportInteger\n        \n          The accumulated count (in minutes) run by the engine while the MIL is activated.\n          Refer to J1939-73 Feb2010 section 5.7.21.3 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 64255] minutes\n        \n      mil_on_distanceInportInteger\n        \n          The distance travelled (in kilometres) while the MIL is activated.\n          Refer to J1939-73 Feb2010 section 5.7.21.1 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 64255] kilometres\n        \n      time_since_dtc_clearInportInteger\n        \n          The engine running time (in minutes) accumulated since emission related DTCs were cleared.\n          Refer to J1939-73 Feb2010 section 5.7.21.4 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 64255] minutes\n        \n      dist_since_dtc_clearInportInteger\n        \n          The distance accumulated (in kilometres) since emission related DTCs were cleared.\n          Refer to J1939-73 Feb2010 section 5.7.21.2 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 64255] kilometres\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM21 message could not be buffered for transmission,\n          or if a previous request to send a DM21 message has not completed.",
    "LLR.PLAT.J1939.73.DM21-TX.109": "The block pj1939_Dm21Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM21-TX.209": "The block pj1939_Dm21Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM21-TX.010": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM21-TX.011": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM21-TX.012": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n            Rationale: \n                The Simulink simulation environment does not easily allow the construction of CAN\n                messages, so a simulation of the outports allows the user to construct a test\n                framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM21-TX.013": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM21 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM21-TX.014": "The block  shall  use the inport value priority\n                to set the DM21 message priority.",
    "LLR.PLAT.J1939.73.DM21-TX.023": "The block  shall  use the inport value dest_addr\n                to set the DM21 message destination address.",
    "LLR.PLAT.J1939.73.DM21-TX.015": "If an error occurred when attempting to transmit the DM21 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM23-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM23-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM23 message for transmission.",
    "LLR.PLAT.J1939.73.DM23-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM23-TX.004": "If a request to transmit a DM23 message is made, then the platform  shall  construct a DM23 message and attempt to\n              buffer the DM23 message for transmission.\n            \n              The DM23 response is defined in J1939 Ref: 73, section 5.7.23",
    "LLR.PLAT.J1939.73.DM23-TX.005": "If the DM23 message cannot be buffered, or if the previously buffered DM23 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM23-TX.006": "The platform  shall  set the DM23 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM23-TX.007": "The platform  shall  set the DM23 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM23-TX.008": "The platform  shall  set the DM23 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.23.",
    "LLR.PLAT.J1939.73.DM23-TX.009": "The platform  shall  set the DM23 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM23-TX.010": "The platform  shall  construct the data portion of the DM23 message, from the list of emission related, previously active DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d as specified by J1939\/73 section 5.7.23.",
    "LLR.PLAT.J1939.73.DM23-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM23-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm23_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM23 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM23 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM23 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM23 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM23-TX.112": "The function pj1939_dm23_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM23-TX.212": "The function pj1939_dm23_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM23-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM23_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM23-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM23 messages.",
    "LLR.PLAT.J1939.73.DM23-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM23 transmission should be made.",
    "LLR.PLAT.J1939.73.DM23-TX.016": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM23-TX.031": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM23-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM23-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm23Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM23 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM23\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM23 message\n          could not be buffered for transmission, or if a previous request to send a DM23\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM23-TX.118": "The block pj1939_Dm23Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM23-TX.218": "The block pj1939_Dm23Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM23-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM23-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM23-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM23-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm23_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM23-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM23-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM23-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM23-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM23 table.",
    "LLR.PLAT.J1939.73.DM23-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM23 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM23-TX.027": "The block  shall  use the inport value priority\n                to set the DM23 message priority.",
    "LLR.PLAT.J1939.73.DM23-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM23-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM24-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM24-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off,\n              then the software  shall  set the error_flag state to true and not attempt to buffer a DM24\n              message for transmission.",
    "LLR.PLAT.J1939.73.DM24-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict),\n              then the ECU  shall  participate in all communications.",
    "LLR.PLAT.J1939.73.DM24-TX.004": "If a request to transmit a DM24 message is made, then the software  shall  construct a DM24\n              message and attempt to buffer the DM24 message for transmission.",
    "LLR.PLAT.J1939.73.DM24-TX.005": "If the DM24 message cannot be buffered, or if the previously buffered DM24 message has not\n              been completely transmitted, then the software  shall  discard the message and set the error\n              state to true, otherwise it shall set it to false.",
    "LLR.PLAT.J1939.73.DM24-TX.006": "The platform  shall  set the DM24 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM24-TX.007": "The platform  shall  set the DM24 message's R\/EDP field to zero.",
    "LLR.PLAT.J1939.73.DM24-TX.008": "The platform  shall  set the DM24 message's DP, PF and PS fields to be 0, 253 and 182\n              respectively.",
    "LLR.PLAT.J1939.73.DM24-TX.009": "The platform  shall  set the DM24 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM24-TX.010": "The platform  shall  send the following information for each SPN defined in the ECU software\n              either as a parameter or as a diagnostic test entity (DTE):\n            a. Suspect Parameter Numberb. SPN support typec. SPN data length\n              sequentially in the order a,b,c,a,b,c, etc., in the format specified in J1939-73 FEB2010\n              Section 5.7.24.",
    "LLR.PLAT.J1939.73.DM24-TX.011": "The platform  shall  clear the \"Supported in Scaled Test Results\" bit if the SPN is that of\n              a DTE defined in the ECU software; otherwise it shall set the bit.",
    "LLR.PLAT.J1939.73.DM24-TX.012": "The platform  shall  clear the \"Supported in Data Stream\" bit if the SPN is defined as a parameter\n              within the ECU software; otherwise it shall set the bit.\n            Note: \n              Supported in data stream is interpreted to mean defined as a parameter and hence available\n              to PGN requests. For Sim-API, defined as a parameter means defined as an SPN via a ppid_Pid\n              block. For C-API, it means defined with a j1939-spn-id within a pid compound statement in the\n              capi file.",
    "LLR.PLAT.J1939.73.DM24-TX.013": "The platform  shall  clear the \"Supported in Expanded Freeze Frame\" bit if the SPN is\n              associated with the expanded freeze frame as defined in LLR.PLAT.PFF.STORE.015;\n              otherwise it shall set the bit.\n            Note: \n              Any SPNs in the calibratable list of SPNs that defines the expanded freeze frame that are\n              not themselves defined as parameters are ignored by the platform. Therefore the list of SPNs\n              supported in expanded freeze frame can only ever be a subset of those supported in data stream.\n              This is not the case for SPNs supported in scaled test results.",
    "LLR.PLAT.J1939.73.DM24-TX.014": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM24-TX.015": "The platform shall provide a C interface function named\n                pj1939_dm24_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the DM24 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM24 message for transmission,written false otherwise.\n Cannot be NULL.\npj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM24-TX.115": "The function pj1939_dm24_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM24-TX.215": "The function pj1939_dm24_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM24-TX.016": "The platform  shall  reject calls with a NULL pointer in either of the\n                parameters pj1939f_error_flag and pj1939f_transport_error\n                by raising the recoverable error PJ1939_DM24_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM24-TX.017": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority and set\n                pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM24-TX.018": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM24-TX.019": "The platform shall provide a Simulink interface block named\n                pj1939_Dm24Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM24 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM24 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM24 message could not be buffered for transmission,\n          or if a previous request to send a DM24 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM24-TX.119": "The block pj1939_Dm24Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM24-TX.219": "The block pj1939_Dm24Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM24-TX.020": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM24-TX.021": "The block  shall  schedule itself to run on target at the rate specified by the subsystem\n                that the block is within.",
    "LLR.PLAT.J1939.73.DM24-TX.022": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM24-TX.023": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM24-TX.024": "If the inport transmit is set to 1 (TRUE)\n                then the block  shall  cause a DM24 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM24-TX.025": "The block  shall  use the inport value priority\n                to set the DM24 message priority.",
    "LLR.PLAT.J1939.73.DM24-TX.026": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM24-TX.027": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM25-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM25-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off,\n              then the software  shall  set the error_flag state to true and not attempt to buffer a DM25\n              message for transmission.",
    "LLR.PLAT.J1939.73.DM25-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict),\n              then the ECU  shall  participate in all communications.",
    "LLR.PLAT.J1939.73.DM25-TX.004": "If a request to transmit a DM25 message is made, then the software  shall  construct a DM25\n              message and attempt to buffer the DM25 message for transmission.",
    "LLR.PLAT.J1939.73.DM25-TX.005": "If the DM25 message cannot be buffered, or if the previously buffered DM25 message has not\n              been completely transmitted, then the software  shall  discard the message and set the error\n              state to true, otherwise it shall set it to false.",
    "LLR.PLAT.J1939.73.DM25-TX.006": "The platform  shall  set the DM25 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM25-TX.007": "The platform  shall  set the DM25 message's R\/EDP field to zero.",
    "LLR.PLAT.J1939.73.DM25-TX.008": "The platform  shall  set the DM25 message's DP, PF and PS fields to be 0, 253 and 183\n              respectively.",
    "LLR.PLAT.J1939.73.DM25-TX.009": "The platform  shall  set the DM25 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM25-TX.010": "If no J1939 standard (DM25) freeze frames have been captured, then the platform  shall  send\n              8 bytes of data, of which the first 5 bytes shall be zero, and the last 3 bytes shall all\n              be 255.",
    "LLR.PLAT.J1939.73.DM25-TX.012": "Otherwise the platform  shall  send the following information for each J1939 expanded (DM25)\n              freeze frame that has been captured:\n            a. freeze frame lengthb. DTC that caused the freeze frame to be capturedc. freeze frame SPN data\n              sequentially in the order a,b,c,a,b,c, etc., where freeze frame length means the number\n              of bytes in the DTC information and the SPN freeze frame data combined, and the DTC information\n              is in the format specified in J1939-73 FEB2010 Section 5.7.25.",
    "LLR.PLAT.J1939.73.DM25-TX.013": "Within a given freeze frame instance, the platform  shall  list the SPN data in the order in which\n              those SPNs are listed in the DM24 response message.",
    "LLR.PLAT.J1939.73.DM25-TX.015": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM25-TX.016": "The platform shall provide a C interface function named\n                pj1939_dm25_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the DM25 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM25 message for transmission,written false otherwise.\n Cannot be NULL.\npj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM25-TX.116": "The function pj1939_dm25_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM25-TX.216": "The function pj1939_dm25_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM25-TX.017": "The platform  shall  reject calls with a NULL pointer in either of the\n                parameters pj1939f_error_flag and pj1939f_transport_error\n                by raising the recoverable error PJ1939_DM25_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM25-TX.018": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority and set\n                pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM25-TX.019": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM25-TX.020": "The platform shall provide a Simulink interface block named\n                pj1939_Dm25Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM25 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM25 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM25 message could not be buffered for transmission,\n          or if a previous request to send a DM25 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]",
    "LLR.PLAT.J1939.73.DM25-TX.120": "The block pj1939_Dm25Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM25-TX.220": "The block pj1939_Dm25Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM25-TX.021": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM25-TX.022": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM25-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM25-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM25-TX.025": "If the inport transmit is set to 1 (TRUE)\n                then the block  shall  cause a DM25 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM25-TX.026": "The block  shall  use the inport value priority\n                to set the DM25 message priority.",
    "LLR.PLAT.J1939.73.DM25-TX.027": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM25-TX.028": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM26-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM26 response and attempt to pass the message to the transport layer for transmission.",
    "LLR.PLAT.J1939.73.DM26-TX.002": "If the DM26 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM26-TX.003": "Otherwise, the message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM26-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm26_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939_eng_time_since_ign_start\n          in\n        U16\nThe time (in seconds), since key-on, that the engine has been running. Refer to J1939-73 Feb2010 section 5.7.26.1 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 64255] secondspj1939_warmup_count_since_dtc_clear\n          in\n        U8\nThe number of warm-up cycles since all DTCs were cleared. Refer to J1939-73 Feb2010 section 5.7.26.2 for details. The platform will limit the transmitted value to the range specified below.\n Range: [0, 250]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM26-TX.104": "The function pj1939_dm26_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM26-TX.204": "The function pj1939_dm26_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM26-TX.005": "The platform  shall  reject calls with a NULL pointer in the following parameter pj1939f_error_flag\n                by raising a recoverable error PJ1939_DM26_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM26-TX.007": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM26-TX.015": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM26-TX.008": "The platform shall provide a Simulink interface block named\n                pj1939_Dm26Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM26 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM26 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      engine_run_timeInportInteger\n        \n          The time (in seconds), since key-on, that the engine has been running.\n          Refer to J1939-73 Feb2010 section 5.7.26.1 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 64255] seconds\n        \n      warmup_count_since_clearInportInteger\n        \n          The number of warm-up cycles since all DTCs were cleared.\n          Refer to J1939-73 Feb2010 section 5.7.26.2 for details.  The platform will limit\n          the transmitted value to the range specified below.\n        \n        \n          Range: [0, 250]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM26 message could not be buffered for transmission,\n          or if a previous request to send a DM26 message has not completed.",
    "LLR.PLAT.J1939.73.DM26-TX.108": "The block pj1939_Dm26Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM26-TX.208": "The block pj1939_Dm26Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM26-TX.009": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM26-TX.010": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM26-TX.011": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n            Rationale: \n                  The Simulink simulation environment does not easily allow the construction of CAN\n                  messages, so a simulation of the outports allows the user to construct a test\n                  framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM26-TX.012": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM26 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM26-TX.013": "The block  shall  use the inport value priority\n                to set the DM26 message priority.",
    "LLR.PLAT.J1939.73.DM26-TX.014": "If an error occurred when attempting to transmit the DM26 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM27-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM27-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM27 message for transmission.",
    "LLR.PLAT.J1939.73.DM27-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM27-TX.004": "If a request to transmit a DM27 message is made, then the platform  shall  construct a DM27 message and attempt to\n              buffer the DM27 message for transmission.\n            \n              The DM27 response is defined in J1939 Ref: 73, section 5.7.27.",
    "LLR.PLAT.J1939.73.DM27-TX.005": "If the DM27 message cannot be buffered, or if the previously buffered DM27 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM27-TX.006": "The platform  shall  set the DM27 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM27-TX.007": "The platform  shall  set the DM27 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM27-TX.008": "The platform  shall  set the DM27 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.27.",
    "LLR.PLAT.J1939.73.DM27-TX.009": "The platform  shall  set the DM27 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM27-TX.010": "The platform  shall  construct the data portion of the DM27 message, from the list of all pending DTCs\n              in the DTC table specified by parameter 'DTC Table Identifier' as specified by J1939\/73 section 5.7.27.",
    "LLR.PLAT.J1939.73.DM27-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM27-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm27_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM27 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM27 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM27 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM27 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM27-TX.112": "The function pj1939_dm27_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM27-TX.212": "The function pj1939_dm27_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM27-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM27_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM27-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM27 messages.",
    "LLR.PLAT.J1939.73.DM27-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM27 transmission should be made.",
    "LLR.PLAT.J1939.73.DM27-TX.016": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM27-TX.031": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM27-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM27-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm27Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM27 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM27\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM27 message\n          could not be buffered for transmission, or if a previous request to send a DM27\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM27-TX.118": "The block pj1939_Dm27Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM27-TX.218": "The block pj1939_Dm27Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM27-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM27-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM27-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM27-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm27_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM27-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM27-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM27-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM27-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM27 table.",
    "LLR.PLAT.J1939.73.DM27-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM27 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM27-TX.027": "The block  shall  use the inport value priority\n                to set the DM27 message priority.",
    "LLR.PLAT.J1939.73.DM27-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM27-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM28-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM28-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM28 message for transmission.",
    "LLR.PLAT.J1939.73.DM28-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM28-TX.004": "If a request to transmit a DM28 message is made, then the platform  shall  construct a DM28 message and attempt to\n              buffer the DM28 message for transmission.\n            \n              The DM28 response is defined in J1939 Ref: 73, section 5.7.28.",
    "LLR.PLAT.J1939.73.DM28-TX.005": "If the DM28 message cannot be buffered, or if the previously buffered DM28 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM28-TX.006": "The platform  shall  set the DM28 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM28-TX.007": "The platform  shall  set the DM28 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM28-TX.008": "The platform  shall  set the DM28 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.28.",
    "LLR.PLAT.J1939.73.DM28-TX.009": "The platform  shall  set the DM28 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM28-TX.010": "The platform  shall  construct the data portion of the DM28 message, from the list of active DTCs that are permanent\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d as specified by J1939\/73 section 5.7.28.",
    "LLR.PLAT.J1939.73.DM28-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM28-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm28_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM28 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM28 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM28 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM28 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM28-TX.112": "The function pj1939_dm28_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM28-TX.212": "The function pj1939_dm28_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM28-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM28_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM28-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM28 messages.",
    "LLR.PLAT.J1939.73.DM28-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM28 transmission should be made.",
    "LLR.PLAT.J1939.73.DM28-TX.016": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM28-TX.031": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM28-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM28-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm28Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM28 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM28\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM28 message\n          could not be buffered for transmission, or if a previous request to send a DM28\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM28-TX.118": "The block pj1939_Dm28Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM28-TX.218": "The block pj1939_Dm28Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM28-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM28-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM28-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM28-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm28_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM28-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM28-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM28-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM28-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM28 table.",
    "LLR.PLAT.J1939.73.DM28-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM28 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM28-TX.027": "The block  shall  use the inport value priority\n                to set the DM28 message priority.",
    "LLR.PLAT.J1939.73.DM28-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM28-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM29-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM29-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM29 message for transmission.",
    "LLR.PLAT.J1939.73.DM29-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM29-TX.004": "If a request to transmit a DM29 message is made, then the platform  shall  construct a DM29 message and attempt to\n              buffer the DM29 message for transmission.\n            \n              The DM29 response is defined in J1939 Ref: 73, section 5.7.29.",
    "LLR.PLAT.J1939.73.DM29-TX.005": "If the DM29 message cannot be buffered, or if the previously buffered DM29 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM29-TX.006": "The platform  shall  set the DM29 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM29-TX.007": "The platform  shall  set the DM29 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM29-TX.008": "The platform  shall  set the DM29 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.29.",
    "LLR.PLAT.J1939.73.DM29-TX.009": "The platform  shall  set the DM29 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM29-TX.032": "The platform  shall  set the DM29 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM29-TX.010": "The platform  shall  construct the data portion of the DM29 message, from the DTC counts of emission related pending DTCs,\n              pending DTCs, active DTCs, previously active DTCs and permanent DTCs.",
    "LLR.PLAT.J1939.73.DM29-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM29-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm29_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM29 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM29 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM29 message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM29 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM29-TX.112": "The function pj1939_dm29_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM29-TX.212": "The function pj1939_dm29_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM29-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM29_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM29-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM29 messages.",
    "LLR.PLAT.J1939.73.DM29-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM29 transmission should be made.",
    "LLR.PLAT.J1939.73.DM29-TX.016": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM29-TX.033": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM29-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM29-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM29-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm29Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM29 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM29\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM29 message\n          could not be buffered for transmission, or if a previous request to send a DM29\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM29-TX.118": "The block pj1939_Dm29Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM29-TX.218": "The block pj1939_Dm29Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM29-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM29-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM29-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM29-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm29_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM29-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM29-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM29-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM29-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM29 table.",
    "LLR.PLAT.J1939.73.DM29-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM29 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM29-TX.027": "The block  shall  use the inport value priority\n                to set the DM29 message priority.",
    "LLR.PLAT.J1939.73.DM29-TX.034": "The block  shall  use the inport value dest_addr\n                to set the DM29 message destination address.",
    "LLR.PLAT.J1939.73.DM29-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM29-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM30-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM30 response and attempt to pass the message to the transport layer for transmission.\n            \n              The DM30 response is defined in J1939 Ref: 73, section 5.7.30.",
    "LLR.PLAT.J1939.73.DM30-TX.018": "The platform  shall  set the DM30 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM30-TX.019": "The platform  shall  set the DM30 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM30-TX.020": "The platform  shall  set the DM30 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.30.",
    "LLR.PLAT.J1939.73.DM30-TX.021": "The platform  shall  set the DM30 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM30-TX.022": "The platform  shall  set the DM30 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM30-TX.002": "If the DM30 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM30-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM30-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm30_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_req_test\n          in\n        const PJ1939_DM7_BUFFER_T *\nThe structure containing the details of the requested test.\n This may be obtained directly from pj1939_get_dm7_commanded_test. The response will be sent to the tool_addr unless the ecu_addr is 255 (i.e. the request was sent to the global address).pj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission or there is a problem in transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM30-TX.104": "The function pj1939_dm30_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM30-TX.204": "The function pj1939_dm30_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM30-TX.005": "The platform  shall  reject calls with a NULL pointer in any of the following parameters pj1939f_error_flag\n              and pj1939f_transport_error by raising a recoverable error PJ1939_DM30_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM30-TX.006": "The platform  shall  use the SPN defined by pj1939f_spn when\n                sending DM30 messages.",
    "LLR.PLAT.J1939.73.DM30-TX.007": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM30-TX.023": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM30-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM30-TX.008": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM30-TX.009": "The platform shall provide a Simulink interface block named\n                pj1939_Dm30Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM30 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM30 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      spnInportInteger\n        \n          The J1939 suspect parameter number to use for obtaining the test results to be transmitted in the\n          DM30 message.\n        \n        \n          Range: [0, 524287]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (should usually be the\n          source address of the corresponding request, but the global\n          address (255) if the request was sent to the global address).\n        \n        \n          Range: [0, 255]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM30 message could not be buffered for transmission,\n          or if a previous request to send a DM30 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      Test Identifier (TID)ParamInteger\n        \n          Together with the spn and\n          Failure Mode Indicator (FMI),\n           this identifies the specific test for which results are required, to match\n          the DTE values; or a special value of 246 (results for all tests)\n          or 247 (all results for specified SPN only).\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              Failure Mode Indicator (FMI)ParamInteger\n        \n          Together with the spn and\n          Test Identifier (TID),\n          this identifies the specific test for which results are required, to match\n          the DTE values; or a special value of 31 if a TID of 246 or 247\n          is requested.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: incorrectly specified in user guide XML.",
    "LLR.PLAT.J1939.73.DM30-TX.109": "The block pj1939_Dm30Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM30-TX.209": "The block pj1939_Dm30Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM30-TX.010": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM30-TX.011": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM30-TX.012": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM30-TX.013": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM30 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM30-TX.014": "The block  shall  use the inport value priority\n                to set the DM30 message priority.",
    "LLR.PLAT.J1939.73.DM30-TX.024": "The block  shall  use the inport value dest_addr\n                to set the DM30 message destination address.",
    "LLR.PLAT.J1939.73.DM30-TX.015": "The block  shall  use the inport value spn\n                when sending DM30 messages.",
    "LLR.PLAT.J1939.73.DM30-TX.016": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM30-TX.017": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM31-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM31-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM31 message for transmission.",
    "LLR.PLAT.J1939.73.DM31-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM31-TX.004": "If a request to transmit a DM31 message is made, then the platform  shall  construct a DM31 message and attempt to\n              buffer the DM31 message for transmission.\n            \n              The DM31 response is defined in J1939 Ref: 73, section 5.7.31.",
    "LLR.PLAT.J1939.73.DM31-TX.005": "If the DM31 message cannot be buffered, or if the previously buffered DM31 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM31-TX.006": "The platform  shall  set the DM31 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM31-TX.007": "The platform  shall  set the DM31 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM31-TX.008": "The platform  shall  set the DM31 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.31.",
    "LLR.PLAT.J1939.73.DM31-TX.009": "The platform  shall  set the DM31 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM31-TX.032": "The platform  shall  set the DM31 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM31-TX.010": "The platform  shall  construct the data portion of the DM31 message with lamp association and occurrence count of active DTCs.\n            Rationale: \n              The standard is rather vague about the state of DTC to consider, but the examples (including when there are no DTCs) and\n              references to DM1 and DM2 reporting composite status of the lamps and DM31 reporting lamp status specific to each DTC in the spec, do imply\n              that they are referring to separating what is causing lamps to be lit specifically. The platform software, switches on lamps *only*\n              when a DTC in Active state; hence only Active DTCs are considered in this message.",
    "LLR.PLAT.J1939.73.DM31-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM31-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm31_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM31 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM31 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM31 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM31 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM31-TX.112": "The function pj1939_dm31_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM31-TX.212": "The function pj1939_dm31_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM31-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM31_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM31-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM31 messages.",
    "LLR.PLAT.J1939.73.DM31-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM31 transmission should be made.",
    "LLR.PLAT.J1939.73.DM31-TX.016": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM31-TX.033": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM31-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM31-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM31-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm31Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM31 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM31\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM31 message\n          could not be buffered for transmission, or if a previous request to send a DM31\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM31-TX.118": "The block pj1939_Dm31Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM31-TX.218": "The block pj1939_Dm31Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM31-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM31-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM31-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM31-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm31_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM31-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM31-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM31-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM31-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM31 table.",
    "LLR.PLAT.J1939.73.DM31-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM31 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM31-TX.027": "The block  shall  use the inport value priority\n                to set the DM31 message priority.",
    "LLR.PLAT.J1939.73.DM31-TX.034": "The block  shall  use the inport value dest_addr\n                to set the DM31 message destination address.",
    "LLR.PLAT.J1939.73.DM31-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM31-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM32-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM32 response and attempt to pass the message to the transport layer for transmission.",
    "LLR.PLAT.J1939.73.DM32-TX.022": "The platform  shall  set the DM32 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM32-TX.023": "The platform  shall  set the DM32 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM32-TX.024": "The platform  shall  set the DM32 message's DP, PF and R\/EDP fields\n              as specified by J1939\/73 FEB2010 section 5.7.32.",
    "LLR.PLAT.J1939.73.DM32-TX.025": "The platform  shall  set the DM32 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM32-TX.026": "The platform  shall  set the DM32 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM32-TX.002": "If the DM32 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM32-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM32-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm32_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM32 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Only DTCs with emissions severities greater than the calibrated pdgc_emissions_report_min_sev are reported. See the documentation for the CAPI interface tool regarding the emissions-severity statement for more information.\n Cannot be NULL.pj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission or there is a problem in transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM32-TX.104": "The function pj1939_dm32_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM32-TX.204": "The function pj1939_dm32_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM32-TX.005": "The platform  shall  reject calls with a NULL pointer in any of the following parameters pj1939f_error_flag\n              and pj1939f_transport_error by raising a recoverable error PJ1939_DM32_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM32-TX.006": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM32 messages.",
    "LLR.PLAT.J1939.73.DM32-TX.007": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM32-TX.027": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM32-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM32-TX.008": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM32-TX.009": "The platform shall provide a Simulink interface block named\n                pj1939_Dm32Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM32 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM32 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM32 message could not be buffered for transmission,\n          or if a previous request to send a DM32 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM32-TX.109": "The block pj1939_Dm32Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM32-TX.209": "The block pj1939_Dm32Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM32-TX.010": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM32-TX.011": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM32-TX.012": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM32-TX.013": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_Dm32Transmit block.  If it doesn't, the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM32-TX.014": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM32-TX-TX.015": "The value of the inport sim_error_flag\n                 shall  be written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM32-TX.016": "The value of the inport sim_transport_errors\n                 shall  be written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM32-TX.017": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM32 table.",
    "LLR.PLAT.J1939.73.DM32-TX.018": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM32 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM32-TX.019": "The block  shall  use the inport value priority\n                to set the DM32 message priority.",
    "LLR.PLAT.J1939.73.DM32-TX.028": "The block  shall  use the inport value dest_addr\n                to set the DM32 message destination address.",
    "LLR.PLAT.J1939.73.DM32-TX.020": "If an error occurred when attempting to transmit the DM32 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM32-TX.021": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM33-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM33 response and attempt to pass the message to the transport layer for transmission.\n            \n              The DM33 response is defined in J1939 Ref: 73, section 5.7.33.",
    "LLR.PLAT.J1939.73.DM33-TX.009": "The platform  shall  set the DM33 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM33-TX.010": "The platform  shall  set the DM33 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM33-TX.011": "The platform  shall  set the DM33 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.33.",
    "LLR.PLAT.J1939.73.DM33-TX.012": "The platform  shall  set the DM33 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM33-TX.013": "The platform  shall  set the DM33 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM33-TX.002": "If the DM33 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM33-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM33-TX.004": "The platform  shall  transmit the data for a maximum of 198 EI-AECDs.\n            Rationale: \n                The J1939-73 FEB2010 standard states that this service can support up to\n                198 EI-AECDs due to TP data limits.",
    "LLR.PLAT.J1939.73.DM33-TX.005": "The platform shall provide a C interface function named\n                pj1939_dm33_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission or there is a problem in transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM33-TX.105": "The function pj1939_dm33_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM33-TX.205": "The function pj1939_dm33_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM33-TX.006": "The platform  shall  reject calls with a NULL pointer in any of the following parameters pj1939f_error_flag\n                and pj1939f_transport_error by raising a recoverable error PJ1939_DM33_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM33-TX.007": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM33-TX.014": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM33-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM33-TX.008": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM34-TX.001": "When requested by the application, the platform  shall  construct the required\n              DM34 response and attempt to pass the message to the transport layer for transmission.\n            \n              The DM34 response is defined in J1939 Ref: 73, section 5.7.34.",
    "LLR.PLAT.J1939.73.DM34-TX.032": "The platform  shall  set the DM34 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM34-TX.033": "The platform  shall  set the DM34 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM34-TX.034": "The platform  shall  set the DM34 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.34.",
    "LLR.PLAT.J1939.73.DM34-TX.035": "The platform  shall  set the DM34 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM34-TX.036": "The platform  shall  set the DM34 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM34-TX.002": "If the DM34 message cannot be transmitted then the platform  shall  discard the message\n              and set the error state to true, in order to indicate to the application that\n              there was a problem in dealing with the request.",
    "LLR.PLAT.J1939.73.DM34-TX.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM34-TX.004": "The platform shall provide a C interface function named\n                pj1939_dm34_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission or there is a problem in transmission. Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM34-TX.104": "The function pj1939_dm34_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM34-TX.204": "The function pj1939_dm34_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM34-TX.005": "If any of the input parameters are pointers to NULL then the\n                  interface  shall  consider this an error and report this error using fault code\n                  PJ1939_DM34_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM34-TX.006": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM34-TX.037": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM34-TX.011": "The platform shall provide a Simulink interface block named\n                pj1939_Dm34Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM34 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM34 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM34 message could not be buffered for transmission,\n          or if a previous request to send a DM34 message has not completed.",
    "LLR.PLAT.J1939.73.DM34-TX.111": "The block pj1939_Dm34Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM34-TX.211": "The block pj1939_Dm34Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM34-TX.012": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM34-TX.013": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM34-TX.014": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n                  Rationale: \n                      The Simulink simulation environment does not easily allow the construction of CAN\n                      messages, so a simulation of the outports allows the user to construct a test\n                      framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM34-TX.015": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM34 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM34-TX.016": "The block  shall  use the inport value priority\n                to set the DM34 message priority.",
    "LLR.PLAT.J1939.73.DM34-TX.038": "The block  shall  use the inport value dest_addr\n                to set the DM34 message destination address.",
    "LLR.PLAT.J1939.73.DM34-TX.017": "If an error occurred when attempting to transmit the DM34 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM35-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM35-TX.002": "For each DTC specified in the DTC table, if at least one change of transient fault status\n              has occurred since the previous DM35 transmission and the minimum inter-message interval\n              since the last transmission has elapsed, the DM35 message  shall  be transmitted.  Otherwise, no DM35 message shall be transmitted.\n            \n              The DM35 response is defined in J1939 Ref: 73, section 5.7.35.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.35\n              The platform's interpretation of J1939-73 is to monitor transient faults (or their disappearance)\n              during the 250ms minimum inter-message interval and if any change is detected, transmit the DM35 message\n              (containing the current state of transient faults) only when that interval has elapsed.",
    "LLR.PLAT.J1939.73.DM35-TX.003": "If requested, the software  shall  force the DM35 message transmission, regardless of any change in\n               DTC transient fault status and regardless of the time interval since the last DM35 transmission.",
    "LLR.PLAT.J1939.73.DM35-TX.029": "The platform  shall  set the DM35 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM35-TX.030": "The platform  shall  set the DM35 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM35-TX.031": "The platform  shall  set the DM35 message's DP, PF and R\/EDP\n              fields as specified by J1939\/73 FEB2010 section 5.7.35.",
    "LLR.PLAT.J1939.73.DM35-TX.032": "The platform  shall  set the DM35 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM35-TX.033": "The platform  shall  set the DM35 message's DA field to the destination address provided.",
    "LLR.PLAT.J1939.73.DM35-TX.004": "If the DM35 message cannot be buffered, or if the previously buffered DM35 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM35-TX.005": "The platform  shall  construct the data portion of the DM35 message, from the list of transient DTCs in the DTC table\n              as specified by J1939\/73 section 5.7.35.",
    "LLR.PLAT.J1939.73.DM35-TX.006": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM35-TX.007": "The platform shall provide a C interface function named\n                pj1939_dm35_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM35 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_force_transmission\n          in\n        const U8\nSet true if the DM35 message should be transmitted regardless of DTC transient fault changes.pj1939f_priority\n          in\n        const U8\nThe priority of the DM35 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM35 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM35-TX.107": "The function pj1939_dm35_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM35-TX.207": "The function pj1939_dm35_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM35-TX.008": "The platform  shall  reject calls with a NULL pointer in any of the following parameters:\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM35_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM35-TX.009": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM35 messages.",
    "LLR.PLAT.J1939.73.DM35-TX.010": "The value of pj1939f_force_transmission  shall  be used to force\n                transmission of a DM35 message, in accordance with requirement LLR.PLAT.J1939.73.DM35-TX.003.",
    "LLR.PLAT.J1939.73.DM35-TX.011": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM35-TX.034": "The platform  shall  set the destination address to pj1939f_dest_addr.",
    "LLR.PLAT.J1939.73.DM35-TX.012": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM35-TX.013": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM35-TX.014": "The platform shall provide a Simulink interface block named\n                pj1939_Dm35Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      start_transmissionInportBoolean\n        \n          Set to 1 to start the transmission of DM35 messages.  A rising edge on this inport\n          causes DM35 messages to be transmitted either until key-off or the stop_transmission\n          inport is set to 1.\n        \n        \n          Range: 0 or 1.\n        \n      force_transmissionInportBoolean\n        \n            Set to 1 to\n            force the transmission of a DM35 message, regardless of whether any DTC has a change\n            of transient fault status.\n        \n        \n          Range: 0 or 1.\n        \n      stop_transmissionInportBoolean\n        \n          Set to 1 to stop the transmission of DM35 messages.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM35 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      dest_addrInportInteger\n        \n          J1939 destination address for the response message (usually the\n          source address of the corresponding request).\n        \n        \n          Range: [0, 254]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM35 message\n          could not be buffered for transmission, or if a previous request to send a DM35\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM35-TX.114": "The block pj1939_Dm35Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM35-TX.214": "The block pj1939_Dm35Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM35-TX.015": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM35-TX.016": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM35-TX.017": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM35-TX.018": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_Dm35Transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM35-TX.019": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM35-TX.020": "The value of the inport sim_error_flag\n                 shall  be written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM35-TX.021": "The value of the inport sim_transport_errors\n                 shall  be written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM35-TX.022": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM35 table.",
    "LLR.PLAT.J1939.73.DM35-TX.023": "Upon detection of a rising edge on inport start_transmission,\n                the block  shall  commence transmission of DM35 messages, in accordance with requirement LLR.PLAT.J1939.73.DM35-TX.002,\n                until key-off or requested to stop transmission via inport stop_transmission.",
    "LLR.PLAT.J1939.73.DM35-TX.024": "If requirement LLR.PLAT.J1939.73.DM35-TX.023 has been satisfied, the block  shall  use the inport value\n                force_transmission\n                to force transmission of a DM35 message, in accordance with requirement LLR.PLAT.J1939.73.DM35-TX.003.",
    "LLR.PLAT.J1939.73.DM35-TX.025": "The block  shall  use the inport value stop_transmission,\n                to stop transmission of DM35 messages.",
    "LLR.PLAT.J1939.73.DM35-TX.026": "The block  shall  use the inport value priority\n                to set the DM35 message priority.",
    "LLR.PLAT.J1939.73.DM35-TX.035": "The block  shall  use the inport value dest_addr\n                to set the DM35 message destination address.",
    "LLR.PLAT.J1939.73.DM35-TX.027": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM35-TX.028": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM36-TX.001": "If a request to transmit a DM36 message is made, then the platform  shall \n              construct a DM36 message and attempt to buffer the DM36 message for transmission.",
    "LLR.PLAT.J1939.73.DM36-TX.002": "If the DM36 message cannot be transmitted (unlikely for short messages\n              of 8 bytes or less) then the platform  shall  discard the message and set the output\n              error flag to true.",
    "LLR.PLAT.J1939.73.DM36-TX.003": "Otherwise, the platform  shall  set the output error flag false.",
    "LLR.PLAT.J1939.73.DM36-TX.004": "The platform  shall  construct the data portion of the DM36 message\n              as specified by J1939\/73 section 5.7.36.",
    "LLR.PLAT.J1939.73.DM36-TX.005": "The platform  shall  limit the contents of the DM36 message to the data ranges specified\n              in J1939\/73 FEB2010 section 5.7.36",
    "LLR.PLAT.J1939.73.DM36-TX.006": "The platform shall provide a C interface function named\n                pj1939_dm36_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the DM36 message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_vnrw_component_count\n          in\n        U8\nThe sum of the system or component non-roadworthiness counts. Refer to J1939-73 Feb2010 section 5.7.36.1 for details. The platform will limit the value to the range specified below.\n Range: [0, 250]pj1939f_continuous_mil\n          in\n        U8\nA code indicating whether one or more systems or components requires that the MIL be steady (continuous) burning. Refer to J1939-73 Feb2010 section 5.7.36.2 for details. The platform will limit the value to the range specified below.\n Range: [0, 3]pj1939f_mil_display_strategy\n          in\n        U8\nA code indicating whether any system is configured to employ a discriminatory MIL display. Refer to J1939-73 Feb2010 section 5.7.36.3 for details. The platform will limit the value to the range specified below.\n Range: [0, 3]pj1939f_mil_activation_mode\n          in\n        U8\nA code indicating the most severe form of MIL display required by the failure status of any system or component. Refer to J1939-73 Feb2010 section 5.7.36.4 for details. The platform will limit the value to the range specified below.\n Range: [0, 15]pj1939f_incomplete_monitor_count\n          in\n        U16\nThe number of incomplete diagnostic monitors for a given sub-system or component. Refer to J1939-73 Feb2010 section 5.7.36.5 for details. The platform will limit the value to the range specified below.\n Range: [0, 64255]pj1939f_mil_accumulated_time\n          in\n        U16\nThe accumulated count, in minutes, that the MIL is activated for the current MIL activation. Refer to J1939-73 Feb2010 section 5.7.36.6 for details. The platform will limit the value to the range specified below. This range is chosen to match that of the accumulated time sent on DM21 message.\n Range: [0, 64255] minutespj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM36 message for transmission, Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM36-TX.106": "The function pj1939_dm36_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM36-TX.206": "The function pj1939_dm36_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM36-TX.007": "The platform  shall  reject calls with a NULL pointer in parameter\n                pj1939f_error_flag by raising a recoverable error\n                PJ1939_DM36_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM36-TX.008": "If a message has been successfully queued, the platform  shall  set\n              pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM36-TX.009": "The function  shall  set the Vehicle Non-Roadworthy Component Count to the value of input\n              parameter pj1939f_vnrw_component_count, in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.010": "The function  shall  set the Vehicle Continuous Malfunction Indicator to the value of input\n              parameter pj1939f_continuous_mil, in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.011": "The function  shall  set the Vehicle Malfunction Indicator Display Strategy to the value of input\n              parameter pj1939f_mil_display_strategy, in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.012": "The function  shall  set the Vehicle Malfunction Indicator Activation Mode to the value of input\n              parameter pj1939f_mil_activation_mode , in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.013": "The function  shall  set the Vehicle Incomplete Monitor Count to the value of input\n              parameter pj1939f_incomplete_monitor_count, in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.014": "The function  shall  set the Vehicle Current MI Accumulated Time to the value of input\n              parameter pj1939f_mil_accumulated_time, in accordance with requirements\n              LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.015": "The platform  shall  set the DM36 message's priority to the value defined in parameter\n              pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM36-TX.016": "If a message has been successfully queued, the platform  shall  set\n              pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM36-TX.017": "The platform shall provide a Simulink interface block named\n                pj1939_Dm36Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM36 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM36 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      vnrw_countInportInteger\n        \n          The sum of the system or component non-roadworthiness counts.\n          Refer to J1939-73 Feb2010 section 5.7.36.1 for details.\n        \n        \n          Range: [0, 250]\n        \n      continuous_milInportInteger\n        \n          A code indicating whether one or more systems or components requires that\n          the MIL be steady (continuous) burning.\n          Refer to J1939-73 Feb2010 section 5.7.36.2 for details.\n        \n        \n          Range: [0, 3]\n        \n      mil_strategyInportInteger\n        \n          A code indicating whether any system is configured to employ a discriminatory MIL display.\n          Refer to J1939-73 Feb2010 section 5.7.36.3 for details.\n        \n        \n          Range: [0, 3]\n        \n      mil_activation_modeInportInteger\n        \n          A code indicating the most severe form of MIL display required by the failure status of any system or component.\n          Refer to J1939-73 Feb2010 section 5.7.36.4 for details.\n        \n        \n          Range: [0, 15]\n        \n      incomplete_monitorsInportInteger\n        \n          The number of incomplete diagnostic monitors for a given sub-system or component.\n          Refer to J1939-73 Feb2010 section 5.7.36.5 for details. The platform will\n          limit the value to the range specified below.\n        \n        \n          Range: [0, 64255]\n        \n      mil_accumulated_timeInportInteger\n        \n          The accumulated count, in minutes, that the MIL is activated for the current MIL activation.\n          Refer to J1939-73 Feb2010 section 5.7.36.6 for details. The platform will\n          limit the value to the range specified below. This range is chosen to match that of\n          the accumulated time sent on DM21 message.\n        \n        \n          Range: [0, 64255] minutes\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM36 message could not be buffered for transmission,\n          or if a previous request to send a DM36 message has not completed.",
    "LLR.PLAT.J1939.73.DM36-TX.117": "The block pj1939_Dm36Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM36-TX.217": "The block pj1939_Dm36Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM36-TX.018": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not (see (todo: ref. to LLR)).",
    "LLR.PLAT.J1939.73.DM36-TX.019": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM36-TX.020": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n                  Rationale: \n                      The Simulink simulation environment does not easily allow the construction of CAN\n                      messages, so a simulation of the outports allows the user to construct a test\n                      framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM36-TX.021": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM36 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM36-TX.022": "The block  shall  use the inport value priority\n                to set the DM36 message priority.",
    "LLR.PLAT.J1939.73.DM36-TX.023": "The block  shall  use the inport value vnrw_count\n                to set the DM36 Vehicle Non-Roadworthy Component Count, in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.024": "The block  shall  use the inport value continuous_mil\n                to set the DM36 Vehicle Continuous Malfunction Indicator, in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.025": "The block  shall  use the inport value mil_strategy\n                to set the DM36 Vehicle Malfunction Indicator Display Strategy, in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.026": "The block  shall  use the inport value mil_activation_mode\n                to set the DM36 Vehicle Malfunction Indicator Activation Mode, in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.027": "The block  shall  use the inport value incomplete_monitors\n                to set the DM36 Vehicle Incomplete Monitor Count, , in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.028": "The block  shall  use the inport value mil_accumulated_time\n                to set the DM36 Current MI Accumulated Time, in accordance with requirements\n                LLR.PLAT.J1939.73.DM36-TX.004 and LLR.PLAT.J1939.73.DM36-TX.005",
    "LLR.PLAT.J1939.73.DM36-TX.029": "If an error occurred when attempting to transmit the DM36 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM37-TX.001": "In the absence of other considerations detailed in the requirements below,\n              DM37 messages  shall  be sent periodically at 0.1Hz (1 message every 10 seconds).\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.37",
    "LLR.PLAT.J1939.73.DM37-TX.002": "If the input data has changed at least once since the previous DM37 transmission and\n              the 1 second minimum inter-message interval since the last transmission has elapsed, the DM37 message  shall  be transmitted and\n              the 0.1Hz periodic message transmission (as defined in requirement LLR.PLAT.J1939.73.DM37-TX.001) re-started at this point.\n            Note: \n              Source: J1939-73 revised Feb 2010, section 5.7.37\n              The platform's interpretation of J1939-73 is to monitor the input data\n              during the 1s minimum inter-message interval and if any change is detected, transmit the DM37 message\n              (containing the current input data) only when that interval has elapsed.  Any change of input data during\n              the 0.1Hz periodic interval will cause the heartbeat to restart i.e. no periodic message will be sent until\n              a further 10 seconds has elapsed since the 'immediate' message had been sent.",
    "LLR.PLAT.J1939.73.DM37-TX.003": "If requested, the software  shall  force the DM37 message transmission, regardless of any change in\n               input data and regardless of the time interval since the last DM37 transmission.",
    "LLR.PLAT.J1939.73.DM37-TX.004": "If the DM37 message cannot be transmitted (unlikely for short messages\n              of 8 bytes or less) then the platform  shall  discard the message and set the output\n              error flag to true.",
    "LLR.PLAT.J1939.73.DM37-TX.005": "Otherwise, the platform  shall  set the output error flag false.",
    "LLR.PLAT.J1939.73.DM37-TX.006": "The platform  shall  construct the data portion of the DM37 message\n              as specified by J1939\/73 section 5.7.37.",
    "LLR.PLAT.J1939.73.DM37-TX.007": "The platform  shall  limit the contents of the DM37 message to the data ranges specified\n              in J1939\/73 FEB2010 section 5.7.37",
    "LLR.PLAT.J1939.73.DM37-TX.008": "The platform shall provide a C interface function named\n                pj1939_dm37_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_force_transmission\n          in\n        const BOOL\nSet to TRUE if the DM37 message should be transmitted in addition to the periodic transmission and regardless of any change in input data. Refer to J1939-73 Feb2010 section 5.7.37 for details of transmission rates.pj1939f_priority\n          in\n        const U8\nThe priority of the DM37 message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_snrw_component_count\n          in\n        U8\nThe number of components that the system has determined to be non-roadworthy. Refer to J1939-73 Feb2010 section 5.7.37.1 for details. The platform will limit the value to the range specified below.\n Range: [0, 250]pj1939f_continuous_mil\n          in\n        U8\nA code indicating whether the system requires that the MIL be steady (continuous) burning. Refer to J1939-73 Feb2010 section 5.7.37.2 for details. The platform will limit the value to the range specified below.\n Range: [0, 3]pj1939f_mil_display_strategy\n          in\n        U8\nA code indicating whether the system is configured to employ a discriminatory MIL display. Refer to J1939-73 Feb2010 section 5.7.37.3 for details. The platform will limit the value to the range specified below.\n Range: [0, 3]pj1939f_mil_activation_mode\n          in\n        U8\nA code indicating the most severe form of MIL display required by the failure status the system or component. Refer to J1939-73 Feb2010 section 5.7.37.4 for details. The platform will limit the value to the range specified below.\n Range: [0, 15]pj1939f_incomplete_monitor_count\n          in\n        U16\nThe number of incomplete diagnostic monitors for a given sub-system or component. Refer to J1939-73 Feb2010 section 5.7.37.5 for details. The platform will limit the value to the range specified below. This range is chosen to match that of the 'Vehicle Incomplete Monitor Count' sent on DM36 message.\n Range: [0, 64255]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM37 message for transmission, Written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM37-TX.108": "The function pj1939_dm37_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM37-TX.208": "The function pj1939_dm37_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM37-TX.009": "The platform  shall  reject calls with a NULL pointer in parameter\n                pj1939f_error_flag by raising a recoverable error\n                PJ1939_DM37_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM37-TX.010": "The platform  shall  set the DM37 message's priority to the value defined in parameter\n              pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM37-TX.011": "The value of pj1939f_force_transmission  shall  be used to force\n              transmission of a DM37 message, in accordance with requirement LLR.PLAT.J1939.73.DM37-TX.003",
    "LLR.PLAT.J1939.73.DM37-TX.012": "If a message has been successfully queued, the platform  shall  set\n              pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM37-TX.013": "The function  shall  set the System Non-Roadworthy Component Count to the value of input\n              parameter pj1939f_snrw_component_count, in accordance with requirements\n              LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.014": "The function  shall  set the System Continuous Malfunction Indicator to the value of input\n              parameter pj1939f_continuous_mil, in accordance with requirements\n              LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.015": "The function  shall  set the System Malfunction Indicator Display Strategy to the value of input\n              parameter pj1939f_mil_display_strategy, in accordance with requirements\n              LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.016": "The function  shall  set the System Malfunction Indicator Activation Mode to the value of input\n              parameter pj1939f_mil_activation_mode, in accordance with requirements\n              LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.017": "The function  shall  set the System Incomplete Monitor Count to the value of input\n              parameter pj1939f_incomplete_monitor_count, in accordance with requirements\n              LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm37Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      force_transmissionInportBoolean\n        \n           Set to 1 if the DM37 message should be transmitted in addition to the\n           periodic transmission and regardless of any change in input data.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM37 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      snrw_countInportInteger\n        \n            The number of components that the system has determined to be non-roadworthy.\n            Refer to J1939-73 Feb2010 section 5.7.37.1 for details.  A change of data on this\n            inport causes transmission of a DM37 message.  The transmission is delayed, if necessary,\n            until the minimum inter-message interval has elapsed.  Refer\n            to J1939-73 Feb2010 section 5.7.37 for details of permitted transmission rates.\n        \n        \n          Range: [0, 250]\n        \n      continuous_milInportInteger\n        \n            A code indicating whether the system requires that the MIL be steady (continuous) burning.\n            Refer to J1939-73 Feb2010 section 5.7.37.2 for details.  A change of data on this\n            inport causes transmission of a DM37 message.  The transmission is delayed, if necessary,\n            until the minimum inter-message interval has elapsed.  Refer\n            to J1939-73 Feb2010 section 5.7.37 for details of permitted transmission rates.\n        \n        \n          Range: [0, 3]\n        \n      mil_strategyInportInteger\n        \n            A code indicating whether the system is configured to employ a discriminatory MIL display.\n            Refer to J1939-73 Feb2010 section 5.7.37.3 for details.  A change of data on this\n            inport causes transmission of a DM37 message.  The transmission is delayed, if necessary,\n            until the minimum inter-message interval has elapsed.  Refer\n            to J1939-73 Feb2010 section 5.7.37 for details of permitted transmission rates.\n        \n        \n          Range: [0, 3]\n        \n      mil_activation_modeInportInteger\n        \n            A code indicating the most severe form of MIL display required by the failure status the system or component.\n            Refer to J1939-73 Feb2010 section 5.7.37.4 for details.  A change of data on this\n            inport causes transmission of a DM37 message.  The transmission is delayed, if necessary,\n            until the minimum inter-message interval has elapsed.  Refer\n            to J1939-73 Feb2010 section 5.7.37 for details of permitted transmission rates.\n        \n        \n          Range: [0, 15]\n        \n      incomplete_monitorsInportInteger\n        \n            The number of incomplete diagnostic monitors for a given sub-system or component.\n            Refer to J1939-73 Feb2010 section 5.7.37.5 for details.  A change of data on this\n            inport causes transmission of a DM37 message.  The transmission is delayed, if necessary,\n            until the minimum inter-message interval has elapsed.  Refer\n            to J1939-73 Feb2010 section 5.7.37 for details of permitted transmission rates.\n            The platform will limit the value to the range specified below. This range is chosen\n            to match that of the 'Vehicle Incomplete Monitor Count' sent on DM36 message.\n        \n        \n          Range: [0, 64255]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM37 message could not be buffered for transmission,\n          or if a previous request to send a DM37 message has not completed.",
    "LLR.PLAT.J1939.73.DM37-TX.118": "The block pj1939_Dm37Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM37-TX.218": "The block pj1939_Dm37Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM37-TX.019": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not (see (todo: ref. to LLR)).",
    "LLR.PLAT.J1939.73.DM37-TX.020": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM37-TX.021": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n                  Rationale: \n                      The Simulink simulation environment does not easily allow the construction of CAN\n                      messages, so a simulation of the outports allows the user to construct a test\n                      framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM37-TX.022": "The block  shall  use the inport value force_transmission\n                to force transmission of a DM37 message, in accordance with requirement LLR.PLAT.J1939.73.DM37-TX.003",
    "LLR.PLAT.J1939.73.DM37-TX.023": "The block  shall  use the inport value priority\n                to set the DM37 message priority.",
    "LLR.PLAT.J1939.73.DM37-TX.024": "The block  shall  use the inport value snrw_count\n                to set the DM37 System Non-Roadworthy Component Count, in accordance with requirements\n                LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.025": "The block  shall  use the inport value continuous_mil\n                to set the DM37 System Continuous Malfunction Indicator, in accordance with requirements\n                LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.006",
    "LLR.PLAT.J1939.73.DM37-TX.026": "The block  shall  use the inport value mil_strategy\n                to set the DM37 System Malfunction Indicator Display Strategy, in accordance with requirements\n                LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.027": "The block  shall  use the inport value mil_activation_mode\n                to set the DM37 System Malfunction Indicator Activation Mode, in accordance with requirements\n                LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.028": "The block  shall  use the inport value incomplete_monitors\n                to set the DM37 Vehicle Incomplete Monitor Count, , in accordance with requirements\n                LLR.PLAT.J1939.73.DM37-TX.006 and LLR.PLAT.J1939.73.DM37-TX.007",
    "LLR.PLAT.J1939.73.DM37-TX.029": "If an error occurred when attempting to transmit the DM37 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM38-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM38-TX.002": "If a request to transmit a DM38 message is made, then the platform  shall \n              construct a DM38 message and attempt to buffer the DM38 message for transmission.",
    "LLR.PLAT.J1939.73.DM38-TX.003": "If the DM38 message cannot be transmitted then the platform  shall  discard the message\n              and set the output error flag to true.",
    "LLR.PLAT.J1939.73.DM38-TX.004": "Otherwise, the platform  shall  set the output error flag false.",
    "LLR.PLAT.J1939.73.DM38-TX.005": "The platform  shall  construct the data portion of the DM38 message\n              as specified by J1939\/73 section 5.7.38.",
    "LLR.PLAT.J1939.73.DM38-TX.006": "The platform  shall  reject any characters within the\n                Global Technical Regulation Description string that\n                are outside of the range of characters specified in J1939\/73 FEB2010 section 5.7.38.1",
    "LLR.PLAT.J1939.73.DM38-TX.007": "The platform  shall  limit the Global Technical Regulation Description string length to\n                the maximum number of characters specified in J1939\/73 FEB2010 section 5.7.38.1",
    "LLR.PLAT.J1939.73.DM38-TX.008": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM38-TX.009": "The platform shall provide a C interface function named\n                pj1939_dm38_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_gtr_description\n          in\n        const U8 *\nA description of the UN\/ECE WWH OBD Global Technical Regulation (GTR) to which the sub-system or component complies. See J1939-73 Feb2010 section 5.7.38.1 for details. The platform will limit the individual character ASCII value to the range specified below. Should a character fall outside, it is rejected and no further characters are processed. Range: [0, 127]pj1939f_string_length\n          in\n        U8\nThe length of the UN\/ECE WWH OBD Global Technical Regulation (GTR) string. See J1939-73 Feb2010 section 5.7.38.1 for details. The platform will limit the length to the range specified below. Range: [0, 200] characterspj1939f_priority\n          in\n        const U8\nThe priority of the DM38 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM38 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM38-TX.109": "The function pj1939_dm38_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM38-TX.209": "The function pj1939_dm38_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM38-TX.010": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_gtr_description, pj1939f_error_flag and\n                pj1939f_transport_error by raising a recoverable error\n                PJ1939_DM38_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM38-TX.011": "The platform  shall  set the DM38 message's priority to the value defined in parameter\n              pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM38-TX.012": "If a message has been successfully queued, the platform  shall  set\n              pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM38-TX.013": "The function  shall  set the Global Technical Regulation Description to the value of input\n              parameter pj1939f_gtr_description, in accordance with requirements\n              LLR.PLAT.J1939.73.DM38-TX.005, LLR.PLAT.J1939.73.DM38-TX.006 and LLR.PLAT.J1939.73.DM38-TX.007",
    "LLR.PLAT.J1939.73.DM38-TX.014": "The platform shall provide a Simulink interface block named\n                pj1939_Dm38Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM38 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM38 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM38 message could not be buffered for transmission,\n          or if a previous request to send a DM38 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      GTR descriptionParamString\n        \n          A description of the UN\/ECE WWH OBD Global Technical Regulation (GTR) to which\n          the sub-system or component complies.  See J1939-73 Feb2010 section 5.7.38.1 for details.\n          The entered string must be enclosed within single quotes.  The single quotes are\n          not, however, included in the transmitted string.  The platform will limit\n          the individual character ASCII values to the range specified below.\n          Should a character fall outside, it is rejected and no further characters are processed.\n          The platform will also limit the string length to the range specified below.\n        \n        \n          Range (ASCII character): [0, 127]\n        \n        \n          Range (string length): [0, 200] characters\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM38-TX.114": "The block pj1939_Dm38Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM38-TX.214": "The block pj1939_Dm38Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM38-TX.015": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not (see (todo: ref. to LLR)).",
    "LLR.PLAT.J1939.73.DM38-TX.016": "If the mask parameter GTR description\n              is empty then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM38-TX.017": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM38-TX.018": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.",
    "LLR.PLAT.J1939.73.DM38-TX.019": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM38-TX.020": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM38 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM38-TX.021": "The block  shall  use the inport value priority\n                to set the DM38 message priority.",
    "LLR.PLAT.J1939.73.DM38-TX.022": "The block  shall  use the mask parameter GTR description\n                to set the DM38 Global Technical Regulation Description, in accordance with requirements\n                LLR.PLAT.J1939.73.DM38-TX.005, LLR.PLAT.J1939.73.DM38-TX.006 and LLR.PLAT.J1939.73.DM38-TX.007",
    "LLR.PLAT.J1939.73.DM38-TX.023": "If an error occurred when attempting to transmit the DM38 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM39-TX.001": "If a request to transmit a DM39 message is made, then the platform  shall \n              construct a DM39 message and attempt to buffer the DM39 message for transmission.",
    "LLR.PLAT.J1939.73.DM39-TX.002": "If the DM39 message cannot be transmitted (unlikely for short messages\n              of 8 bytes or less) then the platform  shall  discard the message and set the output\n              error flag to true.",
    "LLR.PLAT.J1939.73.DM39-TX.003": "Otherwise, the platform  shall  set the output error flag false.",
    "LLR.PLAT.J1939.73.DM39-TX.004": "The platform  shall  construct the data portion of the DM39 message\n              as specified by J1939\/73 section 5.7.39.",
    "LLR.PLAT.J1939.73.DM39-TX.005": "The platform  shall  limit the contents of the DM39 message to the data ranges specified\n              in J1939\/73 FEB2010 section 5.7.39",
    "LLR.PLAT.J1939.73.DM39-TX.006": "The platform shall provide a C interface function named\n                pj1939_dm39_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_priority\n          in\n        const U8\nThe priority of the DM39 message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_sys_cumulative_mil_time\n          in\n        U32\nThe total amount of time that the MIL has been demanded to be illuminated during the life of the system or component. Refer to J1939-73 Feb2010 section 5.7.39.1 for details. The platform will limit the value to the range specified below.\n Range: [0, 4204501215] scaled at 0.05 hr\/bitpj1939f_total_b1_time\n          in\n        U16\nThe total amount of time that one or more DTCs with emission severity B1 have been active. Refer to J1939-73 Feb2010 section 5.7.39.2 for details. The platform will limit the value to the range specified below.\n Range: [0, 64255] scaled at 0.1 hr\/bitpj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM39 message for transmission, written false otherwise.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM39-TX.106": "The function pj1939_dm39_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM39-TX.206": "The function pj1939_dm39_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM39-TX.007": "The platform  shall  reject calls with a NULL pointer in parameter\n                pj1939f_error_flag by raising a recoverable error\n                PJ1939_DM39_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM39-TX.008": "The platform  shall  set the DM39 message's priority to the value defined in parameter\n              pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM39-TX.009": "The function  shall  set the System Cumulative Continuous MI to the value of input\n                parameter pj1939f_sys_cumulative_mil_time, in accordance\n                with requirements LLR.PLAT.J1939.73.DM39-TX.004 and LLR.PLAT.J1939.73.DM39-TX.005",
    "LLR.PLAT.J1939.73.DM39-TX.010": "The function  shall  set the System Greatest B1 Counter to the value of input\n                parameter pj1939f_total_b1_time, in accordance\n                with requirements LLR.PLAT.J1939.73.DM39-TX.004 and LLR.PLAT.J1939.73.DM39-TX.005",
    "LLR.PLAT.J1939.73.DM39-TX.011": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false, otherwise to true.",
    "LLR.PLAT.J1939.73.DM39-TX.012": "The platform shall provide a Simulink interface block named\n                pj1939_Dm39Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM39 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM39 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      cumulative_mil_timeInportInteger\n        \n          The total amount of time that the MIL has been demanded to be illuminated\n          during the life of the system or component.  Refer to\n          J1939-73 Feb2010 section 5.7.39.1 for details.\n        \n        \n          [0, 4204501215] scaled at 0.05 hr\/bit\n        \n      total_b1_timeInportInteger\n        \n          The total amount of time that one or more DTCs with emission severity B1 have been active.\n          Refer to J1939-73 Feb2010 section 5.7.39.2 for details.\n        \n        \n          Range: [0, 64255] scaled at 0.1 hr\/bit\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM39 message could not be buffered for transmission,\n          or if a previous request to send a DM39 message has not completed.",
    "LLR.PLAT.J1939.73.DM39-TX.112": "The block pj1939_Dm39Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM39-TX.212": "The block pj1939_Dm39Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM39-TX.013": "The interface  shall  raise an error if this block is present in a model but a\n              pj1939_Configuration block is not.",
    "LLR.PLAT.J1939.73.DM39-TX.014": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n              is within.",
    "LLR.PLAT.J1939.73.DM39-TX.015": "The interface  shall  set the value of outport\n              error_flag,\n              to the value of inport\n              sim_error_flag.\n                  Rationale: \n                      The Simulink simulation environment does not easily allow the construction of CAN\n                      messages, so a simulation of the outports allows the user to construct a test\n                      framework for the model by emulating requests for PGs and injecting errors.",
    "LLR.PLAT.J1939.73.DM39-TX.016": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM39 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM39-TX.017": "The block  shall  use the inport value priority\n                to set the DM39 message priority.",
    "LLR.PLAT.J1939.73.DM39-TX.018": "The block  shall  use the inport value cumulative_mil_time\n                to set the DM39 System Cumulative Continuous MI Time, in accordance\n                with requirements LLR.PLAT.J1939.73.DM39-TX.004 and LLR.PLAT.J1939.73.DM39-TX.005",
    "LLR.PLAT.J1939.73.DM39-TX.019": "The block  shall  use the inport value total_b1_time\n                to set the DM39 System Greatest B1 Counter, in accordance\n                with requirements LLR.PLAT.J1939.73.DM39-TX.004 and LLR.PLAT.J1939.73.DM39-TX.005",
    "LLR.PLAT.J1939.73.DM39-TX.020": "If an error occurred when attempting to transmit the DM39 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM40-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM40-TX.002": "If a request to transmit a DM40 message is made, then the platform  shall  construct a DM40 message and attempt to\n              buffer the DM40 message for transmission.\n            \n              The DM40 response is defined in J1939 Ref: 73, section 5.7.40.",
    "LLR.PLAT.J1939.73.DM40-TX.003": "If the DM40 message cannot be buffered, or if the previously buffered DM40 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM40-TX.004": "The platform  shall  construct the data portion of the DM40 message, from the list of DTCs in the DTC table\n              as specified by J1939\/73 section 5.7.40.",
    "LLR.PLAT.J1939.73.DM40-TX.005": "The platform  shall  limit the Failure Specific B1 Counter to\n                the range specified in J1939\/73 FEB2010 section 5.7.40.1",
    "LLR.PLAT.J1939.73.DM40-TX.006": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM40-TX.007": "The platform shall provide a C interface function named\n                pj1939_dm40_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM40 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_priority\n          in\n        const U8\nThe priority of the DM40 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM40 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM40-TX.107": "The function pj1939_dm40_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM40-TX.207": "The function pj1939_dm40_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM40-TX.008": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM40_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM40-TX.009": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM40 messages.",
    "LLR.PLAT.J1939.73.DM40-TX.010": "The platform  shall  set the message priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM40-TX.011": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM40-TX.012": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM40-TX.013": "The platform shall provide a Simulink interface block named\n                pj1939_Dm40Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to transmit a DM40 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM40 message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM40 message could not be buffered for transmission,\n          or if a previous request to send a DM40 message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM40-TX.113": "The block pj1939_Dm40Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM40-TX.213": "The block pj1939_Dm40Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM40-TX.014": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM40-TX.015": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM40-TX.016": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM40-TX.017": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_Dm40Transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM40-TX.018": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM40-TX.019": "The value of the inport sim_error_flag\n                 shall  be written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM40-TX.020": "The value of the inport sim_transport_errors\n                 shall  be written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM40-TX.021": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM40 table.",
    "LLR.PLAT.J1939.73.DM40-TX.022": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM40 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM40-TX.023": "The block  shall  use the inport value priority\n                to set the DM40 message priority.",
    "LLR.PLAT.J1939.73.DM40-TX.024": "If an error occurred when attempting to transmit the DM40 message then the\n                outport error_flag  shall  be set to 1 (TRUE).",
    "LLR.PLAT.J1939.73.DM40-TX.025": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM41-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM41-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM41 message for transmission.",
    "LLR.PLAT.J1939.73.DM41-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM41-TX.004": "If a request to transmit a DM41 message is made, then the platform  shall  construct a DM41 message and attempt to\n              buffer the DM41 message for transmission.\n            \n              The DM41 response is defined in J1939 Ref: 73, section 5.7.41.",
    "LLR.PLAT.J1939.73.DM41-TX.005": "If the DM41 message cannot be buffered, or if the previously buffered DM41 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM41-TX.006": "The platform  shall  set the DM41 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM41-TX.007": "The platform  shall  set the DM41 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM41-TX.008": "The platform  shall  set the DM41 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM41-TX.009": "The platform  shall  set the DM41 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM41-TX.010": "The platform  shall  construct the data portion of the DM41 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM41-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM41-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm41_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM41 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM41 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM41 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM41 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM41-TX.112": "The function pj1939_dm41_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM41-TX.212": "The function pj1939_dm41_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM41-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM41_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM41-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM41 messages.",
    "LLR.PLAT.J1939.73.DM41-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM41 transmission should be made.",
    "LLR.PLAT.J1939.73.DM41-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM41-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM41-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM41-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm41Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM41 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM41\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM41 message\n          could not be buffered for transmission, or if a previous request to send a DM41\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM41-TX.118": "The block pj1939_Dm41Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM41-TX.218": "The block pj1939_Dm41Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM41-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM41-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM41-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM41-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm41_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM41-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM41-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM41-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM41-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM41 table.",
    "LLR.PLAT.J1939.73.DM41-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM41 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM41-TX.027": "The block  shall  use the inport value priority\n                to set the DM41 message priority.",
    "LLR.PLAT.J1939.73.DM41-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM41-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM42-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM42-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM42 message for transmission.",
    "LLR.PLAT.J1939.73.DM42-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM42-TX.004": "If a request to transmit a DM42 message is made, then the platform  shall  construct a DM42 message and attempt to\n              buffer the DM42 message for transmission.\n            \n              The DM42 response is defined in J1939 Ref: 73, section 5.7.42.",
    "LLR.PLAT.J1939.73.DM42-TX.005": "If the DM42 message cannot be buffered, or if the previously buffered DM42 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM42-TX.006": "The platform  shall  set the DM42 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM42-TX.007": "The platform  shall  set the DM42 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM42-TX.008": "The platform  shall  set the DM42 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.42.",
    "LLR.PLAT.J1939.73.DM42-TX.009": "The platform  shall  set the DM42 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM42-TX.010": "The platform  shall  construct the data portion of the DM42 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM42-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM42-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm42_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM42 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM42 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM42 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM42 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM42-TX.112": "The function pj1939_dm42_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM42-TX.212": "The function pj1939_dm42_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM42-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM42_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM42-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM42 messages.",
    "LLR.PLAT.J1939.73.DM42-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM42 transmission should be made.",
    "LLR.PLAT.J1939.73.DM42-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM42-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM42-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM42-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm42Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM42 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM42\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM42 message\n          could not be buffered for transmission, or if a previous request to send a DM42\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM42-TX.118": "The block pj1939_Dm42Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM42-TX.218": "The block pj1939_Dm42Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM42-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM42-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM42-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM42-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm42_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM42-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM42-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM42-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM42-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM42 table.",
    "LLR.PLAT.J1939.73.DM42-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM42 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM42-TX.027": "The block  shall  use the inport value priority\n                to set the DM42 message priority.",
    "LLR.PLAT.J1939.73.DM42-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM42-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM43-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM43-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM43 message for transmission.",
    "LLR.PLAT.J1939.73.DM43-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM43-TX.004": "If a request to transmit a DM43 message is made, then the platform  shall  construct a DM43 message and attempt to\n              buffer the DM43 message for transmission.\n            \n              The DM43 response is defined in J1939 Ref: 73, section 5.7.43.",
    "LLR.PLAT.J1939.73.DM43-TX.005": "If the DM43 message cannot be buffered, or if the previously buffered DM43 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM43-TX.006": "The platform  shall  set the DM43 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM43-TX.007": "The platform  shall  set the DM43 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM43-TX.008": "The platform  shall  set the DM43 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.43.",
    "LLR.PLAT.J1939.73.DM43-TX.009": "The platform  shall  set the DM43 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM43-TX.010": "The platform  shall  construct the data portion of the DM43 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM43-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM43-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm43_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM43 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM43 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM43 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM43 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM43-TX.112": "The function pj1939_dm43_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM43-TX.212": "The function pj1939_dm43_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM43-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM43_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM43-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM43 messages.",
    "LLR.PLAT.J1939.73.DM43-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM43 transmission should be made.",
    "LLR.PLAT.J1939.73.DM43-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM43-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM43-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM43-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm43Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM43 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM43\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM43 message\n          could not be buffered for transmission, or if a previous request to send a DM43\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM43-TX.118": "The block pj1939_Dm43Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM43-TX.218": "The block pj1939_Dm43Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM43-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM43-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM43-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM43-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm43_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM43-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM43-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM43-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM43-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM43 table.",
    "LLR.PLAT.J1939.73.DM43-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM43 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM43-TX.027": "The block  shall  use the inport value priority\n                to set the DM43 message priority.",
    "LLR.PLAT.J1939.73.DM43-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM43-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM44-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM44-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM44 message for transmission.",
    "LLR.PLAT.J1939.73.DM44-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM44-TX.004": "If a request to transmit a DM44 message is made, then the platform  shall  construct a DM44 message and attempt to\n              buffer the DM44 message for transmission.\n            \n              The DM44 response is defined in J1939 Ref: 73, section 5.7.44.",
    "LLR.PLAT.J1939.73.DM44-TX.005": "If the DM44 message cannot be buffered, or if the previously buffered DM44 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM44-TX.006": "The platform  shall  set the DM44 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM44-TX.007": "The platform  shall  set the DM44 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM44-TX.008": "The platform  shall  set the DM44 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.44.",
    "LLR.PLAT.J1939.73.DM44-TX.009": "The platform  shall  set the DM44 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM44-TX.010": "The platform  shall  construct the data portion of the DM44 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM44-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM44-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm44_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM44 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM44 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM44 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM44 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM44-TX.112": "The function pj1939_dm44_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM44-TX.212": "The function pj1939_dm44_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM44-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM44_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM44-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM44 messages.",
    "LLR.PLAT.J1939.73.DM44-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM44 transmission should be made.",
    "LLR.PLAT.J1939.73.DM44-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM44-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM44-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM44-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm44Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM44 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM44\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM44 message\n          could not be buffered for transmission, or if a previous request to send a DM44\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM44-TX.118": "The block pj1939_Dm44Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM44-TX.218": "The block pj1939_Dm44Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM44-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM44-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM44-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM44-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm44_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM44-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM44-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM44-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM44-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM44 table.",
    "LLR.PLAT.J1939.73.DM44-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM44 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM44-TX.027": "The block  shall  use the inport value priority\n                to set the DM44 message priority.",
    "LLR.PLAT.J1939.73.DM44-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM44-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM45-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM45-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM45 message for transmission.",
    "LLR.PLAT.J1939.73.DM45-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM45-TX.004": "If a request to transmit a DM45 message is made, then the platform  shall  construct a DM45 message and attempt to\n              buffer the DM45 message for transmission.\n            \n              The DM45 response is defined in J1939 Ref: 73, section 5.7.45.",
    "LLR.PLAT.J1939.73.DM45-TX.005": "If the DM45 message cannot be buffered, or if the previously buffered DM45 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM45-TX.006": "The platform  shall  set the DM45 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM45-TX.007": "The platform  shall  set the DM45 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM45-TX.008": "The platform  shall  set the DM45 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.45.",
    "LLR.PLAT.J1939.73.DM45-TX.009": "The platform  shall  set the DM45 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM45-TX.010": "The platform  shall  construct the data portion of the DM45 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM45-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM45-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm45_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM45 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM45 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM45 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM45 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM45-TX.112": "The function pj1939_dm45_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM45-TX.212": "The function pj1939_dm45_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM45-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM45_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM45-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM45 messages.",
    "LLR.PLAT.J1939.73.DM45-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM45 transmission should be made.",
    "LLR.PLAT.J1939.73.DM45-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM45-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM45-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM45-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm45Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM45 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM45\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM45 message\n          could not be buffered for transmission, or if a previous request to send a DM45\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM45-TX.118": "The block pj1939_Dm45Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM45-TX.218": "The block pj1939_Dm45Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM45-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM45-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM45-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM45-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm45_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM45-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM45-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM45-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM45-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM45 table.",
    "LLR.PLAT.J1939.73.DM45-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM45 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM45-TX.027": "The block  shall  use the inport value priority\n                to set the DM45 message priority.",
    "LLR.PLAT.J1939.73.DM45-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM45-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM46-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM46-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM46 message for transmission.",
    "LLR.PLAT.J1939.73.DM46-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM46-TX.004": "If a request to transmit a DM46 message is made, then the platform  shall  construct a DM46 message and attempt to\n              buffer the DM46 message for transmission.\n            \n              The DM46 response is defined in J1939 Ref: 73, section 5.7.46.",
    "LLR.PLAT.J1939.73.DM46-TX.005": "If the DM46 message cannot be buffered, or if the previously buffered DM46 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM46-TX.006": "The platform  shall  set the DM46 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM46-TX.007": "The platform  shall  set the DM46 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM46-TX.008": "The platform  shall  set the DM46 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.46.",
    "LLR.PLAT.J1939.73.DM46-TX.009": "The platform  shall  set the DM46 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM46-TX.010": "The platform  shall  construct the data portion of the DM46 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM46-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM46-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm46_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM46 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM46 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM46 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM46 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM46-TX.112": "The function pj1939_dm46_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM46-TX.212": "The function pj1939_dm46_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM46-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM46_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM46-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM46 messages.",
    "LLR.PLAT.J1939.73.DM46-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM46 transmission should be made.",
    "LLR.PLAT.J1939.73.DM46-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM46-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM46-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM46-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm46Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM46 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM46\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM46 message\n          could not be buffered for transmission, or if a previous request to send a DM46\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM46-TX.118": "The block pj1939_Dm46Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM46-TX.218": "The block pj1939_Dm46Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM46-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM46-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM46-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM46-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm46_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM46-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM46-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM46-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM46-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM46 table.",
    "LLR.PLAT.J1939.73.DM46-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM46 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM46-TX.027": "The block  shall  use the inport value priority\n                to set the DM46 message priority.",
    "LLR.PLAT.J1939.73.DM46-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM46-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM47-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM47-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM47 message for transmission.",
    "LLR.PLAT.J1939.73.DM47-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM47-TX.004": "If a request to transmit a DM47 message is made, then the platform  shall  construct a DM47 message and attempt to\n              buffer the DM47 message for transmission.\n            \n              The DM47 response is defined in J1939 Ref: 73, section 5.7.47.",
    "LLR.PLAT.J1939.73.DM47-TX.005": "If the DM47 message cannot be buffered, or if the previously buffered DM47 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM47-TX.006": "The platform  shall  set the DM47 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM47-TX.007": "The platform  shall  set the DM47 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM47-TX.008": "The platform  shall  set the DM47 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.47.",
    "LLR.PLAT.J1939.73.DM47-TX.009": "The platform  shall  set the DM47 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM47-TX.010": "The platform  shall  construct the data portion of the DM47 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM47-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM47-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm47_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM47 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM47 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM47 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM47 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM47-TX.112": "The function pj1939_dm47_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM47-TX.212": "The function pj1939_dm47_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM47-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM47_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM47-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM47 messages.",
    "LLR.PLAT.J1939.73.DM47-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM47 transmission should be made.",
    "LLR.PLAT.J1939.73.DM47-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM47-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM47-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM47-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm47Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM47 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM47\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM47 message\n          could not be buffered for transmission, or if a previous request to send a DM47\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM47-TX.118": "The block pj1939_Dm47Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM47-TX.218": "The block pj1939_Dm47Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM47-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM47-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM47-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM47-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm47_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM47-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM47-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM47-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM47-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM47 table.",
    "LLR.PLAT.J1939.73.DM47-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM47 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM47-TX.027": "The block  shall  use the inport value priority\n                to set the DM47 message priority.",
    "LLR.PLAT.J1939.73.DM47-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM47-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM48-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM48-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM48 message for transmission.",
    "LLR.PLAT.J1939.73.DM48-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM48-TX.004": "If a request to transmit a DM48 message is made, then the platform  shall  construct a DM48 message and attempt to\n              buffer the DM48 message for transmission.\n            \n              The DM48 response is defined in J1939 Ref: 73, section 5.7.48.",
    "LLR.PLAT.J1939.73.DM48-TX.005": "If the DM48 message cannot be buffered, or if the previously buffered DM48 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM48-TX.006": "The platform  shall  set the DM48 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM48-TX.007": "The platform  shall  set the DM48 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM48-TX.008": "The platform  shall  set the DM48 message's DP, PF, R\/EDP and PS fields\n              as specified by J1939\/73 FEB2010 section 5.7.48.",
    "LLR.PLAT.J1939.73.DM48-TX.009": "The platform  shall  set the DM48 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM48-TX.010": "The platform  shall  construct the data portion of the DM48 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM48-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM48-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm48_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM48 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM48 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM48 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM48 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM48-TX.112": "The function pj1939_dm48_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM48-TX.212": "The function pj1939_dm48_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM48-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM48_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM48-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM48 messages.",
    "LLR.PLAT.J1939.73.DM48-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM48 transmission should be made.",
    "LLR.PLAT.J1939.73.DM48-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM48-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM48-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM48-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm48Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM48 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM48\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM48 message\n          could not be buffered for transmission, or if a previous request to send a DM48\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM48-TX.118": "The block pj1939_Dm48Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM48-TX.218": "The block pj1939_Dm48Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM48-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM48-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM48-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM48-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm48_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM48-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM48-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM48-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM48-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM48 table.",
    "LLR.PLAT.J1939.73.DM48-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM48 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM48-TX.027": "The block  shall  use the inport value priority\n                to set the DM48 message priority.",
    "LLR.PLAT.J1939.73.DM48-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM48-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM49-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM49-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM49 message for transmission.",
    "LLR.PLAT.J1939.73.DM49-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM49-TX.004": "If a request to transmit a DM49 message is made, then the platform  shall  construct a DM49 message and attempt to\n              buffer the DM49 message for transmission.\n            \n              The DM49 response is defined in J1939 Ref: 73, section 5.7.49.",
    "LLR.PLAT.J1939.73.DM49-TX.005": "If the DM49 message cannot be buffered, or if the previously buffered DM49 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM49-TX.006": "The platform  shall  set the DM49 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM49-TX.007": "The platform  shall  set the DM49 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM49-TX.008": "The platform  shall  set the DM49 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.49.",
    "LLR.PLAT.J1939.73.DM49-TX.009": "The platform  shall  set the DM49 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM49-TX.010": "The platform  shall  construct the data portion of the DM49 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM49-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM49-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm49_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM49 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM49 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM49 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM49 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM49-TX.112": "The function pj1939_dm49_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM49-TX.212": "The function pj1939_dm49_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM49-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM49_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM49-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM49 messages.",
    "LLR.PLAT.J1939.73.DM49-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM49 transmission should be made.",
    "LLR.PLAT.J1939.73.DM49-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM49-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM49-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM49-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm49Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM49 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM49\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM49 message\n          could not be buffered for transmission, or if a previous request to send a DM49\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM49-TX.118": "The block pj1939_Dm49Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM49-TX.218": "The block pj1939_Dm49Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM49-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM49-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM49-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM49-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm49_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM49-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM49-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM49-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM49-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM49 table.",
    "LLR.PLAT.J1939.73.DM49-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM49 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM49-TX.027": "The block  shall  use the inport value priority\n                to set the DM49 message priority.",
    "LLR.PLAT.J1939.73.DM49-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM49-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM50-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM50-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM50 message for transmission.",
    "LLR.PLAT.J1939.73.DM50-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM50-TX.004": "If a request to transmit a DM50 message is made, then the platform  shall  construct a DM50 message and attempt to\n              buffer the DM50 message for transmission.\n            \n              The DM50 response is defined in J1939 Ref: 73, section 5.7.50.",
    "LLR.PLAT.J1939.73.DM50-TX.005": "If the DM50 message cannot be buffered, or if the previously buffered DM50 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM50-TX.006": "The platform  shall  set the DM50 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM50-TX.007": "The platform  shall  set the DM50 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM50-TX.008": "The platform  shall  set the DM50 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.50.",
    "LLR.PLAT.J1939.73.DM50-TX.009": "The platform  shall  set the DM50 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM50-TX.010": "The platform  shall  construct the data portion of the DM50 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM50-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM50-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm50_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM50 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM50 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM50 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM50 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM50-TX.112": "The function pj1939_dm50_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM50-TX.212": "The function pj1939_dm50_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM50-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM50_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM50-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM50 messages.",
    "LLR.PLAT.J1939.73.DM50-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM50 transmission should be made.",
    "LLR.PLAT.J1939.73.DM50-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM50-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM50-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM50-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm50Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM50 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM50\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM50 message\n          could not be buffered for transmission, or if a previous request to send a DM50\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM50-TX.118": "The block pj1939_Dm50Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM50-TX.218": "The block pj1939_Dm50Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM50-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM50-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM50-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM50-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm50_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM50-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM50-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM50-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM50-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM50 table.",
    "LLR.PLAT.J1939.73.DM50-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM50 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM50-TX.027": "The block  shall  use the inport value priority\n                to set the DM50 message priority.",
    "LLR.PLAT.J1939.73.DM50-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM50-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM51-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM51-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM51 message for transmission.",
    "LLR.PLAT.J1939.73.DM51-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM51-TX.004": "If a request to transmit a DM51 message is made, then the platform  shall  construct a DM51 message and attempt to\n              buffer the DM51 message for transmission.\n            \n              The DM51 response is defined in J1939 Ref: 73, section 5.7.51.",
    "LLR.PLAT.J1939.73.DM51-TX.005": "If the DM51 message cannot be buffered, or if the previously buffered DM51 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM51-TX.006": "The platform  shall  set the DM51 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM51-TX.007": "The platform  shall  set the DM51 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM51-TX.008": "The platform  shall  set the DM51 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.51.",
    "LLR.PLAT.J1939.73.DM51-TX.009": "The platform  shall  set the DM51 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM51-TX.010": "The platform  shall  construct the data portion of the DM51 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM51-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM51-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm51_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM51 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM51 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM51 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM51 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM51-TX.112": "The function pj1939_dm51_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM51-TX.212": "The function pj1939_dm51_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM51-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM51_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM51-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM51 messages.",
    "LLR.PLAT.J1939.73.DM51-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM51 transmission should be made.",
    "LLR.PLAT.J1939.73.DM51-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM51-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM51-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM51-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm51Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM51 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM51\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM51 message\n          could not be buffered for transmission, or if a previous request to send a DM51\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM51-TX.118": "The block pj1939_Dm51Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM51-TX.218": "The block pj1939_Dm51Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM51-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM51-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM51-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM51-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm51_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM51-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM51-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM51-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM51-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM51 table.",
    "LLR.PLAT.J1939.73.DM51-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM51 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM51-TX.027": "The block  shall  use the inport value priority\n                to set the DM51 message priority.",
    "LLR.PLAT.J1939.73.DM51-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM51-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM52-TX.001": "The platform  shall  reset the number of transport errors to 0.",
    "LLR.PLAT.J1939.73.DM52-TX.002": "If the node address for the ECU cannot be claimed, or the CAN link for J1939 is bus-off, then the platform  shall \n              set the error state to true and not attempt to buffer a DM52 message for transmission.",
    "LLR.PLAT.J1939.73.DM52-TX.003": "When the ECU has a network address (has claimed a non-NULL address without conflict), then the platform  shall \n              participate in all communications.",
    "LLR.PLAT.J1939.73.DM52-TX.004": "If a request to transmit a DM52 message is made, then the platform  shall  construct a DM52 message and attempt to\n              buffer the DM52 message for transmission.\n            \n              The DM52 response is defined in J1939 Ref: 73, section 5.7.52.",
    "LLR.PLAT.J1939.73.DM52-TX.005": "If the DM52 message cannot be buffered, or if the previously buffered DM52 message has not been completely\n              transmitted, then the platform  shall  discard the message and set the error state to true, otherwise it\n              shall be set false.",
    "LLR.PLAT.J1939.73.DM52-TX.006": "The platform  shall  set the DM52 message's P field to the defined priority.",
    "LLR.PLAT.J1939.73.DM52-TX.007": "The platform  shall  set the DM52 message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM52-TX.008": "The platform  shall  set the DM52 message's DP, PF, R\/EDP and PS\n              fields as specified by J1939\/73 FEB2010 section 5.7.52.",
    "LLR.PLAT.J1939.73.DM52-TX.009": "The platform  shall  set the DM52 message's SA field to the current claimed network address.",
    "LLR.PLAT.J1939.73.DM52-TX.010": "The platform  shall  construct the data portion of the DM52 message, from the list of DTCs\n              in the DTC table specified by parameter \u201cDTC Table Identifier\u201d with severity and state\n              as per table \u201cPGN ASSIGNMENTS FOR HARMONIZED FAILURE REPORTING\u201d in J1939\/73 section 5.7.41.",
    "LLR.PLAT.J1939.73.DM52-TX.011": "The platform  shall  accumulate the number of transmit errors encountered by the\n              transport protocol, saturating the counter at 255 errors.",
    "LLR.PLAT.J1939.73.DM52-TX.012": "The platform shall provide a C interface function named\n                pj1939_dm52_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the DM52 message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_transmit\n          in\n        const U8\nSet true if the DM52 message should be transmitted, false otherwise.pj1939f_priority\n          in\n        const U8\nThe priority of the DM52 message to be transmitted. The lower the priority value, the higher the message priority. Note that this value will be overridden for multi-frame transmissions if the capi assignment statement multiframe-priority is defined (but will still be used for single-frame transmissions).\n Range: [0, 7]pj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM52 message for transmission, Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors\n                The function returns void.",
    "LLR.PLAT.J1939.73.DM52-TX.112": "The function pj1939_dm52_transmit() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM52-TX.212": "The function pj1939_dm52_transmit() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM52-TX.013": "The platform  shall  reject calls with a NULL pointer in any of the following parameters\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_DM52_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM52-TX.014": "The platform  shall  use the DTC table defined by pj1939f_table when\n                sending DM52 messages.",
    "LLR.PLAT.J1939.73.DM52-TX.015": "The value of pj1939f_transmit  shall  be used to determine\n                if a DM52 transmission should be made.",
    "LLR.PLAT.J1939.73.DM52-TX.016": "If a message has been successfully queued, the platform  shall  set the message\n                priority to pj1939f_priority.",
    "LLR.PLAT.J1939.73.DM52-TX.031": "If a message has been successfully queued, the platform  shall  set\n                pj1939f_error_flag to false otherwise to true.",
    "LLR.PLAT.J1939.73.DM52-TX.017": "The platform  shall  report the number of transport protocol errors encountered\n                thus far in pj1939f_transport_error.",
    "LLR.PLAT.J1939.73.DM52-TX.018": "The platform shall provide a Simulink interface block named\n                pj1939_Dm52Transmit that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_error_flagInportBoolean\n        \n          The simulation inport\n          for the error_flag outport.\n        \n      sim_transport_errorsInportInteger\n        \n          Simulation value\n          of the outport transport_errors.\n        \n      transmitInportBoolean\n        \n          Set to 1 to\n          transmit a DM52 message, set to zero otherwise.\n        \n        \n          Range: 0 or 1.\n        \n      priorityInportInteger\n        \n          J1939 priority of the DM52\n          message to be transmitted.\n        \n        \n          Range: [0, 7]\n        \n      error_flagOutportBoolean\n        \n          Set to 1 when the DM52 message\n          could not be buffered for transmission, or if a previous request to send a DM52\n          message has not completed.\n        \n      transport_errorsOutportInteger\n        \n          Saturated count of\n          transport errors (timeout or aborts) for this message.\n        \n        \n          Range: [0, 255]\n        \n      DTC table identifierParamString\n        \n          The name of\n          the DTC table to act on (there must be a corresponding named table\n          specified in a pdtc_Table block\n          in the model).\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.DM52-TX.118": "The block pj1939_Dm52Transmit shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.DM52-TX.218": "The block pj1939_Dm52Transmit shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM52-TX.019": "The model is checked by the interface to see if it contains the block, pj1939_Configuration,\n                if it does not then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM52-TX.020": "The mask parameter DTC table identifier\n                is checked by the interface to see that it is not empty if it is then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM52-TX.021": "The mask parameter DTC table identifier is checked by the interface\n                to see that it matches that defined in a pdtc_Table block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM52-TX.022": "The mask parameter DTC table identifier is checked by the interface\n                to see that it only gets referenced in one pj1939_dm52_transmit block, if it doesn't the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.DM52-TX.030": "The block  shall  schedule itself to run on target at the rate specified by the subsystem that the block\n                is within.",
    "LLR.PLAT.J1939.73.DM52-TX.023": "The value of the inport sim_error_flag\n                is written to the outport error_flag.",
    "LLR.PLAT.J1939.73.DM52-TX.024": "The value of the inport sim_transport_errors\n                is written to the outport transport_errors.",
    "LLR.PLAT.J1939.73.DM52-TX.025": "The block  shall  use the mask value DTC table identifier\n                to set the relevant DM52 table.",
    "LLR.PLAT.J1939.73.DM52-TX.026": "If the inport transmit is set to 1 (TRUE) then the block  shall \n                cause a DM52 message to be constructed and transmitted.",
    "LLR.PLAT.J1939.73.DM52-TX.027": "The block  shall  use the inport value priority\n                to set the DM52 message priority.",
    "LLR.PLAT.J1939.73.DM52-TX.028": "The block  shall  write the buffer error status to the outport\n                error_flag.",
    "LLR.PLAT.J1939.73.DM52-TX.029": "The block  shall  write the number of transmit errors encountered to the outport\n                transport_errors.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.001": "If the node address for the ECU cannot be claimed, then the platform  shall  set the\n                error state true and not attempt to buffer a DM message for transmission.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.002": "When requested by the application, the platform  shall  construct the required DM\n                and attempt to buffer the message for transmission.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.003": "If the DM message cannot be buffered, or if the previously buffered DM message has\n                not been completely transmitted, then the platform  shall  discard the message and set\n                the error state true.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.004": "Otherwise, the DM message was buffered, and the platform  shall  set the\n                error state false.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.005": "The block  shall  support the DM1 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.020": "The block  shall  support the DM2 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.021": "The block  shall  support the DM6 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.022": "The block  shall  support the DM12 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.023": "The block  shall  support the DM23 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.024": "The block  shall  support the DM26 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.025": "The block  shall  support the DM27 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.026": "The block  shall  support the DM28 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.027": "The block  shall  support the DM29 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.028": "The block  shall  support the DM31 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.029": "The block  shall  support the DM41 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.030": "The block  shall  support the DM42 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.031": "The block  shall  support the DM43 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.032": "The block  shall  support the DM44 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.033": "The block  shall  support the DM45 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.034": "The block  shall  support the DM46 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.035": "The block  shall  support the DM47 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.036": "The block  shall  support the DM48 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.037": "The block  shall  support the DM49 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.038": "The block  shall  support the DM50 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.039": "The block  shall  support the DM51 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.040": "The block  shall  support the DM52 diagnostic message.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.006": "The platform  shall  set the DM message's P field from the input \u201cpriority\u201d, clipped\n                to the range [0, 7].",
    "LLR.PLAT.J1939.73.DM-DTC-TX.007": "The platform  shall  set the DM message's reserved field to zero.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.008": "The platform  shall  set the DM message's DP, PF, R\/EDP and PS fields as specified by\n                the appropriate subsection of J1939\/73 FEB2010 section 5.7.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.009": "The platform  shall  set the DM message's SA field to the current claimed network\n                address.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.010": "The platform  shall  construct the data portion of the DM message, from the list of\n                DTCs in the DTC table specified by parameter \u201cDTC Table Identifier\u201d using the\n                criteria as specified by the appropriate subsection of J1939\/73 section 5.7.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.011": "When the model is initialised, the platform  shall  set the DM message's transport\n                error count to zero.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.012": "If an error occurs while transmitting the message using the transport protocol, then\n                the platform  shall  increment the DM message's transport error count (saturating at\n                255) and set the output 'transport_errors' to the message's transport error count.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.013": "The platform shall provide a C interface function named\n                pj1939_transmit_dtc_dm() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_table\n          in\n        const PDTC_TABLE_T *const\nA pointer to a diagnostic trouble code table. The contents of the message are derived from DTCs of J1939 type in this table (DTCs of other types are ignored).\n Cannot be NULL.pj1939f_priority\n          in\n        const U8\nThe priority of the message to be transmitted. The lower the priority value, the higher the message priority.\n Range: [0, 7]pj1939f_dest_addr\n          in\n        const U8\nDestination address for the message to be transmitted (usually the source address for the corresponding request). Range: [0, 254] for specific destination or J1939_GLOBAL_ADDRESS for broadcastpj1939f_pgn\n          in\n        const PGN_T\nThe PGN of the DM to be transmitted.pj1939f_dm_type\n          in\n        const PJ1939_DM_TYPE\nThe type of DTC data to report in this DM responsepj1939f_esev\n          in\n        const PIO_EMISSION_SEV_TYPE_T\nThe emissions severity of DTCs to reportpj1939f_esev_cmp\n          in\n        const PDTC_IT_ESEV_COMPARATOR_T\nThe emissions severity comparison type for DTCs to reportpj1939f_state\n          in\n        const PDTC_STATE_T\nThe state of DTCs to reportpj1939f_state_cmp\n          in\n        const PDTC_IT_STATE_COMPARATOR_T\nThe DTC state comparison type for DTCs to reportpj1939f_perm_test\n          in\n        const PDTC_IT_PERM_TEST_T\nWhether to report only CARB permanent DTCspj1939f_error_flag\n          out\n        U8 *\nA pointer to the location to write with the status of the transmission. Written true if there was no free transmit buffer available to hold the DM message for transmission. Written false otherwise.\n Cannot be NULL.pj1939f_transport_error\n          out\n        U8 *\nA pointer to the location to write the saturated count of transport errors encountered.\n Cannot be NULL.\n Range: [0, 255] errors \n                The function returns void.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.014": "The platform  shall  reject calls with a NULL pointer in any of the following parameters,\n                pj1939f_table, pj1939f_error_flag and pj1939f_transport_error\n                by raising a recoverable error PJ1939_PGN_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.015": "If the value of the pj1939f_pgn is the PGN of an unsupported message then the\n                platform  shall  consider this an error by raising a recoverable error PJ1939_PGN_TRANSMIT_INVALID_ARG.",
    "LLR.PLAT.J1939.73.DM-DTC-TX.016": "If the pj1939f_pgn parameter contains the value of a supported PGN, the message\n                 shall  be constructed and queued for transmission.\n              Rationale: \n                The diagnostic data required for these is already stored by the platform, and it\n                would be difficult to implement correctly or efficiently in Simulink or Stateflow.",
    "LLR.PLAT.J1939.CONFIG.037": "If so enabled, the platform  shall  set the priority value for all multi-frame J1939\n              diagnostic message (DM) transmissions using a single configurable value.\n            Note: \n              When used, this overrides the individual priority values for each DM, which however\n              still applies for single-frame transmissions.",
    "LLR.PLAT.J1939.CONFIG.036": "If the multiframe-priority assignment statement is present in the\n              j1939-messaging compound, then the platform  shall  override the priority\n              settings for all multi-frame J1939 diagnostic message transmissions with the value provided.",
    "LLR.PLAT.J1939.CONFIG.001": "The platform shall provide a Simulink interface block named\n                pj1939_Configuration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionCAN bus identifierParamList\n        \n          A drop-down\n          selection of CAN buses available for J1939 messaging.\n        \n      \n                Calibratable: no.\n              Source node addressParamInteger\n        \n          The J1939\n          network node address for this ECU.\n        \n        \n          The automatically generated calibration parameter for this is pj1939c_node_addr_0.\n        \n        \n          Range: [0, 253]\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Source node nameParamInteger\n        \n          The name of the\n          source ECU, given as a vector of 8 elements. The node name excludes the\n          self-configuration field (see parameter Source self-configuring).\n        \n        \n          Element 1: Industry group (Range: [0, 7]).\n        \n        \n          Element 2: Vehicle system instance (Range: [0, 15]).\n        \n        \n          Element 3: Vehicle system (Range: [0, 127]).\n        \n        \n          Element 4: Function (Range: [0, 255]).\n        \n        \n          Element 5: Function instance (Range: [0, 31]).\n        \n        \n          Element 6: ECU instance (Range: [0, 7]).\n        \n        \n          Element 7: Manufacturer code (Range: [0, 2047]).\n        \n        \n          Element 8: Identify number (Range: [0, 2097151]).\n        \n      \n                Calibratable: no.\n              Source self-configuring?ParamBoolean\n        \n          Set if this\n          ECU can self-configure its network address, clear if this ECU will remain at\n          a fixed address.\n        \n      \n                Calibratable: no.\n              Size of J1939 message buffersParamInteger\n        \n          The number\n          of bytes for each J1939 message buffer. In some networks, the maximum length of\n          any received or transmitted J1939 message will be smaller than the maximum\n          J1939 length of 1785 bytes. This parameter allows the modeller to reduce the amount\n          of RAM allocated to J1939 messages, and therefore increase the RAM allocated\n          to other functions of the ECU.\n        \n        \n          Range: [8, 1785]\n        \n      \n                Calibratable: no.\n              Number of simultaneous transport receive messagesParamInteger\n        \n          The number of long (transport) messages than can be received simultaneously.\n          The smaller the number, the more RAM is allocated to other functions of the ECU.\n        \n        \n          Range: [1, 20]\n        \n        Note\n            The larger the number, the more transport messages can be received at the same time.\n            However, the larger the number, the more likely it is that it will not be possible\n            for the ECU to adhere to the J1939 transport timeouts and some message receives\n            may fail.\n          \n      \n                Calibratable: no.\n              Number of simultaneous transport transmit messagesParamInteger\n        \n          The number of long (transport) messages than can be transmitted simultaneously.\n          The smaller the number, the more RAM is allocated to other functions of the ECU.\n        \n        \n          Range: [1, 20]\n        \n        Note\n            The larger the number, the more transport messages can be transmitted at the same time.\n            However, the larger the number, the more likely it is that it will not be possible\n            for the ECU to adhere to the J1939 transport timeouts and some message transmits\n            may fail.\n          \n      \n                Calibratable: no.\n              Number of receive\/transmit buffersParamInteger\n        \n          The number\n          of receive and transmit buffers used to store J1939 CAN data between processing of\n          J1939 messages (which occurs every 5 milliseconds).\n        \n        \n          Range: [1, 100]\n        \n      \n                Calibratable: no.\n              DM7 Request buffer sizeParamInteger\n        \n          The maximum number of DM7 test entries that may be stored in the buffer, upon receipt of\n          DM7 request messages.\n        \n        \n          Range: [1, 10]\n        \n      \n                Calibratable: no.\n              Use common multi-frame priorityParamBoolean\n        \n          A checkbox to enable the use of a common multi-frame priority. This priority\n          overrides the priorities for all DM transmit blocks for multi-frame message\n          responses. (Single frame responses are unaffected.) It does not affect any\n          priorities passed to instances of the pj1939_PgTransmit block.\n        \n      \n                Calibratable: no.\n              Common multi-frame priorityParamInteger\n        \n          The value of the common multi-frame priority. Only available when the mask parameter checkbox\n          Use common multi-frame priority is ticked.\n        \n        \n          Range: [0, 7]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.CONFIG.101": "The block pj1939_Configuration shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.CONFIG.201": "The block pj1939_Configuration shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.CONFIG.019": "The model must have a pcx_CANConfiguration block for the CAN bus specified by the mask\n                CAN bus identifier, if none is found, the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.020": "If the parameter Source node address is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.021": "If the parameter Source node name is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.022": "If the parameter Size of J1939 message buffers is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.023": "If the parameter Number of simultaneous transport receive messages\n                is out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.024": "If the parameter Number of simultaneous transport transmit messages\n                is out of range, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.025": "If the parameter Number of receive\/transmit buffers is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.033": "If the parameter DM7 Request buffer size is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.034": "If the checkbox Use common multi-frame priority is selected\n                and the parameter Common multi-frame priority is outside the\n                range [0, 7], then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.026": "If the parameter Target type is unsupported, then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.027": "If there is more than one pj1939_Configuration block in the model then the block  shall  raise an error.",
    "LLR.PLAT.J1939.CONFIG.028": "If no pj1939_Configuration block exists in the model, then the J1939 functionality of the platform  shall  be turned off\n                (DTC functionality will still be available).\n              Note: \n                Otherwise, the J1939 functionality is required and the following apply.",
    "LLR.PLAT.J1939.CONFIG.040": "The block  shall  set the CAN bus used for J1939 communications to the bus specified by the mask CAN\n                CAN bus identifier.",
    "LLR.PLAT.J1939.CONFIG.041": "The block  shall  set the application node address to the value specified by the mask\n                Source node address.",
    "LLR.PLAT.J1939.CONFIG.042": "The block  shall  set the application node NAME to the value specified by the mask\n                Source node name.",
    "LLR.PLAT.J1939.CONFIG.043": "The block  shall  set the maximum size of J1939 messages to the value specified by the mask Size of\n                Size of J1939 message buffers.",
    "LLR.PLAT.J1939.CONFIG.029": "The block  shall  set the number of simultaneous J1939 transport messages the application is capable of receiving\n                to the value specified by the mask\n                Number of simultaneous transport receive messages.",
    "LLR.PLAT.J1939.CONFIG.030": "The block  shall  set the number of simultaneous J1939 transport messages the application is capable of\n                transmitting to the value specified by the mask\n                Number of simultaneous transport transmit messages.",
    "LLR.PLAT.J1939.CONFIG.031": "The block  shall  set the number of J1939 CAN messages the application is capable of storing between processing\n                to the value specified by the mask\n                Number of receive\/transmit buffers",
    "LLR.PLAT.J1939.CONFIG.032": "The block  shall  set the number of J1939 DM7 test requests the platform is capable of queueing\n                to the value specified by the mask\n                DM7 Request buffer size",
    "LLR.PLAT.J1939.CONFIG.035": "If the checkbox Use common multi-frame priority is selected,\n                the block  shall  use the mask parameter Common multi-frame priority\n                to define the priority for all multi-frame J1939 diagnostic message transmissions.",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.001": "When requested by the application, the platform  shall  construct the required\n              PG acknowledgement response and attempt to pass the message to the transport layer\n              for transmission.",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.002": "If the acknowledgement message cannot be transmitted (unlikely for 'short' messages\n              of 8 bytes or less) then the platform  shall  discard the message and set the\n              error state true, in order to indicate to the application that there was a problem\n              in dealing with the request.",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.003": "Otherwise, the acknowledgement message was successfully processed by the transport layer,\n              and the platform  shall  set the error state false.",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.004": "The platform shall provide a C interface function named\n                pj1939_pgn_send_ack() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_pgn_to_ack\n          in\n        const U32\nThe PGN request that is being acknowledged.pj1939f_required_response\n          in\n        const PJ1939_ACK_AND_CONTROL_BYTE_T\nThe required response - ACK\/NACK\/ACCESS_DENIED\/BUSY.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - if transmission succeedsFALSE - if transmission fails",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.104": "The function pj1939_pgn_send_ack() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.204": "The function pj1939_pgn_send_ack() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.DM-SEND-ACK.032": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.APP.J1939.REPR.001": "The application should initialize the J1939 protocol on the 2nd CAN channel\n              of the ECU with a baudrate of 250KBps.",
    "LLR.PLAT.J1939.REPR.002": "The platform  shall  reset the security credentials at initialization (enable security).",
    "LLR.PLAT.J1939.REPR.003": "The platform  shall  configure the security algorithms with appropriate\n              application calibrations.",
    "LLR.PLAT.J1939.REPR.015": "The platform  shall  default to disinhibit reprogramming and memory access commands over J1939.",
    "LLR.PLAT.J1939.REPR.004": "The platform  shall  inspect all received DM14 message commands only\n              from a Service Tool with a J1939 source address of 0xF9.",
    "LLR.APP.J1939.REPR.005": "The application should configure the J1939 source address to a value of 0x3D\n              which coincides with the J1939 source address of the bootloader.",
    "LLR.PLAT.J1939.REPR.016": "If a 'Boot Load' DM14 command is received and reprogramming and memory access is inhibited,\n              the platform  shall  send a DM15 message response with a status of 'Busy',\n             'EDCP Extension' set to 'Data in Error Indicator\/EDC Parameter is\n             an Error Indicator' (0x06) and the 'Error Indicator' set to an appropriate error code\n             depending on the reson for inhibiting given by the application.",
    "LLR.PLAT.J1939.REPR.006": "If a 'Boot Load' DM14 command is received and security is disabled and reprogramming and\n              memory access is disinhibited, the platform  shall  respond to this command with a 'Proceed'\n              response on a DM15 message and then it shall pass execution to the bootloader.",
    "LLR.PLAT.J1939.REPR.007": "If a DM14 command other than 'Boot Load' is received, the platform\n               shall  not respond to this command and it will pass it on to the\n              platform filters to be available for an eventual call to\n              pj1939_pg_receive() function.",
    "LLR.PLAT.J1939.REPR.008": "The platform  shall  ignore 'Length\/Number Requested', 'Pointer Type',\n              'Pointer' and 'Pointer Extension' values on a DM14 command.",
    "LLR.PLAT.J1939.REPR.009": "If a 'Boot Load' DM14 command is received and security is enabled and reprogramming and\n              memory access is disinhibited, the platform  shall  respond to this command with a 'Proceed'\n              response and a 'Seed' value generated by the security algorithms on a DM15 message.",
    "LLR.PLAT.J1939.REPR.010": "If after sending a Seed value, a DM14 response is not received within\n              a time allowed (T1 time form J1939-21), the platform  shall  resend\n              the last DM15 message with a Seed value of 'Seed Completed \u2014 begin\n              sending key', 'EDCP Extension' set to 'Data in Error Indicator\/EDC\n              Parameter is an Error Indicator' (0x06) and the 'Error Indicator'\n              set to 'NO response in the time allowed' (0x10002), it shall\n              reset the timers and continue to wait for a response.\n              (see J1939-73 section C.2.4.6)",
    "LLR.PLAT.J1939.REPR.011": "If after sending a Seed value, a DM14 response with a Key is not\n             received and a DM15 message was sent 2 times to request for a Key,\n             the platform  shall  send a DM15 message with a status of 'Busy',\n             'EDCP Extension' set to 'Data in Error Indicator\/EDC Parameter is\n             an Error Indicator' (0x06) and the 'Error Indicator' set to 'NO\n             response in the time allowed' (0x10002), and it shall stop waiting\n             for a response with a Key.",
    "LLR.PLAT.J1939.REPR.012": "If after sending a Seed value, a DM14 response with a Key is received\n               and the key value is deemed valid by the platform's security algorithms,\n               the platform  shall  respond to the initial command with a 'Proceed'\n               response on a DM15 message and then it shall pass execution to the bootloader.",
    "LLR.PLAT.J1939.REPR.013": "The platform  shall  implement a security algorithm that generates\n               a random 2-byte seed. (the seed values need to be compliant with\n               the Seed requirements in the J1939-73 specification section 5.7.15.4)",
    "LLR.PLAT.J1939.REPR.014": "The platform  shall  implement a security algorithm function that\n               calculates a 2-byte key based on an arbitrary 2-byte seed.\n               (the key values need to be compliant with the Key requirements\n               in the J1939-73 specification section 5.7.14.4)",
    "LLR.PLAT.J1939.REPR.017": "The platform shall provide a C interface function named\n                pj1939_inhibit_reprogramming() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_inhibit\n          in\n        U8\nTrue if reprogramming should be inhibited, false otherwise.pj1939f_reason\n          in\n        PJ1939_INHIBIT_REPR_REASONS_T\nGives the reason for inhibiting reprogramming.\n                The function returns void.",
    "LLR.PLAT.J1939.REPR.117": "The function pj1939_inhibit_reprogramming() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.REPR.217": "The function pj1939_inhibit_reprogramming() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.J1939.REPR.018": "The platform  shall  inhibit reprogramming and memory access if the pj1939f_inhibit\n                parameter is true and enable reprogramming otherwise.",
    "LLR.PLAT.J1939.REPR.019": "If reprogramming and memory access is inhibited, the platform  shall  read the\n                pj1939f_reason parameter and translate it in an Error Indicator\n                on a DM15 response.",
    "LLR.PLAT.J1939.REPR.020": "The platform shall provide a Simulink interface block named\n                pj1939_InhibitReprogramming that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninhibitInportBoolean\n        \n          Set to 0 to allow reprogramming,\n          set to 1 to disallow reprogramming.\n        \n      reasonInportU32\n        \n          \n                    Value\n                  \n                    Name\n                  \n                    Description\n                  0GeneralApplication needs to inhibit reprogramming but there is no specific reason given.1Not in Diagnostic ModeApplication needs to inhibit reprogramming because the unit is not in Diagnostic Mode.2Not in Engineering ModeApplication needs to inhibit reprogramming because the unit is not in Engineering Mode.3Not in Development ModeApplication needs to inhibit reprogramming because the unit is not in Development Mode.4Engine is runningApplication needs to inhibit reprogramming because the vehicle's engine is running.5Vehicle not in ParkApplication needs to inhibit reprogramming because the vehicle's transmission is not in the Park position.6Vehicle not stationaryApplication needs to inhibit reprogramming because the vehicle is in motion.\n          \n              It is the choice of the application designer to select one of the above reasons for inhibiting reprogramming based on the information\n              that is available to the application. The 'reason' information will be translated in to an Error Indicator on the J1939 DM15 responses\n              as specified by the J1939-73 specifications. If reprogramming is allowed, hence not inhibited, the 'reason' inport will be ignored.",
    "LLR.PLAT.J1939.REPR.120": "The block pj1939_InhibitReprogramming shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.REPR.220": "The block pj1939_InhibitReprogramming shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.J1939.REPR.021": "The block  shall  schedule itself to run on target at the rate\n                  specified by the subsystem that the block is within.",
    "LLR.PLAT.J1939.REPR.022": "The block  shall  inhibit J1939 reprogramming when the inport parameter\n                  inhibit is set to 1\n                  and enable J1939 reprogramming when set to 0.",
    "LLR.PLAT.J1939.REPR.023": "If J1939 reprogramming is not inhibited, the block  shall  ignore the inport parameter\n                  reason.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.001": "When requested by the application software, the platform  shall  update the status of the desired\n                NTE area.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.002": "The platform shall provide a C interface function named\n                pj1939_set_control_area_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpj1939f_cntrl_area\n          in\n        PJ1939_NTE_CNTRL_AREA_T\nThe NTE control area for which the status has to be set.\npj1939f_cntrl_area_status\n          in\n        PJ1939_NTE_CNTRL_AREA_STATUS_T\nThe status for the selected NTE control area.\n\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - if the status was updated successfullyFALSE - if the status was not updated due to invalid arguments",
    "LLR.PLAT.J1939.73.UPDATE-NTE.102": "The function pj1939_set_control_area_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.202": "The function pj1939_set_control_area_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.UPDATE-NTE.003": "The software  shall  set the control area status corresponding to the pj1939f_cntrl_area to\n                the value of pj1939f_cntrl_area_status.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.004": "The platform shall provide a Simulink interface block named\n                pj1939_UpdateNteStatus that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionnte_statusInportInteger\n        \n          A 2-bit status code indicating the status of engine operation within the\n          manufacturer specific NTE area.  See J1939-73 FEB2010 section 5.7.34 for details\n          of these codes.\n        \n      NTE areaParamList\n        \n          A drop down to identify the NTE area for which the status is to be updated.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.104": "The block pj1939_UpdateNteStatus shall support the targets:\n            All targets.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.204": "The block pj1939_UpdateNteStatus shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.J1939.73.UPDATE-NTE.005": "If the parameter Sample time is outside its\n              range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.006": "The block  shall  schedule itself to run under simulation and on target at the rate\n              specified by parameter Sample time.",
    "LLR.PLAT.J1939.73.UPDATE-NTE.007": "The block  shall  use the inport value nte_status\n                to set the NTE status for the given NTE area\n                (as selected by parameter NTE area).",
    "LLR.APP.PKN.TASK.001": "For C-API application, the application  will  define its tasks, priorities, period\n              and resources in the capi interface definition file.",
    "LLR.APP.PKN.TASK.002": "The application  will  define at least one task.",
    "LLR.PLAT.PKN.TASK.001": "The platform  shall  allow up to 12 separate user defined tasks.",
    "LLR.PLAT.PKN.EXCEP.001": "When a critical input exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.019": "When a data storage exception occurs the platform continues execution. (Note:\n              see source code comments for detailed analysis; the reason for this is that a data storage\n              exception is only likely to be caused by accessing flash during a write operation,\n              and that is also caught by an ECC exception, and handled there instead.)",
    "LLR.PLAT.PKN.EXCEP.003": "When an instruction storage exception occurs then the platform  shall  set the reset\n              marker to PSC_RESET_ACCESS_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.004": "When an external interrupt exception occurs then the platform  shall  set the reset\n              marker to PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.005": "When an alignment exception occurs then the platform  shall  set the reset marker to\n              PSC_RESET_ACCESS_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.006": "When a program exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.007": "When a FP unavailable exception occurs then the platform  shall  set the reset marker to\n              PSC_RESET_FP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.008": "When a system call exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.009": "When an APU unavailable interrupt exception occurs then the platform  shall  set the\n              reset marker to PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.010": "When a fixed interval exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.011": "When a watchdog exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.012": "When a data TLB exception occurs then the platform  shall  set the reset marker to\n              PSC_RESET_ACCESS_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.013": "When an instruction TLB exception occurs then the platform  shall  set the reset\n              marker to PSC_RESET_ACCESS_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.014": "When a debug exception occurs then the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.015": "When a SPE unavailable exception occurs then the platform  shall  set the reset marker\n              to PSC_RESET_FP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.016": "When a SPE data exception occurs then the platform  shall  set the reset marker to\n              PSC_RESET_FP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.017": "When a SPE round exception occurs then the platform  shall  set the reset marker to\n              PSC_RESET_FP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.018": "When a decrementer exception occurs then the scheduler tick has occurred and platform\n               shall  manage task scheduling as required by\n              [LLR.PLAT.PKN.TASKREADY].",
    "LLR.PLAT.PKN.EXCEP.020": "When a machine check exception occurs because of an ECC failure in SRAM and the\n              platform is checksumming data during initialisation then the platform  shall  continue\n              from where the exception occurred.",
    "LLR.PLAT.PKN.EXCEP.021": "When a machine check exception occurs because of an ECC failure in Flash and the\n              platform is checksumming data during initialisation then the platform  shall  continue\n              from where the exception occurred.",
    "LLR.PLAT.PKN.EXCEP.024": "When a machine check exception occurs because of an ECC failure in Flash and the\n              platform is checksumming non-volatile data owned by the PFS feature,\n              the platform  shall  continue from where the exception occurred. (This is normal\n              if incomplete programming has occurred due to unexpected power off. See PFS\n              requirements for the action taken if data fails checksum validation.)",
    "LLR.PLAT.PKN.EXCEP.025": "When a machine check exception occurs because of an ECC failure in Flash and the\n              platform is performing a background write operation of flash,\n              the platform  shall  continue from where the exception occurred. (This is in\n              case a periodic read through NULL is present in the customer application,\n              a latent bug which would otherwise only emerge as a serious problem when\n              PFS happens to erase flash.)",
    "LLR.PLAT.PKN.EXCEP.026": "When a machine check exception occurs because of an ECC failure in Flash and the\n              platform is reading flash data in order to program adjacent data,\n              the platform  shall  continue from where the exception occurred. (This can\n              be normal if a previous block of bytes were misprogrammed due to power\n              interruption.)",
    "LLR.PLAT.PKN.EXCEP.022": "When a machine check exception occurs because of an ECC failure in SRAM or Flash and\n              the ECC exception is not tolerated according to the above requirements, the platform  shall \n              set the reset marker to PSC_ECC_EXCEP_PATTERN, raise an\n              unrecoverable error (PSY_PKN,\n              PKN_ERR_UNEXPECTED_EXCEPTION), thus resetting the ECU.",
    "LLR.PLAT.PKN.EXCEP.023": "When a machine check exception occurs because of another reason then the platform\n               shall  set the reset marker to PSC_BAD_EXCEP_PATTERN, raise an\n              unrecoverable error (PSY_PKN,\n              PKN_ERR_UNEXPECTED_EXCEPTION), thus resetting the ECU.",
    "LLR.PLAT.PKN.INT.001": "When a MPC5xxx FlexCAN interrupt required by the software occurs the platform  shall \n              allow the PCAN feature to process the interrupt.",
    "LLR.PLAT.PKN.INT.002": "When a MPC5xxx DSPI interrupt required by the software occurs the platform  shall  allow\n              the PSPI feature to process the interrupt.",
    "LLR.PLAT.PKN.INT.003": "When a MPC5xxx eTPU interrupt required by the software occurs the platform  shall  allow\n              the PTPU feature to process the interrupt.",
    "LLR.PLAT.PKN.INT.004": "When any other interrupt occurs the platform  shall  set the reset marker to\n              PSC_BAD_EXCEP_PATTERN, raise an unrecoverable error\n              (PSY_PKN, PKN_ERR_UNEXPECTED_EXCEPTION), thus\n              resetting the ECU.",
    "LLR.PLAT.PKN.RESACQ.001": "The platform shall provide a C interface function named\n                pkn_acquire_resource() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_r_hd\n          in\n        const PKN_RESOURCE_HANDLE_T\nA pointer to a resource. The resource itself specifies which tasks can acquire this resource, the ceiling of those tasks and a pointer to a buffer to store context. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PKN.RESACQ.101": "The function pkn_acquire_resource() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.RESACQ.201": "The function pkn_acquire_resource() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.RESACQ.002": "If the pknf_r_hd parameter does not point to a valid resource handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_RESOURCE_HANDLE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the pointer is outside its\n                valid bounds and the application has some form of defect. An unrecoverable error early\n                in the development process will help debug the issue.  An unrecoverable error in the\n                field will prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.RESACQ.004": "If the resource identified by the pknf_r_hd parameter has not been\n                declared as a resource the calling task can acquire in the C-API interface specification\n                file then the function  shall  raise an unrecoverable error (PSY_PKN,\n                PKN_ERR_TASK_NOT_DECLARED_AS_ACQUIRING_RESOURCE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the resource has not been\n                declared by the calling task as one it acquires, thus if the calling task becomes\n                pre-empted while it is accessing the resource, and the pre-empting task also accesses\n                the resource, the resulting behaviour may be undefined.  An unrecoverable error early in\n                the development process will help debug the issue.  An unrecoverable error in the field\n                will prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.RESACQ.003": "The function  shall  ensure that only the calling task can access the resource identified\n                by pknf_r_hd by employing the IPCP.\n              Rationale: \n                The Immediate Priority Ceiling Protocol (IPCP) ensures that only one task can access a\n                shared resource at a time, by temporarily raising the priority of that task to the\n                highest priority of any task that could attempt to access the same resource. The IPCP\n                prevents deadlocks and priority inversion if certain rules about acquiring and release\n                resources are followed, making it ideal for the type of real-time systems the platform\n                will be presented with. See\n                \n                  OpenECU Software High-Level Design, \u201cScheduler (kernel) feature (prefix pkn)\u201d\n                \n                for further details.",
    "LLR.APP.PKN.RESREL.001": "During runtime, the application  will  release resources in the reverse order from which\n              it acquired them, as required by the IPCP.\n            Rationale: \n              Following this procedure will ensure the task schedule is deadlock and priority\n              inversion free.",
    "LLR.PLAT.PKN.RESREL.001": "When a task completes, the platform  shall  ensure that any unreleased resources are\n              released without violating the release requirements of the IPCP.\n            Rationale: \n              Although each application task is required to release any resources it acquired prior to\n              the task's termination, as a precaution, the platform will ensure all resources are\n              released when the platform terminates the task. This allows other tasks to acquire the\n              same resources in the event that the application fails to follow the requirements.\n            Note: \n              A future enhancement would require the platform to record a recoverable error when an\n              unreleased resource is found on task termination.",
    "LLR.PLAT.PKN.RESREL.002": "The platform shall provide a C interface function named\n                pkn_release_resource() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_r_hd\n          in\n        const PKN_RESOURCE_HANDLE_T\nA pointer to a resource. The resource itself specifies which tasks can acquire this resource, the ceiling of those tasks and a pointer to a buffer to store context. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PKN.RESREL.102": "The function pkn_release_resource() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.RESREL.202": "The function pkn_release_resource() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.RESREL.003": "If the pknf_r_hd parameter does not point to a valid resource handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_RESOURCE_HANDLE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the pointer is outside its\n                valid bounds and the application has some form of defect. An unrecoverable error early\n                in the development process will help debug the issue.  An unrecoverable error in the\n                field will prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.RESREL.005": "If the resource identified by the pknf_r_hd parameter has not been\n                declared as a resource the calling task can acquire (and therefore release) in the C-API\n                interface specification file then the function  shall  raise an unrecoverable error\n                (PSY_PKN,\n                PKN_ERR_TASK_NOT_DECLARED_AS_ACQUIRING_RESOURCE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the resource has not been\n                declared by the calling task as one it acquires (and therefore can release), thus there\n                is the opportunity to break the IPCP algorithm.  An unrecoverable error early in the\n                development process will help debug the issue.  An unrecoverable error in the field will\n                prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.RESREL.004": "The function  shall  ensure that other tasks which can access the resource identified by\n                pknf_r_hd can acquire the resource by following\n                [LLR.PLAT.PKN.RESACQ].\n              Note: \n                A future enhancement would require the platform to check that a task releases resources\n                in the reverse order from which it acquired them, raising an unrecoverable error if the\n                condition is found. This would help ensure the IPCP is being followed.",
    "LLR.PLAT.PKN.TASKREADY.012": "The platform  shall  configure the decrementer exception to occur every millisecond.\n            Rationale: \n              This provides an accurate tick for the scheduler (the alternative, the fixed interval\n              timer cannot match 1 millisecond exactly).\n            Note: \n              This is a very low-level requirement, almost implementation like, but the low-level\n              requirements need to be specific about exception and interrupt handling so that tests\n              can be written.",
    "LLR.PLAT.PKN.TASKREADY.001": "The platform  shall  set the task's periodic timer to the task's offset time, or make the\n              task ready to run if task's offset time is zero.\n            Rationale: \n              This provides the ability to stagger the starting time of each task, which can lead\n              to a more balanced task schedule (if required).",
    "LLR.PLAT.PKN.TASKREADY.002": "The platform  shall  start the background idle task (or more accurately, the background\n              idle loop).\n            Note: \n              The background idle loop may immediately be pre-empted by\n              [LLR.PLAT.PKN.TASKREADY]\n              during runtime.",
    "LLR.PLAT.PKN.TASKREADY.003": "Every millisecond, the platform  shall  decrement the task's periodic timer, saturating at\n              zero.",
    "LLR.PLAT.PKN.TASKREADY.004": "Every millisecond, if a task's periodic timer reaches zero (either by initialisation or\n              by a decrement), the platform  shall  make the task ready to run.",
    "LLR.PLAT.PKN.TASKREADY.013": "If a task's periodic timer reaches zero (and therefore becomes made ready to run via [LLR.PLAT.PKN.TASKREADY.004])\n              and the same task is currently running, then the platform  shall  increment the over-run count for the task,\n              saturating the counter at 255.",
    "LLR.PLAT.PKN.TASKREADY.017": "The platform  shall  clear the over-run count for all periodic tasks to zero during application initialisation.",
    "LLR.PLAT.PKN.TASKREADY.005": "Every millisecond, if a task's periodic timer reaches zero and if the task requires its\n              timer to be automatically restarted, the platform  shall  set the task's periodic timer to\n              the period of the task\n            Rationale: \n              This allows tasks to be periodic for bursts, reverting to being event driven thereafter\n              (for example, when scheduling a task to empty a queue periodically, until the queue\n              becomes empty, at which point the task stops until it is required again, reducing CPU\n              load).",
    "LLR.PLAT.PKN.TASKREADY.006": "When the highest priority of all tasks ready to run, exceeds the priority of the\n              currently running task (or the background idle loop which has the lowest priority of all\n              tasks) then the platform  shall  pre-empt the current task, and start the highest priority\n              task ready to run.\n            Rationale: \n              This ensures tasks are scheduled pre-emptively, based on their relative priority, where\n              the highest priority task is running.",
    "LLR.PLAT.PKN.TASKREADY.007": "When a task completes, the platform  shall  terminate the task and make the task not ready\n              to run.\n            Rationale: \n              It is possible for the task to run for a duration that exceeds its period. If the task\n              were immediately made ready to run again (see\n              [LLR.PLAT.PKN.TASKREADY.004])\n              then lower priority tasks ready to run would continue to wait. If the task continually\n              exceeded its period, no lower priority task would run. To provide a more rounded\n              response as a result of a task taking too long to run, the platform will not\n              immediately run the same task that has just terminated, allowing lower priority tasks\n              to run. Although neither situation is ideal, allowing lower priority tasks to run\n              ensures a higher priority task cannot starve tasks of CPU time.",
    "LLR.APP.PKN.TASKREADY.001": "The application  will  consider the scheduling behaviour of\n              [[LLR.PLAT.PKN.TASKREADY.006]]\n              as part of the application design.",
    "LLR.PLAT.PKN.TASKREADY.008": "When a task completes, the platform  shall  do one of the following in order:\n            \n                  start the next highest priority task which is ready to run but has not started\n                  (because other tasks or interrupts could have made a task ready to run);\n                \n                  or resume the next highest priority pre-empted task (which continues the schedule\n                  from where it was pre-empted last);\n                \n                  or resume the background idle loop when no other pre-empted task exists.",
    "LLR.PLAT.PKN.TASKREADY.009": "The platform shall provide a C interface function named\n                pkn_ready_task() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_t_hd\n          in\n        const PKN_TASK_HANDLE_T\nA pointer to a task structure. The task specifies the priority it should run at as well as the function to call when the task runs. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PKN.TASKREADY.109": "The function pkn_ready_task() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.TASKREADY.209": "The function pkn_ready_task() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.TASKREADY.010": "If the pknf_t_hd parameter does not point to a valid task handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_TASK_HANDLE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the pointer is outside its\n                valid bounds and the application has some form of defect. An unrecoverable error early\n                in the development process will help debug the issue.  An unrecoverable error in the\n                field will prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.TASKREADY.011": "The function  shall  make ready the task identified by the pknf_t_hd\n                parameter (even if the task's periodic timer is not already zero).",
    "LLR.PLAT.PKN.TASKREADYINT.001": "On exiting the interrupt handler the platform  shall  continue task scheduling as required\n              by [LLR.PLAT.PKN.TASKREADY.008].\n            Rationale: \n              The interrupt may have made a task with priority higher than the pre-empted task and\n              following [LLR.PLAT.PKN.TASKREADY.008],\n              ensures the highest priority task is running.",
    "LLR.PLAT.PKN.TASKREADYINT.002": "The platform shall provide a C interface function named\n                pkn_ready_task_from_int() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_t_hd\n          in\n        const PKN_TASK_HANDLE_T\nA pointer to a task structure. The task specifies the priority it should run at as well as the function to call when the task runs. \n Cannot be NULL. \n                The function returns void.",
    "LLR.PLAT.PKN.TASKREADYINT.003": "If the pknf_r_hd parameter does not point to a valid task handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_TASK_HANDLE).\n              Rationale: \n                An unrecoverable error is suitable in this situation because the pointer is outside its\n                valid bounds and the application has some form of defect. An unrecoverable error early\n                in the development process will help debug the issue.  An unrecoverable error in the\n                field will prevent erroneous memory accesses from resulting in undefined behaviour.",
    "LLR.PLAT.PKN.TASKREADYINT.004": "The function  shall  make ready the task identified by the pknf_t_hd\n                parameter (even if the task's periodic timer is not already zero).",
    "LLR.PLAT.PKN.TASKDURATION.004": "During runtime, the platform  shall  measure the time taken for a task to complete from\n              when the task becomes the highest-priority task running after it is made ready,\n              excluding time taken by other higher priority tasks (but not interrupts) that preempt\n              the measured task.\n            Rationale: \n              The measured time excludes pre-emption by other tasks, giving a realistic measurement of\n              the task's actual duration.\n            \n              It turns out there is no simple way to exclude time given to pre-empting interrupts at\n              the implementation level, but the overall interrupt load is small and the pre-emption\n              time low, giving a reasonable measure of task duration. And measuring interrupt time as\n              part of the task duration means the application can add up each task duration and get an\n              accurate total of time spent outside the background idle task (which could act as an\n              independent measure of CPU loading if required).",
    "LLR.PLAT.PKN.TASKDURATION.001": "The platform shall provide a C interface function named\n                pkn_get_task_duration() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_t_hd\n          in\n        const PKN_TASK_HANDLE_T\nA pointer to a task structure. The task specifies the priority it should run at as well as the function to call when the task runs. \n Cannot be NULL.\n                The function returns a value of type\n                U32\n                with a value of:\n              The last measured duration of a task in microseconds Range: [0, 4294967295] microseconds.",
    "LLR.PLAT.PKN.TASKDURATION.101": "The function pkn_get_task_duration() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.TASKDURATION.201": "The function pkn_get_task_duration() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.TASKDURATION.005": "If the pknf_t_hd parameter does not point to a valid task handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_TASK_HANDLE).",
    "LLR.PLAT.PKN.TASKDURATION.002": "The function  shall  return the last measured duration for the task identified by\n                pknf_t_hd with a resolution of 1 microsecond per LSB, or zero if the\n                task duration has not yet been measured.",
    "LLR.PLAT.PKN.TASKDURATION.003": "When an application is built, the build tools  shall  add an ASAP2 displayable for each\n              application task declared in the C-API interface specification, named\n              mpl_tt_<name> that corresponds to the task's duration measured\n              by [LLR.PLAT.PKN.TASKDURATION.004],\n              where <name> corresponds to\n              the task's name given in the C-API interface specification.",
    "LLR.PLAT.PKN.TASKMAXDUR.001": "During runtime, the platform  shall  record the maximum task duration measurement by\n              [LLR.PLAT.PKN.TASKDURATION.004]\n              since reset.\n            Rationale: \n              The application may not sample the task duration information quickly enough to record\n              the last measurement for all tasks. Providing the maximum measured task duration allows\n              the application to sample more slowly and still determine whether its work is being\n              completed in a timely fashion.",
    "LLR.PLAT.PKN.TASKMAXDUR.002": "The platform shall provide a C interface function named\n                pkn_get_max_task_duration() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_t_hd\n          in\n        const PKN_TASK_HANDLE_T\nA pointer to a task structure. The task specifies the priority it should run at as well as the function to call when the task runs. \n Cannot be NULL.\n                The function returns a value of type\n                U32\n                with a value of:\n              The maximum measured duration of a task in microseconds Range: [0, 4294967295] microseconds.",
    "LLR.PLAT.PKN.TASKMAXDUR.102": "The function pkn_get_max_task_duration() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.TASKMAXDUR.202": "The function pkn_get_max_task_duration() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.TASKMAXDUR.003": "If the pknf_t_hd parameter does not point to a valid task handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_TASK_HANDLE).",
    "LLR.PLAT.PKN.TASKMAXDUR.004": "The function  shall  return the recorded maximum task duration measurement for the task\n                identified by pknf_t_hd with a resolution of 1 microsecond per LSB,\n                or zero if the task duration has not yet been measured.",
    "LLR.PLAT.PKN.TASKMAXDUR.005": "When an application is built, the build tools  shall  add an ASAP2 displayable for each\n              application task declared in the C-API interface specification, named\n              mpl_mtt_<name> that corresponds to the task's maximum duration\n              recorded by [LLR.PLAT.PKN.TASKMAXDUR.001],\n              where <name> corresponds to the task's name given in the C-API\n              interface specification.",
    "LLR.PLAT.PKN.TASKOVRRUN.001": "The platform shall provide a C interface function named\n                pkn_get_task_overrun_count() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpknf_pt_hd\n          in\n        const PKN_PERIODIC_TASK_HANDLE_T\nA pointer to a task structure. The task specifies the priority it should run at as well as the function to call when the task runs. \n Cannot be NULL.\n                The function returns a value of type\n                U8\n                with a value of:\n              The number of times the task has overrun.\n Range: [0, 65535] count.",
    "LLR.PLAT.PKN.TASKOVRRUN.002": "The function pkn_get_task_overrun_count() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PKN.TASKOVRRUN.003": "The function pkn_get_task_overrun_count() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PKN.TASKOVRRUN.004": "If the pknf_pt_hd parameter does not point to a valid task handle\n                structure then the function  shall  raise an unrecoverable error\n                (PSY_PKN, PKN_ERR_INVALID_PERIODIC_TASK_HANDLE).",
    "LLR.PLAT.PKN.TASKOVRRUN.005": "The function  shall  return the number of times the task has overrun its period.",
    "LLR.PLAT.PKN.TASKOVRRUN.006": "The platform shall provide a Simulink interface block named\n                pkn_TaskPeriodOverrun that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_overrunsInport-\n        \n          Only used under simulation and when the parameter\n          Provide simulation inputs is ticked. The outport\n          overruns is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255] counts\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            overrunsOutportinteger\n        \n          The saturated counts of periodic overruns for the model rate task since the ECU was\n          powered on (or reset).  Under simulation, if the\n          Provide simulation inputs parameter isn't ticked, the outport is set\n          to the minimum of its range.\n        \n        \n          Range: [0, 255] counts\n        \n      Sample time (task)Paramfloat\n        \n          The periodicity of the model rate to measure.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Sample time (block)Paramfloat\n        \n          The periodicity of the block. The task and block sample time allow the model rate task\n          measurement to occur independently from the task itself.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Provide simulation inputsParamboolean\n        \n          Tick to enable inport sim_overruns.\n        \n      \n                Calibratable: incorrectly specified in user guide XML.",
    "LLR.PLAT.PKN.TASKOVRRUN.007": "The block pkn_TaskPeriodOverrun shall support the targets:\n            All targets.",
    "LLR.PLAT.PKN.TASKOVRRUN.008": "The block pkn_TaskPeriodOverrun shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PKN.TASKOVRRUN.009": "If the parameter Sample time (task) is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PKN.TASKOVRRUN.010": "If the parameter Sample time (block) is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PKN.TASKOVRRUN.011": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time (block).",
    "LLR.PLAT.PKN.TASKOVRRUN.012": "The value of inport, sim_overruns\n                is written to the outport, overruns.",
    "LLR.PLAT.PKN.TASKOVRRUN.013": "The block  shall  report the number of overruns for the specified task.",
    "LLR.PLAT.PMEM.CONFIG.001": "Where memory configuration is supported, the platform  shall  configure\n              the memory according to the memory configuration selected in the application.",
    "LLR.PLAT.PMEM.CONFIG.002": "If the selected memory configuration requires the use of external RAM\n              as an extension of internal RAM, then the platform  shall  test for\n              the presence of external RAM and reset the ECU if it is not present.\n            Note: \n              The above behaviour will lead to repeated resets which will cause the\n              ECU to enter and remain in reprogramming mode.",
    "LLR.PLAT.PMEM.CONFIG.011": "The platform  shall  remap the calibrations to external RAM\n              if and only if external RAM is detected.\n            Note: \n              This allows the same software to run on developer ECUs (where\n              external RAM is present) and fleet ECUs (where it is typically not).",
    "LLR.PLAT.PMEM.CONFIG.003": "All memory configurations supported by the platform  shall  allow the calibration\n              and strategy to be downloaded independently.\n            Note: \n              This is an important consideration which restricts what configurations are possible.",
    "LLR.PLAT.PMEM.CONFIG.004": "The capi file  shall  be used to specify the memory configuration:\n            \nmemory-config\n{\nconfig-id = identifier\n}",
    "LLR.PLAT.PMEM.CONFIG.005": "The interface  shall  use the config-id identifier to specify the memory\n              configuration to be used.",
    "LLR.PLAT.PMEM.CONFIG.006": "If no memory-config compound is present then the platform  shall  use\n              the default memory configuration.",
    "LLR.PLAT.PMEM.CONFIG.007": "The platform shall provide a Simulink interface block named\n                pmem_MemoryConfiguration that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionMemory configurationParamList\n        \n          A list of the memory configurations available for this target.\n          See Memory configurations for details of the memory\n          configurations available for different targets.\n      \n      \n                Calibratable: no.",
    "LLR.PLAT.PMEM.CONFIG.107": "The block pmem_MemoryConfiguration shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PMEM.CONFIG.207": "The block pmem_MemoryConfiguration shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PMEM.CONFIG.008": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PMEM.CONFIG.009": "The block  shall  use the mask parameter\n                Memory configuration\n                to specify the memory configuration to be used.",
    "LLR.PLAT.PMEM.CONFIG.010": "If the pmem_MemoryConfiguration Simulink block is not present in the\n                application model then the platform  shall  use the default memory\n                configuration.",
    "LLR.PLAT.ADAPTOOL.001": "The parameters which represent the default values for adaptive parameters\n               shall  be placed in the .cal_adap linker section.",
    "LLR.PLAT.ADAPTOOL.002": "The .cal_adap linker section  shall  be stored in the binary image\n              in the .cal_flash memory region.",
    "LLR.PLAT.ADAPNVM.007": "The platform software  shall  define the OE_ADAP macro so that\n              no in-line modifiers are applied to the variable declarations for Diab builds.",
    "LLR.PLAT.ADAPNVM.008": "The platform software  shall  define the OE_ADAP macro to set\n              the __attribute__ section override to .cal_adap\n              for GCC builds.",
    "LLR.PLAT.ADPTOOL.003": "The target link compiler scripts for pnv blocks  shall  add the names of the adaptive parameters\n              to the adaptive-list element of the adaptives section\n              of the auto-generated .capi interface file. (This supports Diab builds.)",
    "LLR.PLAT.ADPTOOL.004": "The CAPI tool  shall  emit #pragma section overrides for the parameter names\n              in the adaptive-list element of the adaptives section\n              of the interface file for Diab builds.",
    "LLR.PLAT.ADPTOOL.005": "The target link compiler scripts for pnv blocks  shall  add the names of the adaptive parameters\n              to an auto-generated adaptive parameters list file.  (This supports GCC builds.)",
    "LLR.PLAT.ADPTOOL.006": "The Simulink make scripts for GCC builds  shall  run the gen_pnv_overrides\n              script to modify the parameter declarations in the generated source code using the\n              auto-generated adaptive parameters list file.",
    "LLR.PNVTOOL.IO.001": "The gen_pnv_overrides tool  shall  require a command-line argument containing the name\n              of the source code file to modify.",
    "LLR.PNVTOOL.IO.002": "The gen_pnv_overrides tool  shall  accept an optional command-line argument specifying the\n              name of a file containing the list of names of pnv parameters.",
    "LLR.PNVTOOL.IO.003": "The gen_pnv_overrides tool  shall  exit with a code of 0 on success.",
    "LLR.PNVTOOL.IO.004": "The gen_pnv_overrides tool  shall  exit with a nonzero code if an error was encountered\n              during execution.",
    "LLR.PNVTOOL.IO.005": "The gen_pnv_overrides tool  shall  use standard output or standard error streams\n              for providing runtime information.",
    "LLR.PNVTOOL.FUNC.001": "If the optional command line argument specifying the name of the pnv parameter list file\n              is not present, the gen_pnv_overrides tool  shall  use a filename of\n              pnv_list.txt",
    "LLR.PNVTOOL.FUNC.002": "If either the source code file or pnv parameter list file cannot be opened, the gen_pnv_overrides\n              tool  shall  exit with an error condition.",
    "LLR.PNVTOOL.FUNC.003": "The gen_pnv_overrides tool  shall  replace OE_CAL with OE_ADAP\n              on all variable declarations in the specified C source file for variables which are named in the \n              pnv parameter list file.",
    "LLR.PLAT.ADAPNVM.005": "The platform startup code  shall  reserve a section of RAM sufficient\n              to store live copies of all adaptive parameters.",
    "LLR.PLAT.ADAPNVM.006": "If the platform retrieves the adaptive data from non-volatile memory at start-up, the\n              platform  shall  set the live copy of each adaptive element to the value read from non-volatile\n              memory.",
    "LLR.PLAT.ADAPNVM.001": "If the platform fails to retrieve the adaptive data from non-volatile memory at start-up, \n              the platform  shall  set the live copy of each adaptive element to its default value from\n              calibration memory.",
    "LLR.PLAT.ADAPNVM.002": "The platform  shall  provide a mechanism to track when the adaptive data\n              in RAM has been modified.",
    "LLR.PLAT.ADAPNVM.003": "The platform  shall  provide a mechanism to track when the adaptive data\n              in Flash has been modified.",
    "LLR.PLAT.ADAPNVM.004": "The following non-volatile features  shall  be supported by the platform:\n              Non-volatile arrayAdaptive scalarAdaptive 1-d look-up mapAdaptive 2-d look-up map",
    "LLR.PLAT.PNV.ARRAY.011": "The platform  shall  provide a mechanism to reset the non-volatile array.",
    "LLR.PLAT.PNV.ARRAY.012": "The platform  shall  provide a mechanism to modify the non-volatile array.",
    "LLR.PLAT.PNV.ARRAY.013": "The platform  shall  perform the reset action if both the reset and modify actions\n              are specified (reset overrides modify).",
    "LLR.PLAT.PNV.ARRAY.001": "The platform shall provide a C interface function named\n                pnv_array() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpnvf_index\n          in\n        U32\nThe index to the array element to access. Range: [0, { pnvf_n - 1 }]pnvf_new_value\n          in\n        volatile const void *\nA pointer to the new value to write to the array index. Written only if pnvf_change is true and pnvf_reset is false. As the parameter is a void pointer, the size in bytes of the new value to write is given by pnvf_elem_size. \n Cannot be NULL.pnvf_change\n          in\n        BOOL\nSet true to change the adaptive based on the new value (pnvf_new_value), set false for no change. If both pnvf_change and pnvf_reset are set true, then no change occurs.pnvf_reset\n          in\n        BOOL\nSet true to reset the adaptive to its default (pnvf_array_default), set false for no reset. If both pnvf_change and pnvf_reset are set true, then no change occurs.pnvf_elem_size\n          in\n        U32\nThe size of each array element in bytes. Must be greater than zero.pnvf_n\n          in\n        S32\nThe number of elements in the adaptive array. Must be greater than zero.pnvf_array_default\n          in\n        volatile const void *\nPointer to array's default contents. The contents are used to overwrite the adaptive array's contents if the pnvf_reset parameter is true. \n The array which this pointer represents must be declared with the OE_ADAP macro. \n Cannot be NULL.pnvf_valid_index\n          out\n        BOOL *\nPointer to boolean to be written with the result of whether the array index (pnvf_index) is valid or not. \n Cannot be NULL.pnvf_value\n          out\n        void *\nPointer to memory to be written with the array element referenced by pnvf_index. If the array index (pnvf_index) is invalid, then the first element of the array is written to the memory pointed to by pnvf_value. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PNV.ARRAY.101": "The function pnv_array() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ARRAY.201": "The function pnv_array() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ARRAY.002": "The function  shall  reject calls with a NULL pointer in\n                any of the following parameters pnvf_new_value,\n                pnvf_array, pnvf_array_default,\n                pnvf_valid_index or pnvf_value by\n                raising a recoverable error PSY_PNV\/PNV_ARRAY_INVALID_ARG.",
    "LLR.PLAT.PNV.ARRAY.003": "The function  shall  reject calls with a value smaller than\n                1 for either of the parameters pnvf_n\n                or pnvf_elem_size by raising a recoverable error\n                PSY_PNV\/PNV_ARRAY_INVALID_ARG.",
    "LLR.PLAT.PNV.ARRAY.004": "The platform  shall  use the parameter pnvf_elem_size\n                to determine the  size of the non-volatile data in bytes.",
    "LLR.PLAT.PNV.ARRAY.005": "The platform  shall  set pnvf_valid_index to true when\n                pnvf_index is within the valid index range and\n                false otherwise.",
    "LLR.PLAT.PNV.ARRAY.006": "The platform  shall  ignore calls to change the non-volatile data when\n                pnvf_index is not within the valid index range.",
    "LLR.PLAT.PNV.ARRAY.007": "If pnvf_reset is true, the platform  shall  copy the default\n                values from pnvf_array_default into pnvf_array.",
    "LLR.PLAT.PNV.ARRAY.008": "If pnvf_change is true, the platform  shall  copy data from\n                pnvf_new_value into pnvf_array at the\n                valid index pnvf_index.",
    "LLR.PLAT.PNV.ARRAY.009": "When pnvf_index is within the valid index range, the platform\n                 shall  copy the latest data from pnvf_array at index\n                pnvf_index into pnvf_value.",
    "LLR.PLAT.PNV.ARRAY.010": "When pnvf_index is not within the valid index range, the\n                platform  shall  copy the first data value from pnvf_array\n                into pnvf_value.",
    "LLR.PLAT.PNV.ARRAY.030": "The platform shall provide a C interface function named\n                pnv_array_dump() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpnvf_elem_size\n          in\n        U32\nThe size of each array element in bytes.pnvf_num_elems\n          in\n        S32\nThe number of elements in the adaptive array.pnvf_array_default\n          in\n        volatile const void *\nPointer to array's default contents. This is just used to identify the true adaptive array. \n Cannot be NULL.pnvf_output\n          out\n        void *\nPointer to memory to be written with the entire contents of the adaptive array.\n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PNV.ARRAY.130": "The function pnv_array_dump() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ARRAY.230": "The function pnv_array_dump() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ARRAY.031": "The function  shall  raise a recoverable error\n                PSY_PNV\/PNV_ARRAY_DUMP_INVALID_ARG\n                if the argument passed to parameter pnvf_output\n                is NULL.",
    "LLR.PLAT.PNV.ARRAY.035": "The function  shall  raise a recoverable error\n                PSY_PNV\/PNV_ARRAY_DUMP_INVALID_ARG\n                if the start of the default array does not lie within\n                the adaptive data area of read-only memory.",
    "LLR.PLAT.PNV.ARRAY.036": "The function  shall  raise a recoverable error\n                PSY_PNV\/PNV_ARRAY_DUMP_INVALID_ARG\n                if the end of the default array does not lie within\n                the adaptive data area of read-only memory.",
    "LLR.PLAT.PNV.ARRAY.037": "The function  shall  not attempt to copy any data to\n                the pnvf_output output if any of\n                the above conditions resulting in a recoverable error\n                being raised are met.",
    "LLR.PLAT.PNV.ARRAY.034": "The platform  shall  copy a number of bytes equal to the\n                total size of the array from the start of the adaptive\n                array to the area of memory starting at the address\n                passed to the parameter pnvf_output.",
    "LLR.PLAT.PNV.ARRAY.014": "The platform shall provide a Simulink interface block named\n                pnv_Array that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionnInportInteger\n        \n          The nth\n          element in the array to modify.\n        \n        \n          Range: [0, number of elements in array - 1]\n        \n      uInportReal\n        \n          The value to write to the\n          nth element of the array. The type of this inport\n          is the same as the type of the parameter Array Data (default).\n        \n      changeInportBoolean\n        \n          1 if the nth\n          element of the array should be change to inport u, 0 otherwise.\n          If the inport reset is 1, no change will occur (even if inport\n          change is 1).\n        \n        \n          Range: 0 or 1\n        \n      resetInportBoolean\n        \n          1 to change the array\n          to the values of the Array Data (default) parameter, 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      valid_nOutportBoolean\n        \n          1 if inport n refers\n          to an element in the array, 0 if inport n is larger than the number\n          of array elements.\n        \n      u'OutportReal\n        \n          The value of the nth\n          element of the array, possibly after the array has been changed. The type\n          of this outport is the same as the type of the parameter Array Data (default).\n        \n      whole_arrayOutportDynamically Typed\n        \n          The current values of all elements of the array, possibly after the array has been changed,\n          output as a vector. The type of this outport is the same as the type of the parameter\n          Array Data (default). This outport is only present when the\n          Output entire array contents? mask parameter checkbox is ticked.\n        \n      Array Data (default)ParamReal\n        \n          The name of the\n          DDE for the array (e.g. vftv_array, see\n          Section \"Naming rules\").\n          An array can contain one or more elements. The type of the array dictates the type of inport u\n          and outport u'.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Output entire array contents?ParamBoolean\n        \n          Tick this checkbox to create an outport from the block to output the entire array contents.\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.ARRAY.114": "The block pnv_Array shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.ARRAY.214": "The block pnv_Array shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.ARRAY.015": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.016": "If the parameter Array Data (default) is not a 1d vector of finite\n                reals then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.017": "If the parameter Array Data (default) is not a single or double type\n                then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.018": "If the parameter Array Data (default) contents is not a valid name or\n                array the block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.019": "If the parameter Array Data (default) data length is zero then the\n                block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.020": "If the model does not contain a pnv_AdaptiveChecksum block  then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ARRAY.021": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.ARRAY.022": "During simulation the platform software is used resulting in the same behaviour as seen on the target.",
    "LLR.PLAT.PNV.ARRAY.023": "If reset is 1, the block revert to the default values from\n                Array Data (default).",
    "LLR.PLAT.PNV.ARRAY.024": "If change is 1, the block  shall  copy data from\n                u into the array at index n as long\n                as n is in range.",
    "LLR.PLAT.PNV.ARRAY.025": "If the array index, n is out of range then the outport,\n                valid_n  shall  be set to 0 and the value of outport\n                u'  shall  be set to the first array element.",
    "LLR.PLAT.PNV.ARRAY.026": "If the array index, n is in range then the outport,\n                valid_n  shall  be set to 1 and\n                u'  shall  be set to the element corresponding to index\n                n.",
    "LLR.PLAT.PNV.ARRAY.027": "The platform  shall  make the the outport whole_array\n                available if and only if the checkbox\n                Output entire array contents? is ticked.",
    "LLR.PLAT.PNV.ARRAY.028": "If the checkbox Output entire array contents? is ticked,\n                then the entire contents of the array  shall  be output as a vector to the outport\n                whole_array every time the block executes.",
    "LLR.PLAT.PNV.ADPSCALAR.001": "The platform  shall  provide a mechanism to reset the non-volatile scalar.",
    "LLR.PLAT.PNV.ADPSCALAR.002": "The platform  shall  provide a mechanism to adapt the non-volatile scalar\n              based on an adaption increment.",
    "LLR.PLAT.PNV.ADPSCALAR.003": "The platform  shall  perform the reset action if both the reset and adapt actions\n              are specified.",
    "LLR.PLAT.PNV.ADPSCALAR.004": "The platform shall provide a C interface function named\n                pnv_adap_scalar_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpnvf_adapt_increment\n          in\n        F32\nThe adaption increment to be applied to the scalar value.pnvf_adapt\n          in\n        BOOL\nSet true to adapt the adaptive scalar based on the adaption increase (pnvf_adapt_increment), set false for no adaption. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_reset\n          in\n        BOOL\nSet true to reset the adaptive scalar to its default (pnvf_adapt_default), set false for no reset. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_adapt_default\n          in\n        volatile const F32 *\nPointer to scalar's default value. The default value is used to overwrite the adaptive scalar's value if the pnvf_reset parameter is true. \n The calibration which this pointer represents must be declared with the OE_ADAP macro. \n Cannot be NULL.pnvf_adapted\n          out\n        F32 *\nPointer to adapted output. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PNV.ADPSCALAR.104": "The function pnv_adap_scalar_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ADPSCALAR.204": "The function pnv_adap_scalar_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ADPSCALAR.005": "The platform  shall  reject calls with a NULL pointer in\n                any of the following parameters pnvf_adapt_value,\n                pnvf_adapt_default or pnvf_adapted by\n                raising a recoverable error PSY_PNV\/PNV_ADAPSCALAR_INVALID_ARG.",
    "LLR.PLAT.PNV.ADPSCALAR.006": "When pnvf_reset is true, the platform  shall  reset the adaptive\n                scalar to the default value pnvf_adapt_default.",
    "LLR.PLAT.PNV.ADPSCALAR.007": "When pnvf_adapt is true, the platform  shall  increment the adaptive\n                scalar by the pnvf_adapt_increment value.",
    "LLR.PLAT.PNV.ADPSCALAR.008": "The platform  shall  output the adaptive scalar value into pnvf_adapted.",
    "LLR.PLAT.PNV.ADPSCALAR.009": "The platform shall provide a Simulink interface block named\n                pnv_AdaptiveScalar that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionadapt_incrementInportReal\n        \n          The increment to the\n          current adapted value. The increment is only used when the inports\n          adapt and reset are conditioned correctly.\n        \n      adaptInportBoolean\n        \n          1 if the current adapted value\n          should be adjusted, 0 otherwise. If the inport reset is 1, no adaption\n          will occur (even if inport adapt is 1).\n        \n        \n          Range: 0 or 1\n        \n      resetInportBoolean\n        \n          1 if the current adapted value\n          should be reset to Adaptive Scalar (default), 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      adapted_scalarOutportReal\n        \n          The adapted value of the\n          Adaptive Scalar (default) parameter.\n        \n      Adaptive Scalar (default)ParamReal\n        \n          The name of\n          the default adapted scalar output value (e.g., vftc_myscalar). The adaptive block\n          reverts to this value when the reset inport is asserted or when the block data is\n          unrecoverable during power initialisation of the ECU.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.ADPSCALAR.109": "The block pnv_AdaptiveScalar shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.ADPSCALAR.209": "The block pnv_AdaptiveScalar shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.ADPSCALAR.010": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPSCALAR.011": "If the parameter Adaptive Scalar (default) is not a finite\n                real then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPSCALAR.012": "If the parameter Adaptive Scalar (default) is not of single\n                or double type then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPSCALAR.013": "If the parameter Adaptive Scalar (default) content\n                is not a valid name or scalar the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPSCALAR.014": "If the model does not contain a pnv_AdaptiveChecksum block  then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPSCALAR.015": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.ADPSCALAR.016": "During simulation the platform software is used resulting in the same behaviour as seen on the target.",
    "LLR.PLAT.PNV.ADPSCALAR.019": "When the inport, reset is true, the block  shall  reset\n                the outport adapted_scalar to the default value defined\n                by the mask Adaptive Scalar (default).",
    "LLR.PLAT.PNV.ADPSCALAR.020": "When the inport, adapt is true, the block  shall  adapt the scalar\n                by the inport adapt_increment value.",
    "LLR.PLAT.PNV.ADPSCALAR.021": "When the inports, reset and\n                adapt are false, the block  shall  write the adaptive scalar\n                value to the outport, adapted_scalar.",
    "LLR.PLAT.PNV.ADPMAP1D.001": "The platform  shall  provide a mechanism to reset the non-volatile map.",
    "LLR.PLAT.PNV.ADPMAP1D.002": "The platform  shall  provide a mechanism to adapt the non-volatile\n              map based on an adaption increment and a point of interpolation.",
    "LLR.PLAT.PNV.ADPMAP1D.003": "The platform  shall  perform the reset action if a reset is\n              commanded regardless of the state of the adapt input",
    "LLR.APP.PNV.ADPMAP1D.001": "The application  shall  provide a monotonic series (increasing or\n              decreasing) of x-axis values.",
    "LLR.APP.PNV.ADPMAP1D.002": "The application  shall  provide a series of two (2) or greater for\n              the x-axis and the z-axis",
    "LLR.APP.PNV.ADPMAP1D.003": "The application  shall  provide arrays for the x-axis and the z-axis\n              of the same size",
    "LLR.APP.PNV.ADPMAP1D.004": "The application  shall  provide an array of default values for\n              resetting the map of the same size as the index axis (x-axis) and\n              the adaptive map axis (z-axis)",
    "LLR.PLAT.PNV.ADPMAP1D.004": "The 1d interpolation routine  shall  not support extrapolation\n              outside the maps bounds. An input value exceeding the index axis\n              (x-axis) limits shall result in an output clipped to the map\n              value corresponding to the exceeded index axis (x-axis) limit.",
    "LLR.PLAT.PNV.ADPMAP1D.005": "A 1d linear interpolated value  shall  be deduced from the 1d map\n              series (z-axis) when the input value (x) is within the bounds of\n              the index axis (x-axis).",
    "LLR.PLAT.PNV.ADPMAP1D.006": "The platform shall provide a C interface function named\n                pnv_adap_map_1d_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpnvf_adapt_xx\n          in\n        F32\nThe argument to z(x), a point on the x-axis for interpolation.pnvf_adapt_increment\n          in\n        F32\nThe adaption increment, applied proportionately over interpolated values.pnvf_adapt\n          in\n        BOOL\nSet true to adapt the adaptive table based on the adaption increase (pnvf_adapt_increment), set false for no adaption. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_reset\n          in\n        BOOL\nSet true to reset the adaptive table to its default (pnvf_pz_default), set false for no reset. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_n\n          in\n        S32\nThe number of elements in the x-axis and z-data. If the number of elements is less than two (2), the output is set to zero and an error is returned (instead call pnv_adap_scalar_f32() for a scalar function). If the number of elements is greater than 1, then the x-axis is searched for bounding breakpoints to perform the interpolation.pnvf_px\n          in\n        volatile const F32 *\nPointer to array of the map's x-axis data. The values stored in the x-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.pnvf_pz_default\n          in\n        volatile const F32 *\nPointer to array of the map's default z-data. The default z-data is used to overwrite the adaptive map's z-data if the pnvf_reset parameter is true. \n The map which this pointer references must be declared with the OE_ADAP macro. \n Cannot be NULL.pnvf_pzz\n          out\n        F32 *\nPointer to interpolated output (possibly adapted or reset). \n Cannot be NULL.\n                The function returns a value of type\n                PNV_RC_T\n                with a value of:\n              PNV_RC_BAD_ARGS - if the input parameters are invalidPNV_RC_INSUFFICIENT_ELEMENTS - if there are insufficient elements to use the functionPNV_RC_OK - if operation is successful",
    "LLR.PLAT.PNV.ADPMAP1D.106": "The function pnv_adap_map_1d_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ADPMAP1D.206": "The function pnv_adap_map_1d_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ADPMAP1D.007": "The platform  shall  reject calls with a NULL\n                pointer in any of the following parameters\n                pnvf_px,\n                pnvf_pz,\n                pnvf_pzz or\n                pnvf_pz_default and\n                return PNV_RC_BAD_ARGS of the enumerated type\n                PNV_RC_T.  At the same time it  will  raise a recoverable\n                error PSY_PUT\/PNV_ADAPMAP_INVALID_ARG.",
    "LLR.PLAT.PNV.ADPMAP1D.008": "The platform  shall  reject calls with a pnvf_n\n                having a value of less than two (2) and return\n                PNV_RC_INSUFFICIENT_ELEMENTS of the enumerated type\n                PNV_RC_T. The output pnvf_pzz\n                 shall  be set to zero.",
    "LLR.PLAT.PNV.ADPMAP1D.009": "When pnvf_reset is true, the platform  shall  reset the adaptive\n                scalar to the default value pnvf_adapt_default.",
    "LLR.PLAT.PNV.ADPMAP1D.010": "When pnvf_adapt is true and pnvf_reset is false the\n                platform  shall  increment the adaptive maps value or values by the interpolated\n                pnvf_adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP1D.011": "The platform  shall  output the interpolated adaptive value into pnvf_pzz.",
    "LLR.PLAT.PNV.ADPMAP1D.012": "The platform shall provide a Simulink interface block named\n                pnv_AdaptiveMap1d that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionxInportReal\n        \n          The x-value at which a z-value is to\n          be adapted then interpolated. May be a scalar or a vector. If the inport is attached\n          to a vector, the size of the vector must match the size of any vector attached\n          to another inport.\n        \n      adapt_incrementInportReal\n        \n          The increment to the\n          current adapted value. The increment is only used when the inports\n          adapt and reset are conditioned correctly. May be a scalar or a vector.\n          If the inport is attached to a vector, the size of the vector must match the\n          size of any vector attached to another inport.\n        \n      adaptInportBoolean\n        \n          1 if the current adapted value\n          should be adjusted, 0 otherwise. If the inport reset is 1, no adaption\n          will occur (even if inport adapt is 1). May be a scalar or a vector. If the inport\n          is attached to a vector, the size of the vector must match the size of any vector\n          attached to another inport.\n        \n        \n          Range: 0 or 1\n        \n      resetInportBoolean\n        \n          1 if the current adapted value\n          should be reset to Adaptive Z Data (default), 0 otherwise. May be a scalar or a vector.\n          If the inport is attached to a vector, the size of the vector must match the size of any\n          vector attached to another inport.\n        \n        \n          Range: 0 or 1\n        \n      adapted_zOutportReal\n        \n          The adapted value or\n          values interpolated from parameter Adaptive Z Data (default) at the value\n          or values for inport x.\n        \n      X-axis Data (default)ParamReal\n        \n          The name of the\n          map's x axis (e.g. vftm_mymap_x, see\n          Section \"Naming rules\"). There must be two or more elements in this\n          parameter and that must be the same as the number of elements in parameter\n          Adaptive Z Data (default). The values of this parameter must increase\n          monotonically and adjacent values must not be the same.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Adaptive Z Data (default)ParamReal\n        \n          The name of\n          the map's z axis (e.g. vftm_mymap_zsee\n          Section \"Naming rules\"). There must be two or more elements in this\n          parameter and that must be the same as the number of elements in\n          X-axis Data (default). The adaptive block reverts to these values when the reset\n          inport is asserted or when the block data is unrecoverable during power\n          initialisation of the ECU.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.ADPMAP1D.112": "The block pnv_AdaptiveMap1d shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.ADPMAP1D.212": "The block pnv_AdaptiveMap1d shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.ADPMAP1D.013": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.014": "X-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the interface, if they are not a finite\n                real then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.015": "X-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the interface, if they are not of single or double\n                type then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.016": "X-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the interface, if they have a different number of\n                elements then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.017": "X-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the block, if they have less than two (2)\n                elements then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.018": "If X-axis Data (Default)\n                is not monotonically increasing or decreasing then the block\n                 shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.019": "If the model does not contain a pnv_AdaptiveChecksum block then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP1D.020": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.ADPMAP1D.021": "When the inport, reset is true, the platform\n                 shall  set the outport, adapted_z to the\n                interpolated or clipped value calculated after applying the    mask,\n                Adaptive Z Data (Default) to the z-axis\n                regardless of the state of adapt.",
    "LLR.PLAT.PNV.ADPMAP1D.022": "When adapt is true and\n                reset is false the\n                platform  shall  increment the adaptive maps value or values by the interpolated\n                adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP1D.023": "When the inports, adapt and\n                reset are false,\n                the platform  shall  return the linearly interpolated or clipped value\n                deduced from the 1d map series (z-axis) to the outport,\n                adapted_z.",
    "LLR.PLAT.PNV.ADPMAP1D.024": "When the inport, reset is true, the platform\n                 shall  set the outport, adapted_z to the\n                interpolated or clipped value calculated after applying the    mask,\n                Adaptive Z Data (Default) to the z-axis\n                regardless of the state of adapt.",
    "LLR.PLAT.PNV.ADPMAP1D.025": "When adapt is true and\n                reset is false the\n                platform  shall  increment the adaptive maps value or values by the interpolated\n                adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP1D.026": "When the inports, adapt and\n                reset are false,\n                the platform  shall  return the linearly interpolated or clipped value\n                deduced from the 1d map series (z-axis) to the outport,\n                adapted_z.",
    "LLR.PLAT.PNV.ADPMAP2D.001": "The platform  shall  provide a mechanism to reset the non-volatile map.",
    "LLR.PLAT.PNV.ADPMAP2D.002": "The platform  shall  provide a mechanism to adapt the non-volatile\n              map based on an adaption increment and a point of interpolation.",
    "LLR.PLAT.PNV.ADPMAP2D.003": "The platform  shall  perform the reset action if a reset is\n              commanded regardless of the state of the adapt input",
    "LLR.APP.PNV.ADPMAP2D.001": "The application  shall  provide a monotonic series (increasing or\n              decreasing) of x-axis and y-axis values.",
    "LLR.APP.PNV.ADPMAP2D.002": "The application  shall  provide a series of two (2) or greater of\n              x-axis and y-axis elements.",
    "LLR.APP.PNV.ADPMAP2D.003": "The application  shall  provide an array for the z-axis of the same\n              size as the x-axis size multiplied by the y-axis size",
    "LLR.APP.PNV.ADPMAP2D.004": "The application  shall  provide an array of default values for\n              resetting the map of the same size as the x-axis size multiplied\n              by the y-axis size",
    "LLR.PLAT.PNV.ADPMAP2D.004": "The 2d interpolation routine  shall  not support extrapolation\n              outside the maps bounds. An input value exceeding the x-axis\n              and\/or y-axis limits shall result in an output clipped to\n              the map value corresponding to the exceeded x-axis and\/or y-axis\n              limit.",
    "LLR.PLAT.PNV.ADPMAP2D.005": "A 2d linear interpolated value  shall  be deduced from the 2d map\n              series (z-axis) when the input values x and y are within the bounds\n              of the index axes.",
    "LLR.PLAT.PNV.ADPMAP2D.006": "The platform shall provide a C interface function named\n                pnv_adap_map_2d_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpnvf_adapt_xx\n          in\n        F32\nThe argument to z(x,y), a point on the x-axis for interpolation.pnvf_adapt_yy\n          in\n        F32\nThe argument to z(x,y), a point on the y-axis for interpolation.pnvf_adapt_increment\n          in\n        F32\nThe adaption increment, applied proportionately over interpolated values.pnvf_adapt\n          in\n        BOOL\nSet true to adapt the adaptive table based on the adaption increase (pnvf_adapt_increment), set false for no adaption. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_reset\n          in\n        BOOL\nSet true to reset the adaptive table to its default (pnvf_pz_default), set false for no reset. If both pnvf_adapt and pnvf_reset are set true, then no adaption occurs.pnvf_nx\n          in\n        S32\nThe number of elements in the x-axis and z(x,) data. If the number of elements is less than two (2), the output is set to zero and an error is returned (instead call pnv_adap_map_1d_f32() for a 1d table lookup and interpolate function). If the number of elements is greater than 1, then the x-axis is searched for bounding breakpoints to perform the interpolation.pnvf_ny\n          in\n        S32\nThe number of elements in the y-axis and z(,y) data. If the number of elements is less than two (2), the output is set to zero and an error is returned (instead call pnv_adap_map_1d_f32() for a 1d table lookup and interpolate function). If the number of elements is greater than 1, then the y-axis is searched for bounding breakpoints to perform the interpolation.pnvf_px\n          in\n        volatile const F32 *\nPointer to array of the map's x-axis data. The values stored in the x-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.pnvf_py\n          in\n        volatile const F32 *\nPointer to array of the map's y-axis. The values stored in the y-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.pnvf_pz_default\n          in\n        volatile const F32 *\nPointer to array of the map's default z-data. The default z-data is used to overwrite the adaptive map's z-data if the pnvf_reset parameter is true. \n The map which this pointer references must be declared with the OE_ADAP macro. \n Cannot be NULL.pnvf_pzz\n          out\n        F32 *\nPointer to interpolated output (possibly adapted or reset). \n Cannot be NULL.\n                The function returns a value of type\n                PNV_RC_T\n                with a value of:\n              PNV_RC_BAD_ARGS - if the input parameters are invalidPNV_RC_INSUFFICIENT_ELEMENTS - if there are insufficient elements to use the functionPNV_RC_OK - if operation is successful",
    "LLR.PLAT.PNV.ADPMAP2D.106": "The function pnv_adap_map_2d_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ADPMAP2D.206": "The function pnv_adap_map_2d_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ADPMAP2D.007": "The platform  shall  reject calls with a NULL\n                pointer in any of the following parameters\n                pnvf_px,\n                pnvf_py,\n                pnvf_pz,\n                pnvf_pzz or\n                pnvf_pz_default and\n                return PNV_RC_BAD_ARGS of the enumerated type\n                PNV_RC_T. At the same time it  will  raise a recoverable\n                error PSY_PUT\/PNV_ADAPMAP_INVALID_ARG.",
    "LLR.PLAT.PNV.ADPMAP2D.008": "The platform  shall  reject calls with a pnvf_nx or\n                pnvf_ny having a value of less than two (2) and return\n                PNV_RC_INSUFFICIENT_ELEMENTS of the enumerated type\n                PNV_RC_T. The output pnvf_pzz\n                 shall  be set to zero.",
    "LLR.PLAT.PNV.ADPMAP2D.009": "When pnvf_reset is true, the platform  shall  reset the adaptive\n                map to the default value pnvf_pz_default.",
    "LLR.PLAT.PNV.ADPMAP2D.010": "When pnvf_adapt is true and\n                pnvf_reset is false the platform  shall \n                increment the adaptive maps value or values by the interpolated\n                pnvf_adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP2D.011": "The platform  shall  output the interpolated adaptive value into\n                pnvf_pzz.",
    "LLR.PLAT.PNV.ADPMAP2D.012": "The platform shall provide a Simulink interface block named\n                pnv_AdaptiveMap2d that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionxInportReal\n        \n          The x-value at which a z-value is to\n          be adapted then interpolated. May be a scalar or a vector. If the inport is attached\n          to a vector, the size of the vector must match the size of any vector attached\n          to another inport.\n        \n      yInportReal\n        \n          The y-value at which a z-value is to\n          be adapted then interpolated. May be a scalar or a vector. If the inport is attached\n          to a vector, the size of the vector must match the size of any vector attached\n          to another inport.\n        \n      adapt_incrementInportReal\n        \n          The increment to the\n          current adapted value. The increment is only used when the inports\n          adapt and reset are conditioned correctly. May be a scalar or a vector. If the\n          inport is attached to a vector, the size of the vector must match the size of any\n          vector attached to another inport.\n        \n      adaptInportBoolean\n        \n          1 if the current adapted value\n          should be adjusted, 0 otherwise. If the inport reset is 1, no adaption\n          will occur (even if inport adapt is 1). May be a scalar or a vector. If the inport\n          is attached to a vector, the size of the vector must match the size of any vector\n          attached to another inport.\n        \n        \n          Range: 0 or 1\n        \n      resetInportBoolean\n        \n          1 if the current adapted value\n          should be forced to Adaptive Z Data (default), 0 otherwise. May be a scalar or a\n          vector. If the inport is attached to a vector, the size of the vector must match\n          the size of any vector attached to another inport.\n        \n        \n          Range: 0 or 1\n        \n      adapted_zOutportReal\n        \n          The adapted value or\n          values interpolated from parameter Adaptive Z Data (default) at the values for\n          inports x and y.\n        \n      X-axis Data (default)ParamReal\n        \n          The name of the\n          map's x axis (e.g. vftm_mymap_x, see Section \"Naming rules\").\n          There must be two or more elements in this parameter and that must be the same as\n          the number of elements as columns in parameter Adaptive Z Data (default). The\n          values of this parameter must increase monotonically and adjacent values must not\n          be the same.\n        \n      \n                Calibratable: no.\n              Y-axis Data (default)ParamReal\n        \n          The name of the\n          map's y axis (e.g. vftm_mymap_y, see Section \"Naming rules\").\n          There must be two or more elements in this parameter and that must be the same as\n          the number of elements as rows in parameter Adaptive Z Data (default). The\n          values of this parameter must increase monotonically and adjacent values must not\n          be the same.\n        \n      \n                Calibratable: no.\n              Adaptive Z Data (default)ParamReal\n        \n          The name of\n          the map's z matrix (e.g. vftm_mymap_z, see Section \"Naming rules\").\n          There must be the same number of rows as elements in parameter Y-axis Data (default)\n          and number of columns as elements in parameter X-axis Data (default).\n        \n      \n                Calibratable: no.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.ADPMAP2D.112": "The block pnv_AdaptiveMap2d shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.ADPMAP2D.212": "The block pnv_AdaptiveMap2d shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.ADPMAP2D.013": "Sample time is checked by the\n                block, if it is out of range, the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.014": "X-axis Data (Default),\n                Y-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the block, if they are not a finite reals then the\n                block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.015": "X-axis Data (Default),\n                Y-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the block, if they are not of single or double type\n                then the interface  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.016": "X-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the block, if the number of elements in the x-axis\n                does not match the number of columns in the z-data array then the block\n                 shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.017": "Y-axis Data (Default) and\n                Adaptive Z Data (Default)\n                are checked by the block, if the number of elements in the y-axis\n                does not match the number of rows in the z-data array then the block\n                 shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.018": "X-axis Data (Default) and\n                Y-axis Data (Default) are\n                checked by the block, if either have less than two (2) elements then\n                the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.019": "X-axis Data (Default) and\n                Y-axis Data (Default) are\n                checked by the block, if either are not monotonically increasing or\n                decreasing then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.020": "If the model does not contain a pnv_AdaptiveChecksum block then the block  shall  raise an error.",
    "LLR.PLAT.PNV.ADPMAP2D.021": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.ADPMAP2D.022": "When the inport, reset\n                is true, the platform  shall  set the outport,\n                adapted_z to the\n                interpolated or clipped value calculated after applying the mask,\n                Adaptive Z Data (default)\n                to the z-data.",
    "LLR.PLAT.PNV.ADPMAP2D.023": "When adapt is true and\n                reset is false the\n                platform  shall  increment the adaptive maps value or values by the interpolated\n                adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP2D.024": "When the inports, adapt and\n                reset are false,\n                the platform  shall  return the linear interpolated value deduced\n                from the 2d map series (z-axis) when the input values\n                x and\n                y are within\n                the bounds of the index axes,\n                X-axis Data (Default) and\n                Y-axis Data (Default) respectively,\n                to the outport, adapted_z.",
    "LLR.PLAT.PNV.ADPMAP2D.025": "When the inport, reset\n                is true, the platform  shall  set the outport,\n                adapted_z to the\n                interpolated or clipped value calculated after applying the mask,\n                Adaptive Z Data (default)\n                to the z-data.",
    "LLR.PLAT.PNV.ADPMAP2D.026": "When adapt is true and\n                reset is false the\n                platform  shall  increment the adaptive maps value or values by the interpolated\n                adapt_increment value.",
    "LLR.PLAT.PNV.ADPMAP2D.027": "When the inports, adapt and\n                reset are false,\n                the platform  shall  return the linear interpolated value deduced\n                from the 2d map series (z-axis) when the input values\n                x and\n                y are within\n                the bounds of the index axes,\n                X-axis Data (Default) and\n                Y-axis Data (Default) respectively,\n                to the outport, adapted_z.",
    "LLR.PLAT.PNV.COMMIT.002": "The platform  shall  commit data to non-volatile storage only if the data\n              has changed.",
    "LLR.PLAT.PNV.COMMIT.003": "When committing modified non-volatile data, the platform  shall  recalculate\n              the checksum of the current non-volatile memory objects.",
    "LLR.PLAT.PNV.COMMIT.001": "The platform shall provide a C interface function named\n                pnv_commit_to_store() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PNV.COMMIT.101": "The function pnv_commit_to_store() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.COMMIT.201": "The function pnv_commit_to_store() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.COMMIT.005": "When the non-volatile data has been modified, the platform  shall  copy the\n                data into flash if flash memmory is used for storage.",
    "LLR.PLAT.PNV.COMMIT.006": "The platform shall provide a Simulink interface block named\n                pnv_AdaptiveChecksum that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncalc_checksumInportBoolean\n        \n          Transition from 0 to 1\n          to cause the adaptive data to be saved;\n          no save takes place otherwise.\n        \n      Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.COMMIT.106": "The block pnv_AdaptiveChecksum shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.COMMIT.206": "The block pnv_AdaptiveChecksum shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.COMMIT.007": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PNV.COMMIT.008": "If the pnv_AdaptiveChecksum block appears more than once in the model then the block  shall  raise an error.",
    "LLR.PLAT.PNV.COMMIT.009": "If there is no pnv_Status block in the model then the block  shall  raise an error.",
    "LLR.PLAT.PNV.COMMIT.010": "The block  shall  schedule itself to run on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.COMMIT.011": "If the inport calc_checksum changes from 0 to 1 then the block\n                 shall  update the non-volatile data checksum, otherwise no action will be taken.",
    "LLR.PLAT.PNV.ISSTOREINTACT.001": "The platform shall provide a C interface function named\n                pnv_is_store_intact() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if there are no adaptive data changes since the last commit to the non-volatile store (from calling pnv_commit_to_store()), false otherwise",
    "LLR.PLAT.PNV.ISSTOREINTACT.101": "The function pnv_is_store_intact() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.ISSTOREINTACT.201": "The function pnv_is_store_intact() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.ISSTOREINTACT.002": "The function  shall  return true if there are no changes to the non-volatile data objects\n                since the last commit and false otherwise.",
    "LLR.PLAT.PNV.IS_RAM_CSUM_VALID.001": "The platform shall provide a C interface function named\n                pnv_is_ram_adap_csum_valid() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if RAM checksum intact, false otherwise.",
    "LLR.PLAT.PNV.IS_RAM_CSUM_VALID.101": "The function pnv_is_ram_adap_csum_valid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.IS_RAM_CSUM_VALID.201": "The function pnv_is_ram_adap_csum_valid() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.IS_RAM_CSUM_VALID.002": "The function  shall  return true if the adaptive data checksum is valid for the current\n                set of adaptive data in RAM, false otherwise.",
    "LLR.PLAT.PNV.IS_FLASH_CSUM_VALID.001": "The platform shall provide a C interface function named\n                pnv_is_flash_adap_csum_valid() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if Flash checksum intact, false otherwise.",
    "LLR.PLAT.PNV.IS_FLASH_CSUM_VALID.101": "The function pnv_is_flash_adap_csum_valid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PNV.IS_FLASH_CSUM_VALID.201": "The function pnv_is_flash_adap_csum_valid() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PNV.IS_FLASH_CSUM_VALID.002": "The function  shall  return true if the adaptive data checksum is valid for the current\n                set of adaptive data in flash, false otherwise.",
    "LLR.PLAT.PNV.STATUS.001": "The platform shall provide a Simulink interface block named\n                pnv_Status that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_ram_adaptive_checksum_okInportBoolean\n        \n          Value passed through to outport ram_adaptive_checksum_ok when running\n          the model under simulation. Has no effect when running on the target ECU.\n        \n        \n          Range: 0 or 1\n        \n      sim_flash_adaptive_checksum_okInportBoolean\n        \n          Value passed through to outport flash_adaptive_checksum_ok when running\n          the model under simulation. Has no effect when running on the target ECU.\n        \n        \n          Range: 0 or 1\n        \n      ram_adaptive_checksum_okOutportBoolean\n        \n          1 if the battery-backed RAM adaptive\n          data check-sum is valid and up to date, 0 otherwise. If the adaptive data check-sum\n          is invalid or inconsistent with the data stored in the battery backed RAM at\n          model start up, the adaptive data is reverted to default - see help\n          on the following adaptive data blocks:\n          adaptive checksum,\n          scalar,\n          1-d or\n          2-d maps, or\n          arrays.\n        \n        \n          Range: 0 or 1\n        \n      flash_adaptive_checksum_okOutportBoolean\n        \n          1 if the adaptive\n          data check-sum is valid either at start up or after a NVM update, 0 otherwise.\n          If the adaptive data check-sum is invalid at model start up, the adaptive data is\n          reverted to default - see help on the following adaptive data blocks:\n          adaptive checksum,\n          scalar,\n          1-d or\n          2-d maps, or\n          arrays.\n        \n        \n          Range: 0 or 1\n        \n      Sample timeParamReal\n        \n          The\n          periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.\n              Store adaptives in flash?ParamBoolean\n        \n          Store adaptives in flash memory if ticked.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PNV.STATUS.101": "The block pnv_Status shall support the targets:\n            All targets.",
    "LLR.PLAT.PNV.STATUS.201": "The block pnv_Status shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PNV.STATUS.002": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PNV.STATUS.003": "If the pnv_status block appears more than once in the model then the block  shall  raise an error.",
    "LLR.PLAT.PNV.STATUS.004": "If the mask Store adaptives in flash? is un-selected then\n                the target type must support battery backed RAM or the block  shall  raise an error.",
    "LLR.PLAT.PNV.STATUS.005": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PNV.STATUS.006": "The value of inport, sim_ram_adaptive_checksum_ok\n                is written to the outport, ram_adaptive_checksum_ok.",
    "LLR.PLAT.PNV.STATUS.007": "The value of inport, sim_flash_adaptive_checksum_ok\n                is written to the outport, flash_adaptive_checksum_ok.",
    "LLR.PLAT.PNV.STATUS.008": "The block  shall  write the value indicating if the ram checksum is valid to the outport\n                ram_adaptive_checksum_ok.",
    "LLR.PLAT.PNV.STATUS.009": "The block  shall  write the value indicating if the flash checksum is valid to the outport\n                flash_adaptive_checksum_ok.",
    "LLR.PLAT.PPID.PID.001": "The platform  shall  provide a mechanism whereby the application can\n              define PIDs which can be accessed by both the application and diagnostic\n              tool.",
    "LLR.PLAT.PPID.PID.050": "For non-volatile PIDs, during initialisation, the platform  shall  read all\n              non-volatile PIDs from non-volatile memory, compare them to the application\n              allowed list, and delete the non-volatile PID if the non-volatile PID is either\n              not on the allowed list, or the size is not within the min and max size range defined in the\n              application defined list.",
    "LLR.APP.PPID.PID.001": "The application  shall  provide data which is to be accessed by a diagnostic\n              scan tool via the associated PID.",
    "LLR.APP.PPID.PID.002": "The application  shall  right-justify any SPN data that are less than 8 bits in length\n              to the least significant bit, and pad the remaining bits with zero.\n            Note: \n              It is a requirement for freeze frame data on J1939 DM25 that the SPN data are packed\n              in this way. Since data can only be entered through the API as a whole number of bytes\n              this requirement must be met by the application developers.",
    "LLR.PLAT.PPID.PID.002": "The platform  shall  provide a mechanism by which the application can update\n              a PIDs cached data.",
    "LLR.PLAT.PPID.PID.003": "The platform  shall  provide a mechanism to read a PIDs overriden data.",
    "LLR.PLAT.PPID.PID.004": "The platform  shall  provide a mechanism to read a PIDs override state.",
    "LLR.PLAT.PPID.PID.039": "The platform  shall  provide a mechanism to write a PIDs data to non-volatile memory.",
    "LLR.PLAT.PPID.PID.040": "The platform  shall  provide a mechanism to read a PIDs data from non-volatile memory.",
    "LLR.PLAT.PPID.PID.006": "The platform  shall  provide an interface to allow the application to\n                    define individual PIDs as shown below.\n                pid\n{\n  name = identifier;\n  iso-16bit-id = integer;\n  byte-length = integer;\n  allow-ioctrl = true or false;\n  j1979-8bit-id = integer;\n  kwp-8bit-id = integer;\n  j1939-spn-id = integer;\n  resend-input-as-output = true or false;\n  input-byte-length = integer;\n  nonvolatile = true or false;\n  min-length = integer;\n  max-length = integer;\n  alphanumeric = true or false;\n  iso-scaling-bytes = string;\n}",
    "LLR.PLAT.PPID.PID.007": "The platform  shall  provide an interface to allow the application to\n                    add individual PIDs to a table as shown below.\n                pid-data\n{\n  pid { ... }\n  pid { ... }\n}",
    "LLR.PLAT.PPID.PID.008": "The platform  shall  provide the following constant variable for the C-API tool to declare\n                the number of PIDs defined by the application.\n              extern const U16 ppid_num_pids",
    "LLR.PLAT.PPID.PID.051": "The interface  shall  use the iso-16bit-id value to define\n                the unique 16-bit PID identifier (known as a CommonIdentifier in KW2000-3\n                or just Identifier in UDS).\n              Note\n                  For PIDs that have a J1979 and\/or KW2000 8-bit ID defined but no 16-bit ID,\n                  this may still be used with a dummy value.",
    "LLR.PLAT.PPID.PID.064": "The interface  shall  use the byte-length value to define the\n                length of the PID data in bytes.",
    "LLR.PLAT.PPID.PID.053": "The interface  shall  use the input-byte-length value to define\n                the maximum length of the override (IOControl) data expected from the test tool\n                for this PID.",
    "LLR.PLAT.PPID.PID.054": "The interface  shall  use the j1979-8bit-id value to define\n                the J1979 service 0x01 PID ID.",
    "LLR.PLAT.PPID.PID.055": "The interface  shall  use the kwp-8bit-id value to define\n                the KW2000-3 LocalIdentifier for this PID.",
    "LLR.PLAT.PPID.PID.056": "The interface  shall  use the j1939-spn-id value to define\n                the J1939 SPN identifier.",
    "LLR.PLAT.PPID.PID.057": "The interface  shall  use the resend-input-as-output flag to define\n                the data content to send in response to a read data by identifier ($22) command.\n                If false the response  shall  use the application value written to the PID\n                otherwise, if true the response shall instead use the overridden value.",
    "LLR.PLAT.PPID.PID.049": "The parameter alphanumeric  shall , for J1939 SPNs, define whether\n                the PID data is alphanumeric.\n              Note: \n                  Note: this may then be used in DM4 and DM25 to determine byte ordering.",
    "LLR.PLAT.PPID.PID.041": "The parameter nonvolatile  shall  define whether the PID is stored in\n                Non-volatile memory, if applicable to this PID.",
    "LLR.PLAT.PPID.PID.042": "For a PID stored in non-volatile memory,\n                the parameter min-length  shall  define the minimum length allowed for\n                the PID.",
    "LLR.PLAT.PPID.PID.043": "For a PID stored in non-volatile memory,\n                the parameter max-length  shall  define the maximum length allowed for\n                the PID.",
    "LLR.PLAT.PPID.PID.052": "The parameter iso-scaling-bytes  shall  define the scaling bytes that\n                will be transmitted in response to a UDS service $24 request for this PID.\n              Note: \n                  Notes:\n                \n                  1) If UDS service $24 is not desired for a PID, do no include\n                  iso-scaling-bytes for this PID.  In this case,\n                  If a $24 request is made for this PID, a negative response will\n                  be sent.\n                \n                  2) The scaling bytes are defined as a list of integers, which can be decimal\n                  or hex.  Example: iso-scaling-bytes = 0x32, 75, 123, 0x4F;",
    "LLR.PLAT.PPID.PID.018": "The platform shall provide a Simulink interface block named\n                ppid_Pid that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionapp_bytesInportArray\n        \n          Application supplied data which is to be accessed by a diagnostic scan tool via\n          the associated PID.\n        \n      write_to_nvInportBoolean\n        \n          Flag from application to write the data supplied at app_bytes\n          to non-volatile memory. This inport is only active when the\n          Non-volatile storage parameter is ticked.\n        \n      pid_bytesOutportArray\n        \n          When the PID data is being overridden at the request of the diagnostic scan tool, this outport\n          gives the override data. When not overridden, this outport just copies what is entered at the\n          app_bytes inport. Note that the size and dimensions of this outport are\n          automatically set to match those of the app_bytes inport.\n        \n      override_statusOutportInteger\n        \n          Indicates the ControlParameter status for an InputOutputControl\n          diagnostic service.\n          The values of the InputOutputControlParameter are specified as per the\n          draft KW2000-3.\n          The issued KW2000-3 standard does not specify the values.\n          The draft KW2000-3 and UDS InputOutputControlParameter values do not match\n        \n\n        Table\u00a03.72.\u00a0InputOutputControl Status (KW2000-3 draft)\n                  IOControl Status\n                \n                  Value\n                \n                  Description\n                returnControlToECU0x00\n                  Indicates that ControlParameter from InputOutputControl request from\n                  test tool was \"return control to ECU\", or this PID is not currently subject\n                  to IOControl.\n                freezeCurrentState0x05\n                  Indicates that ControlParameter from InputOutputControl request from\n                  test tool was \"freeze current state\", indicating that this PID is currently\n                  subject to override by the tool.\n                shortTermAdjustment0x07\n                  Indicates that ControlParameter from InputOutputControl request from\n                  test tool was \"short term adjustment\", indicating that this PID is currently\n                  subject to override by the tool.\n                \n      is_validOutportBoolean\n        \n          Flag to indicate if the value read from a non-volatile PID is valid.  The non-volatile\n          PID can be invalid, if it does not exist yet in non-volatile memory, as it has never\n          been written before.  It can also be invalid if the previous size in bytes does not\n          match the currently read size.  This flag indicates if the data in pid_bytes\n          is valid. This outport is only active when the Non-volatile storage\n          parameter is ticked.\n        \n      num_cem_recvdOutportuint8_T\n        \n          The number of controlEnableMask bytes received in the most recent $2F request from\n          the test tool. This outport is only active when the Number of controlEnableMask bytes expected\n          parameter has a non-zero value.\n        \n      cem_bytesOutportuint8_T vector\n        \n          The controlEnableMask byte values received in the most recent $2F request from\n          the test tool. This outport is only active when the Number of controlEnableMask bytes expected\n          parameter has a non-zero value. Only the number of bytes indicated in the\n          num_cem_recvd signal are valid; the rest are zeroed.\n        \n      Non-volatile storageParamBoolean\n        \n          If ticked indicates the PID's value is to be preserved across power cycles thus it is stored in non-volatile memory\n        \n      \n                Calibratable: no.\n              J1979 (8 bit)ParamBoolean\n        \n          If ticked, this parameter is accessible using the SAE J1979 protocol.\n          A numeric box is unveiled upon ticking this box.\n          In the unveiled numeric box enter the unique PID number.\n          This parameter is not available if the Non-volatile storage parameter\n          is ticked.\n        \n      \n                Calibratable: no.\n              KWP (8 bit)ParamBoolean\n        \n          If ticked, this parameter is accessible using the Keyword 2000-3 protocol.\n          A numeric box is unveiled upon ticking this box.\n          In the unveiled numeric box enter a unique PID number.\n        \n      \n                Calibratable: no.\n              ISO (16 bit)ParamBoolean\n        \n          If ticked, this parameter is accessible using the ISO 14229-1 (UDS) protocol.\n          Two additional parameters are unveiled upon ticking this box.\n          In the unveiled numeric box enter the unique PID number.\n          Tick the unveiled \"ReadScalingByIdentifier (UDS $24) support\" box if UDS $24 support\n          is required.  If this box is ticked, more options are unveiled: see below\n          following \"Resend input as output\".  NOTE: If ticked, the PID data is not\n          altered in any way by the PID block.  The UDS $24 scaling data is only used to\n          describe the scaling done by the application prior to the PID block\n          so the diagnostic tool can properly decode the data.\n        \n      \n                Calibratable: no.\n              J1939 (SPN)ParamBoolean\n        \n          If ticked indicates the PID represents a J1939 Suspect Parameter Number.\n          A numeric box is displayed upon ticking this box. In the displayed numeric\n          box enter the unique SPN number. Note that this parameter is only currently\n          used to allow freeze frame data to be stored for a J1939 DTC, and to allow\n          reading from and writing to non-volatile memory.\n        \n      \n                Calibratable: no.\n              Alphanumeric?ParamBoolean\n        \n          This checkbox is only displayed when the J1939 (SPN)\n          checkbox is ticked. It determines the format in which the SPN data is transmitted.\n          If ticked, the SPN data is treated as alphanumeric data with most significant\n          byte transmitted first; otherwise it is transmitted with least significant\n          byte first.\n        \n      \n                Calibratable: no.\n              String PIDParamBoolean\n        \n          If ticked indicates a string PID. A box to enter the string is displayed upon\n          ticking this box. The entered string needs to be enclosed with single apostrophes.\n          Note when using a string PID with non-volatile memory, the value of the string\n          will only be written during initialisation.\n        \n      \n                Calibratable: no.\n              Allows IOControlParamBoolean\n        \n          If ticked allows the diagnostic scan tool to override the PID. Leave unticked\n          to deny the diagnostic scan tool the ability to override the PID.  Not applicable\n          for non-volatile PIDs.\n        \n      \n                Calibratable: no.\n              Resend input as outputParamBoolean\n        \n          For a PID value which is being overridden by a diagnostic scan tool, two options\n          exist for what value to report back to the diagnostic scan tool in response to\n          a read data by identifier ($22) command.  Not applicable for non-volatile PIDs.\n          \n              Unticked - Responds with the application value written to the PID.\n            \n              Ticked - Responds with the overridden value.\n            \n        \n      \n                Calibratable: no.\n              Number of controlEnableMask bytes expectedParamInteger\n        \n          If set to a non-zero value, the PID will accept additional input bytes as part\n          of a $2F service request, and these are assumed to be controlEnableMask bytes.\n          These are made available via the outports num_cem_recvd\n          and cem_bytes.\n        \n        \n          It is the responsibility of the application to act appropriately on any\n          controlEnableMask bytes, e.g. by restricting the override of physical outputs only\n          to selected signals.\n        \n      \n                Calibratable: no.\n              Number of data bytesParamInteger\n        \n          Part of ReadScalingByIdentifier support.  Enter the number of data bytes that\n          will be stored by this PID. This is the number of data bytes of the PID data,\n          NOT the number of scaling bytes.\n        \n      \n                Calibratable: no.\n              Scaling Data TypeParamList\n        \n          Part of ReadScalingByIdentifier support.  A drop-down selection of data types\n          as defined in ISO-14229.\n        \n      \n                Calibratable: no.\n              Specify Scaling Formula?ParamBoolean\n        \n          Part of ReadScalingByIdentifier support.  If ticked, indicates that a scaling\n          formula will be transmitted with the scaling information.  A \"Formula Type\"\n          drop-down will be unveiled where the formula type must be specified.  Additionally,\n          numeric boxes will be unveiled where the formula coefficients must be entered.\n        \n      \n                Calibratable: no.\n              Specify engineering units?ParamBoolean\n        \n          Part of ReadScalingByIdentifier support.  If ticked, indicates that engineering\n          units will be transmitted with the scaling information.  A \"Units\" drop-down will\n          be unveiled where the engineering units must be specified.  Additionally, a\n          \"Use Unit Prefix\" check-box will be unveiled.  If ticked, a unit prefix will be\n          transmitted with the scaling information. A unit prefix drop-down will be unveiled\n          where the unit prefix must be specified.\n        \n      \n                Calibratable: no.\n              Specify state and connection type?ParamBoolean\n        \n          Part of ReadScalingByIdentifier support.  If ticked, indicates that state\n          and connection information (such as active high\/low, pull-up\/down circuitry,\n          etc.) will be transmitted with the scaling information. Four drop-downs will\n          be unveiled where the state and connection information must be specified.\n        \n      \n                Calibratable: no.\n              Manual Entry Scaling BytesParamArray\n        \n          Part of ReadScalingByIdentifier support.  This field will be unveiled if the\n          \"Scaling Data Type\" drop-down is set to \"F: Manually enter scaling bytes\".  This\n          field allows the user to manually specify all of the scaling bytes that will be\n          sent by the test tool.  Scaling bytes must be entered as a comma-separated list\n          of decimal integers from 0 to 255.\n        \n      \n                Calibratable: no.\n              Scaling Bytes Sent To Test ToolParamString\n        \n          Part of ReadScalingByIdentifier support.  This field displays the scaling bytes\n          that will be transmitted when service $24 is requested.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PPID.PID.118": "The block ppid_Pid shall support the targets:\n            All targets.",
    "LLR.PLAT.PPID.PID.218": "The block ppid_Pid shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.PID.046": "The app_bytes inport  shall  support multi-dimensional inputs.",
    "LLR.PLAT.PPID.PID.047": "The pid_bytes outport  shall  have the same size and dimensions\n              as the app_bytes inport.",
    "LLR.PLAT.PPID.PID.019": "If the target does not support this block then the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.058": "If the none of the diagnostic protocols is selected then the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.059": "If the J1979 PID identifier is outside the range [0, 255] the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.060": "If the KWP local identifier is outside the range [0, 255] the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.061": "If the ISO PID identifier is outside the range [0, 65535] the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.062": "If the SPN identifier is outside the range [0, 524287] the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.PID.020": "The block  shall  schedule itself to run on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPID.PID.021": "The block  shall  copy the app_bytes inport to the\n                pid_bytes outport.",
    "LLR.PLAT.PPID.PID.022": "The block  shall  set the override_status outport to\n                0 (returnControlToECU).",
    "LLR.PLAT.PPID.PID.025": "If the checkbox Non-volatile storage\n                is selected then the block  shall  store in non-volatile memory the PID's\n                value so as to preserve it across power cycles.",
    "LLR.PLAT.PPID.PID.026": "If the checkbox Non-volatile storage\n                is selected then the block  shall  reveal an additional inport\n                write_to_nv and outport\n                is_valid.",
    "LLR.PLAT.PPID.PID.027": "If the checkbox Non-volatile storage\n                is selected and the inport write_to_nv\n                transitions from false to true then the platform  shall  write the data supplied\n                at the inport app_bytes to non-volatile memory.",
    "LLR.PLAT.PPID.PID.028": "If the checkbox Non-volatile storage\n                is selected then the platform  shall  write to the outport\n                is_valid the state of the PID read from\n                non volatile memory.",
    "LLR.PLAT.PPID.PID.044": "If the checkbox Non-volatile storage\n                is selected then the platform  shall  write to the outport\n                pid_bytes the value of the PID read from\n                non volatile memory.",
    "LLR.PLAT.PPID.PID.045": "If the checkbox Non-volatile storage\n                is selected then the platform  shall  disable the checkbox for\n                J1979 (8 bit).\n              Rationale: \n                There are no defined services for J1979 to write or read from non-volatile PIDs\n                therefore J1979 PIDs are not supported as non-volatile PIDs.",
    "LLR.PLAT.PPID.PID.029": "If the checkbox J1979 (8 bit)\n                is selected then the block  shall  treat the PID format as per J1979 standard.",
    "LLR.PLAT.PPID.PID.030": "If the checkbox J1979 (8 bit)\n                is selected then the block  shall  reveal a numeric box that allows the user to\n                enter a unique PID number.",
    "LLR.PLAT.PPID.PID.031": "If the checkbox KWP (8 bit)\n                is selected then the block  shall  treat the PID format as per KWP (Keyword\n                2000 protocol) and a numeric box shall allow the user to enter a unique PID\n                number",
    "LLR.PLAT.PPID.PID.032": "If the checkbox ISO (16 bit)\n                is selected then the block  shall  treat the PID format as per IS0 15765\n                and a numeric box shall allow the user to enter a unique PID number",
    "LLR.PLAT.PPID.PID.033": "If the checkbox J1939 (SPN)\n                is selected then the block  shall  treat the PID format as a J1939 SPN\n                and a numeric box shall allow the user to enter a unique PID number\n                with a range of range [0, 524287].",
    "LLR.PLAT.PPID.PID.048": "If the checkbox J1939 (SPN)\n                is selected then the checkbox Alphanumeric?\n                 shall  be displayed which shall allow the user to indicate whether the SPN data\n                are to be treated as alphanumeric or not.\n              Note: \n                Alphanumeric SPN data are transmitted most-significant byte first whereas\n                other SPN data are transmitted least-significant byte first. See J1939-71\n                DEC2003 section 5.1.2.",
    "LLR.PLAT.PPID.PID.034": "If the checkbox String PID\n                is selected then the block  shall  treat the PID format as a string PID\n                and an alphanumeric box shall allow the user to enter a unique PID string.\n                The blocks output shall not be updated.",
    "LLR.PLAT.PPID.PID.035": "If the checkbox Allows IOControl\n                is not selected then the block  shall  simply copy\n                app_bytes to the PIDs cached data\n                area and the pid_bytes  will  be the same\n                as app_bytes.",
    "LLR.PLAT.PPID.PID.036": "If the checkbox Allows IOControl is\n                checked and the override state of the PID is PPID_ECU_CONTROLLED\n                then the block  shall  simply copy app_bytes\n                to the PIDs cached data area and the pid_bytes\n                 will  be the same as app_bytes.",
    "LLR.PLAT.PPID.PID.037": "If the checkbox Allows IOControl is\n                checked and the override state of the PID is\n                PPID_SHORT_TERM_ADJUSTMENT or\n                PPID_CURRENT_STATE_FROZEN\n                and the checkbox for Resend input as output\n                is checked then the block  shall  copy the PIDs overridden data to\n                pid_bytes otherwise it  will  copy the PIDs\n                cached application supplied data to the port.",
    "LLR.PLAT.PPID.PID.063": "The block  shall  output the override state of the PID to the\n                is_overridden outport.",
    "LLR.PLAT.PPID.UPDATE.001": "The platform  shall  check the input vaules and return an error if they are\n              invalid",
    "LLR.PLAT.PPID.UPDATE.002": "If the input variables are valid the platform  shall  update cached values for\n              this PID with fresh application.",
    "LLR.PLAT.PPID.UPDATE.003": "The platform shall provide a C interface function named\n                ppid_update_pid() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppidf_pid_const_data\n          in\/out\n        const struct PPID_PID_CONST_T *const\nPointer to the PID data structure to be updatedppidf_app_supplied_data\n          in\n        const U8 *\nApplication supplied data to be used for the update\n                The function returns a value of type\n                PPID_RC_T\n                with a value of:\n              PPID_RC_BAD_ARGS - if the input parameters are invalidPPID_RC_BAD_CONFIG_DATA - if there is a mismatch in the byte-length of PID dataPPID_RC_OK - if operation is successful",
    "LLR.PLAT.PPID.UPDATE.103": "The function ppid_update_pid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPID.UPDATE.203": "The function ppid_update_pid() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.UPDATE.004": "The platform  shall  reject calls where ppidf_pid_const_data\n                is NULL, or points to a region not within the bounds\n                of the table of PIDs and return from the call with the an argument of\n                PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.UPDATE.006": "The platform  shall  reject calls where ppidf_pid_const_data\n                contains pointers to NULL instead of valid pointers\n                to data for its app_supplied_data value and return from\n                the call with the an argument of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.UPDATE.007": "The platform  shall  reject calls where ppidf_pid_const_data\n                value for byte_len exceeds the maximum for the\n                system of PPID_MAX_PID_BYTE_LEN and return from the\n                call with the an argument of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.UPDATE.008": "The platform  shall  copy  the number of bytes defined by the value of\n                ppidf_pid_const_data->byte_len from\n                ppidf_app_supplied_data into\n                ppidf_pid_const_data->app_supplied_data.",
    "LLR.PLAT.PPID.GET.001": "The platform  shall  update application values for this PID with the cached\n              values.",
    "LLR.PLAT.PPID.GET.002": "The platform shall provide a C interface function named\n                ppid_get_pid() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppidf_pid_const_data\n          in\n        const struct PPID_PID_CONST_T *\nPointer to the PID data structure. \n Cannot be NULL.ppidf_pid_data\n          out\n        U8 *\nPointer to the buffer (address of array) provided by the application to receive the PID data. \n Cannot be NULL.ppidf_override_state\n          out\n        U8 *\nPointer to variable set to nonzero code if the PID is overridden, zero otherwise. The code value will be one of:\nPPID_ECU_CONTROLLED PPID_CURRENT_STATE_FROZEN PPID_SHORT_TERM_ADJUSTMENT Can be NULL if overridden status is not required.\n\n                The function returns a value of type\n                PPID_RC_T\n                with a value of:\n              PPID_RC_BAD_ARGS - if the input parameters are invalidPPID_RC_BAD_CONFIG_DATA - if the length of PID data is too long or data is invalidPPID_RC_OK - if operation is successful",
    "LLR.PLAT.PPID.GET.102": "The function ppid_get_pid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPID.GET.202": "The function ppid_get_pid() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.GET.003": "The platform  shall  reject calls where ppidf_pid_const_data\n                is NULL, or points to a region not within the bounds\n                of the table of PIDs and return from the call with the an argument of\n                PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.GET.004": "The platform  shall  reject calls where ppidf_pid_data\n                is NULL and return from the call with the an argument of\n                PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.GET.006": "The platform  shall  reject calls where ppidf_pid_const_data\n                contains pointers to NULL instead of valid pointers\n                to data for its app_supplied_data value and return from\n                the call with the an argument of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.GET.007": "The platform  shall  reject calls where ppidf_pid_const_data\n                value for byte_len exceeds the maximum for the\n                system of PPID_MAX_PID_BYTE_LEN and return from the\n                call with the an argument of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.GET.008": "The platform  shall  reject calls where ppidf_pid_const_data\n                contains pointers to NULL instead of valid pointers\n                to data for its override_data value and\n                ppidf_pid_const_data value for override_state\n                states the data is overridden and return from the call with the an argument\n                of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.GET.009": "If the override_state indicates that the data is overridden\n                and the ppidf_pid_const_data->flags shows that PPID_RESEND_IN_OUT\n                has been selected for the pid then the platform  shall  copy the number of bytes defined by the value of\n                ppidf_pid_const_data->byte_len from ppidf_pid_const_data->override_data\n                into ppidf_pid_data.",
    "LLR.PLAT.PPID.GET.010": "If the override_state indicates that the data is not\n                overridden then the platform  shall  copy the number of bytes defined by\n                the value of ppidf_pid_const_data->byte_len from\n                ppidf_pid_const_data->app_supplied_data into\n                ppidf_pid_data.",
    "LLR.PLAT.PPID.GET.011": "If ppidf_override_state is not NULL.\n                the the platform  shall  copy the value to it indicating whether the PID is\n                is currently subject to alteration via an InputOutputControl\n                request from the test tool. With zero meaning it is not.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.001": "The platform  shall  make available the override data of the PID\n              when requested by the application.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.002": "The platform  shall  make available the override state of the PID\n              when requested by the application.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.003": "The platform shall provide a C interface function named\n                ppid_get_override_data() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppidf_pid_const_data\n          in\n        const struct PPID_PID_CONST_T *\nPointer to the PID data structure. \n Cannot be NULL.ppidf_override_data\n          out\n        U8 *\nPointer to the buffer (address of array) provided by the application to receive the PID data. This must be at least large enough for the input byte length declared for this PID (or the output length if that was not explicitly specified, and so assumed equal).\n Can be NULL if the actual data is not required.ppidf_override_state\n          out\n        U8 *\nPointer to variable set to nonzero code if the PID is overridden, zero otherwise. The code is the IOControl parameter from the request message.\n Can be NULL if overridden status is not required.ppidf_control_enable_mask_data\n          out\n        U8 *\nPointer to the buffer (address of array) provided by the application to receive the controlEnableMask data (if the PID is configured to accept it).\n Both this and ppidf_num_cem_bytes must be non-NULL if the data is required.ppidf_num_cem_bytes\n          out\n        U8 *\nPointer to variable set to the number of controlEnableMask bytes last received for this PID when an IOControl override was requested.\n Both this and ppidf_control_enable_mask_data must be non-NULL if the data is required.\n                The function returns a value of type\n                PPID_RC_T\n                with a value of:\n              PPID_RC_BAD_ARGS - if the input parameters are invalidPPID_RC_BAD_CONFIG_DATA - if the length of PID data is too long or data is invalidPPID_RC_OK - if operation is successful",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.103": "The function ppid_get_override_data() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.203": "The function ppid_get_override_data() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.004": "The platform  shall  reject calls where\n                pid_const_data is NULL, or points\n                to a region not within the bounds of the table of PIDs and return from\n                the call with the an argument of PPID_RC_BAD_ARGS.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.006": "The platform  shall  reject calls where\n                ppidf_pid_const_data\n                contains pointers to NULL instead of valid pointers\n                to data for its override_data and override_state\n                values and return from the call with the an argument of\n                PPID_RC_BAD_CONFIG_DATA.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.007": "The platform  shall  reject calls where ppidf_pid_const_data\n                value for input_byte_len exceeds the maximum for the\n                system of PPID_MAX_PID_BYTE_LEN and return from the call\n                with the an argument of PPID_RC_BAD_CONFIG_DATA",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.008": "If ppidf_override_data is not NULL\n                the platform  shall  copy  the number of bytes defined by the value of\n                ppidf_pid_const_data->input_byte_len from\n                ppidf_pid_const_data->override_data into\n                ppidf_override_data.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.009": "If ppidf_override_state is not NULL\n                the platform  shall  copy the value of\n                ppidf_pid_const_data->override_state into\n                ppidf_override_state.",
    "LLR.PLAT.PPID.GETOVERRIDEDATA.010": "If both ppidf_control_enable_mask_data and\n                ppidf_num_cem_bytes are not NULL,\n                and if the PID is configured to accept controlEnableMask bytes,\n                the platform  shall  fill ppidf_control_enable_mask_data with the\n                controlEnableMask bytes most recently supplied by the tester, and\n                ppidf_num_cem_bytes with the number of bytes it supplied.",
    "LLR.PLAT.PPID.SCALING.001": "The block  shall  scale the input with the user entered parameters and output\n                the result",
    "LLR.PLAT.PPID.SCALING.002": "The block  shall  allow selection of the output data size as a unsigned\n                integer 8, 16 or 32 bits long",
    "LLR.PLAT.PPID.SCALING.003": "The platform shall provide a Simulink interface block named\n                ppid_Scaling that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioninInportInteger\n        \n          Input value to be scaled.\n        \n      rawOutportInteger\n        \n          Raw bytes output to represent the input with the scaling applied.\n        \n      J1979 standard scalingParamList\n        \n          If ticked a drop down list of standard J1979 scalings is revealed.\n          The scalings in the list are as per Annex B of issue 7 of ISO15031-5 (SAE J1979).\n        \n      \n                Calibratable: no.\n              Scaling\/bitParamReal\n        \n          Numeric field to enter the scaling\/bit.\n        \n        \n          For example a value of 0.25 in this field\n          would result in 4 being output (assuming the offset is set to 0)\n          from this block when the input is 1.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Scaling offsetParamReal\n        \n          Numeric field to enter the scaling offset.\n        \n        \n          For example with a value of 0.25 set in the scaling\/bit field and\n          this field set to -0.5, would result in 2 being output from this\n          block when the input is 1.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              MaxParamReal\n        \n          Numeric field to enter the maximum value of the input.\n          An input value exceeding the maximum value is clipped\n          to the maximum value prior to the scaling being applied.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              MinParamReal\n        \n          Numeric field to enter the minimum value of the input.\n          An input value falling below the minimum value is clipped\n          to the minimum value prior to the scaling being applied.\n        \n      \n                Calibratable: used during initialisation (power-up).\n              Engineering UnitsParamString\n        \n          String field to the engineering units associated with the scaling. The\n          string in this field should be enclosed with single apostrophes.\n        \n      \n                Calibratable: no.\n              Data type outParamList\n        \n          A drop down list of the supported data types out. The supported data types are:\n          uint8uint16uint32\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PPID.SCALING.103": "The block ppid_Scaling shall support the targets:\n            All targets.",
    "LLR.PLAT.PPID.SCALING.203": "The block ppid_Scaling shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.SCALING.005": "If the target does not support this block then the block  shall  raise an\n                   error.",
    "LLR.PLAT.PPID.SCALING.006": "The block  shall  schedule itself to run on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPID.SCALING.007": "If the checkbox  J1979 standard scaling is\n                ticked a drop down list of standard J1979 scalings is revealed. The scalings in the list\n                are as as per Annex B of issue 7 of ISO15031-5 (SAE J1979). The block  shall  scale the input\n                to the output with the chosen scaling if this option is selected.",
    "LLR.PLAT.PPID.SCALING.008": "If the checkbox  J1979 standard scaling\n                is not checked then the block  shall  scale the input value by the amount value of\n                Scaling\/bit using simple multiplication.",
    "LLR.PLAT.PPID.SCALING.009": "If the checkbox  J1979 standard scaling\n                is not checked then the block  shall  apply the offset to the input value of\n                Scaling offset.",
    "LLR.PLAT.PPID.SCALING.010": "If the checkbox  J1979 standard scaling\n                is not checked then the blocks scaling of the input value  shall  have an upper\n                limit of Max.",
    "LLR.PLAT.PPID.SCALING.011": "If the checkbox  J1979 standard scaling\n                is not checked then the blocks scaling of the input value  shall  have an lower\n                limit of Min.",
    "LLR.PLAT.PPID.SCALING.012": "The string input Engineering Units  shall  define\n                the engineering units associated with the scaling when enclosed in single apostrophes",
    "LLR.PLAT.PPID.SCALING.013": "A drop down list of the supported data types out, Data type out\n                 shall  define the format of the output data; allowed types are:\n                uint8uint16uint32",
    "LLR.PLAT.PPID.CLROVERRIDE.001": "The  platform  shall  provide a mechanism  whereby the override state can be\n              cleared for an individual PID.",
    "LLR.PLAT.PPID.CLROVERRIDE.002": "If any of the input parameters are pointers to NULL then the software  shall \n              consider this an error and return a value other of\n              PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.CLROVERRIDE.003": "When called the platform  shall  set the PIDs override state to\n              PPID_ECU_CONTROLLED",
    "LLR.PLAT.PPID.OVERRIDE.001": "The  platform  shall  provide a mechanism  whereby the override state can be\n              set and the input signal, internal parameter or output signal can be adjusted.",
    "LLR.PLAT.PPID.OVERRIDE.002": "If the length of the override data exceeds the length of the PIDs buffer\n              then the error PPID_RC_ERROR is returned.",
    "LLR.PLAT.PPID.OVERRIDE.003": "If any of the input parameters are pointers to NULL then the software  shall \n              consider this an error and return a value other of\n              PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.OVERRIDE.004": "The platform  shall  return the error PPID_RC_BAD_CONFIG_DATA if the\n              PIDs override state is a pointer to NULL.",
    "LLR.PLAT.PPID.OVERRIDE.005": "The platform  shall  return the error PPID_RC_BAD_CONFIG_DATA if the\n              PIDs override data is a pointer to NULL.",
    "LLR.PLAT.PPID.OVERRIDE.006": "When called, provided there are no errors, the platform  shall  set the PIDs\n              override state to PPID_SHORT_TERM_ADJUSTMENT",
    "LLR.PLAT.PPID.OVERRIDE.008": "When called, provided there are no errors, the platform  shall  set the PIDs\n              value to the value specified by the test tool.",
    "LLR.PLAT.PPID.FREEZE.001": "The  platform  shall  provide a mechanism  whereby the override state can be\n              frozen and the input signal, internal parameter or output signal holds its\n              current value.",
    "LLR.PLAT.PPID.FREEZE.002": "If a request is made to freeze a PID that is NULL then the platform  shall  consider\n              this an error and return a value of PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.FREEZE.003": "If a request is made to freeze a PID that has an override state pointer that is NULL\n              then the platform  shall  consider this an error and return a value of\n              PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.FREEZE.004": "If a request is made to freeze a PID that has an override data pointer that is NULL\n              then the platform  shall  consider this an error and return a value of\n              PPID_RC_BAD_ARGS",
    "LLR.PLAT.PPID.FREEZE.005": "When called, provided there are no errors and the override state is not\n              PPID_ECU_CONTROLLED, the platform  shall  set the PIDs\n              override state to PPID_CURRENT_STATE_FROZEN",
    "LLR.PLAT.PPID.CLRALLOVERRIDE.001": "The  platform  shall  provide a mechanism  whereby the override state can be\n              cleared.",
    "LLR.PLAT.PPID.CLRALLOVERRIDE.002": "When the connection to the test tool is lost for more than 5 seconds the platform\n               shall  restore the variable override_state to zero.\n            Rationale: \n              The Th!nk project had a requirement to do this after 5 sec, which tallies with the following\n              different timeout from ISO15765-3: \u201cS3Server Time for the server to keep a diagnostic\n              session other than the defaultSession active while not receiving any diagnostic\n              request message: 5000 ms\u201d\n            \n              This is not quite what we need for KW2000-3 IOControlByCommonIdentifier,\n              but suggests that if the test tool goes quiet for 5 seconds then we can assume it's not there\n              any more.",
    "LLR.PLAT.PPID.CLRALLOVERRIDE.003": "If any of the input parameters are pointers to NULL then the platform  shall \n              consider this an error and return PPID_RC_BAD_ARGS.",
    "LLR.PLAT.PPID.CLRALLOVERRIDE.004": "When called the platform  shall  set the PIDs override state to\n              PPID_ECU_CONTROLLED",
    "LLR.PLAT.PPID.GETNV.001": "The platform  shall  update application values for the NV PID requested by the application\n              with the value stored in non-volatile memory.",
    "LLR.PLAT.PPID.GETNV.002": "The platform shall provide a C interface function named\n                ppid_get_nv_pid() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppidf_type_flag\n          in\n        U8\nOne of the constants PPID_ISO_16BIT_PID, PPID_KWP_8BIT_PID or PPID_J1939_SPN_PID indicating which type of ID is being provided to identify the PID.ppidf_id\n          in\n        U32\nIdentifies this PID. The value passed will be interpreted as a KW2000 LID, KW2000\/UDS 16-bit ID or J1939 SPN depending on ppidf_type_flag.ppidf_data_ptr\n          out\n        U8 *\nIf a value is set for this PID, the data content will be written to this location unless it is set to NULL. The caller must ensure that this points to a buffer of sufficient size to accept the data. Set to NULL if the actual data is not required.ppidf_min_size\n          in\n        U16\nIf the stored data length is less than this value, PPID_RC_ERROR will be returned and no data will be written through ppidf_data_ptr, but the actual size will still be returned through ppidf_current_size.ppidf_max_size\n          in\n        U16\nSimilar to ppidf_min_size, but the maximum size allowable.ppidf_current_size\n          out\n        U16 *\nUnless this is NULL, the current data size of the PID will be written through this pointer if a value currently exists.\n                The function returns a value of type\n                PPID_RC_T\n                with a value of:\n              PPID_RC_ERROR - if the PID does not currently have a value set or the size was out of rangePPID_RC_OK - if operation is successful",
    "LLR.PLAT.PPID.GETNV.102": "The function ppid_get_nv_pid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPID.GETNV.202": "The function ppid_get_nv_pid() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.GETNV.003": "For the type of PID requested with the parameter ppidf_type_flag, if the non-volatile PID identified\n                by the pid_bytes parameter exists in non-volatile memory and the size of the non-volatile PID\n                is greater or equal to ppidf_min_size and less than or equal to ppidf_max_size,\n                the platform  shall  return the value of the non-volatile PID to the application in the ppidf_data_ptr\n                and the size of the non-volatile PID in the parameter ppidf_current_size.",
    "LLR.PLAT.PPID.SETNV.001": "The platform  shall  write the application value for this NV PID to\n              non-volatile memory.",
    "LLR.PLAT.PPID.SETNV.002": "The platform shall provide a C interface function named\n                ppid_set_nv_pid() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppidf_type_flags\n          in\n        U8\nOne or more of the constants PPID_ISO_16BIT_PID, PPID_KWP_8BIT_PID or PPID_J1939_SPN_PID ORd together to indicate which type(s) of ID this PID shall be identified by.ppidf_kwp_8bit_id\n          in\n        U8\nIf relevant, the KW2000 LID for this PID. Otherwise unused.ppidf_pid_id\n          in\n        U16\nIf relevant, the KW2000\/UDS 16-bit ID for this PID. Otherwise unused.ppidf_j1939_spn_id\n          in\n        U32\nIf relevant, the J1939 SPN for this PID. Otherwise unused.ppidf_new_data_ptr\n          in\n        const U8 *\nPointer to the byte data from which the new value of this PID will be copied. Cannot be NULL if any data is to be written, but other error status values can still be obtained if it is NULL.ppidf_new_size\n          in\n        U8\nNew size for the value of this PID. Must be within the specific range set for this PID.ppidf_only_if_uninit\n          in\n        BOOL\nIf TRUE, the PID value is set only if no prior value existed for this PID (intended for initialisation to a default in a newly-flashed application). Otherwise, the new value is always set.\n                The function returns a value of type\n                PPID_RC_T\n                with a value of:\n              PPID_RC_ALREADY_SET - if ppidf_only_if_uninit=TRUE and a value was already set for this PIDPPID_RC_ERROR - if the new value could not be written (e.g. if not defined for this application)PPID_RC_OK - if operation is successful",
    "LLR.PLAT.PPID.SETNV.102": "The function ppid_set_nv_pid() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPID.SETNV.202": "The function ppid_set_nv_pid() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPID.SETNV.003": "The platform  shall  reject calls where\n                ppidf_new_data_ptr is NULL\n                and return from the call with the an argument of PPID_RC_ERROR.",
    "LLR.PLAT.PPID.SETNV.004": "For the type of PID requested with the parameter ppidf_type_flag, the non-volatile PID identified\n                by the ppidf_kwp_8bit_id, ppidf_pid_id, or ppidf_j1939_spn_id parameters\n                 will  be written to non-volatile memory with the data size specified by ppidf_new_size, and data from the application\n                supplied data buffer ppidf_new_data_ptr.",
    "LLR.PLAT.PPID.SETNV.005": "If the ppidf_only_if_uninit parameter is TRUE, the non-volatile PID  will  only be written to if the PID\n                does not yet exist.",
    "LLR.PLAT.PPM.WRAP.001": "At pre-initialisation time, the platform  shall  execute the underlying driver's\n              pre-initialisation routine.",
    "LLR.PLAT.PPM.WRAP.002": "At post-initialisation time, the platform  shall  execute the underlying driver's\n              post-initialisation routine.",
    "LLR.PLAT.PPM.WRAP.003": "The platform  shall  provide a task which the kernel executes periodically at a\n              rate of 100ms to execute the necessary periodic work done by the device-specific\n              driver.",
    "LLR.PLAT.PPM.WRAP.004": "<xi:include><\/xi:include>",
    "LLR.PLAT.PPM.WRAP.005": "The platform shall provide a C interface function named\n                ppm_digital_output() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionppmf_device\n          in\n        U8\nPower management device to addressppmf_pchan\n          in\n        U8\nPower management channel in device to addressppmf_state\n          in\n        BOOL\nState of digital outputppmf_init\n          in\n        BOOL\nInitialise the channel\n                The function returns a value of type\n                PDX_RC_T\n                with a value of:\n              Status of write.PDX_RC_OK - successful actionPDX_RC_SW_ERROR - channel not supportedPDX_RC_HW_ERROR - if error initialising channelPDX_RC_BAD_ARGS - configuration error",
    "LLR.PLAT.PPM.WRAP.006": "The functions ppm_digital_output_init and\n                ppm_digital_output  shall  call the corresponding functions of the\n                underlying driver.",
    "LLR.PLAT.PPM.TJA104X.001": "At pre-initialisation time, the TJA104x driver  shall  initialise the power hold output\n              to the disabled state.\n            Rationale: \n              The ECU's default behaviour should be to shut down when ignition is removed. To change this behaviour the application enables the power hold output.",
    "LLR.PLAT.PPM.TJA104X.002": "At pre-initialisation time, the TJA104x driver  shall  initialise the CAN-enable\n              outputs to the enabled state.\n            Rationale: \n              The ECU's default behaviour should be to allow the CAN transceivers to function.",
    "LLR.PLAT.PPM.TJA104X.003": "At post-initialisation time, the TJA104x driver  shall  set up the internal desired keep-awake state.",
    "LLR.PLAT.PPM.TJA104X.004": "If the ignition sense is asserted, then the desired keep-awake state  shall  be set to\n              on and the the CAN enable pins should match the values set by the application.",
    "LLR.PLAT.PPM.TJA104X.005": "If the ignition sense is set to the inactive state and the power-hold output is set\n              to the active state, then the power hold output pin  shall  be set to the active state\n              and the desired keep-awake state shall be set to on.",
    "LLR.PLAT.PPM.TJA104X.009": "If the ignition sense is set to the inactive state and the power-hold output is set\n              to the active state, then the CAN enable pins  shall  match the values set by the application.",
    "LLR.PLAT.PPM.TJA104X.006": "If both the ignition sense power-hold output are set to the inactive state, then the\n              power hold output pin  shall  be set to the inactive state and the desired keep-awake state shall be set to off.",
    "LLR.PLAT.PPM.TJA104X.007": "If the desired keep-awake state changes from on to off, then the CAN enable pins\n               shall  be set to the inactive state.\n            Note: \n              On a transition from the enabled to disabled state, immediately set the digital\n              output to the disabled state.",
    "LLR.PLAT.PPM.TJA104X.008": "The TJA1041Ax periodic function  shall  toggle the CAN enable pins specified\n              in the device configuration structure if the desire keep-awake state has remained\n              off and and the time since the last toggle has been at least the timeout specified in\n              the device configuration structure.",
    "LLR.PLAT.PPR.MEMORY.001": "When requested by the application software, the platform  shall  store DME, DTE, Ignition Cycle and General Denominator data in NVM.\n            Note: \n              This function suspends the scheduler for a period of time. The period of time depends on the size of data and the storage location.\n              If storing information to Flash, the worst case Flash erase time given worst case environmental conditions, can be around 1.8 seconds.",
    "LLR.PLAT.PPR.MEMORY.002": "When requested by the application software, the platform  shall  return the status of the PPR NVM store.",
    "LLR.PLAT.PPR.MEMORY.003": "The platform shall provide a C interface function named\n                ppr_commit_to_store() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PPR.MEMORY.103": "The function ppr_commit_to_store() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MEMORY.203": "The function ppr_commit_to_store() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MEMORY.004": "If the PPR information has been modified and if the PPR non-volatile storage is enabled the function  shall  store it in NVM.",
    "LLR.PLAT.PPR.MEMORY.005": "The platform  shall  set a flag on successfully storing the PPR data in NVM.",
    "LLR.PLAT.PPR.MEMORY.006": "The platform shall provide a C interface function named\n                ppr_is_store_intact() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if there are no data changes since the last commit to the non-volatile store (from calling ppr_commit_to_store()), false otherwise",
    "LLR.PLAT.PPR.MEMORY.106": "The function ppr_is_store_intact() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MEMORY.206": "The function ppr_is_store_intact() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MEMORY.007": "The function  shall  return the status of the non volatile PPR store.",
    "LLR.PLAT.PPR.MEMORY.008": "The platform shall provide a Simulink interface block named\n                ppr_Memory that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncommitInportBoolean\n        \n          Set to 1 to write the IUPR data to non-volatile memory.  Note that the block\n          responds to the rising edge of this inport in order to prevent multiple stores\n          to NVM.\n          Set to zero otherwise.\n        \n        \n          Range: 0 or 1\n        \n      store_up_to_dateOutportBoolean\n        \n          Set to 1 if the\n          storage of IUPR data to non-volatile memory was successful, set to zero otherwise.\n        \n        \n          Range: 0 or 1",
    "LLR.PLAT.PPR.MEMORY.108": "The block ppr_Memory shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.MEMORY.208": "The block ppr_Memory shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MEMORY.009": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MEMORY.012": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPR.MEMORY.013": "The block  shall  update the PPR storage when the inport commit is set\n                to 1, otherwise no action is taken.",
    "LLR.PLAT.PPR.MEMORY.014": "The block  shall  update the outport store_up_to_date with\n                the status of the PPR storage area.",
    "LLR.PLAT.PPR.IGNITION.001": "On startup, the platform  shall  retrieve the ignition cycle counter from non-volatile storage.",
    "LLR.PLAT.PPR.IGNITION.015": "If PPR data was not succesfully retrieved from non-volatile storage, the platform  shall  reset the\n              ignition cycle counter to zero.",
    "LLR.PLAT.PPR.IGNITION.002": "When requested by the application, the platform  shall  increment the ignition cycle counter by one.",
    "LLR.PLAT.PPR.IGNITION.003": "The ignition cycle counter  shall  be incremented only once per ignition cycle.",
    "LLR.PLAT.PPR.IGNITION.004": "If the ignition cycle counter reaches the maximum value of 65,535 the ignition cycle counter  shall  rollover and increment to zero on the next ignition\n              cycle to avoid overflow problems.",
    "LLR.PLAT.PPR.IGNITION.005": "The platform shall provide a C interface function named\n                ppr_update_ign_cyc_counter() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_ign_cyc_update_enable\n          in\n        BOOL\nIndicates start of ignition cycle\n                The function returns void.",
    "LLR.PLAT.PPR.IGNITION.105": "The function ppr_update_ign_cyc_counter() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.IGNITION.205": "The function ppr_update_ign_cyc_counter() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.IGNITION.006": "The function  shall  update the ignition cycle count in accordance with requirements LLR.PLAT.PPR.IGNITION.002,\n                LLR.PLAT.PPR.IGNITION.003 and LLR.PLAT.PPR.IGNITION.004 if the parameter pprf_ign_cyc_update_enable\n                is set to true, otherwise no action is taken.",
    "LLR.PLAT.PPR.IGNITION.013": "The platform shall provide a C interface function named\n                ppr_get_ign_cycle_count() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U16\n                with a value of:\n              U16 - The ignition cycle count.",
    "LLR.PLAT.PPR.IGNITION.113": "The function ppr_get_ign_cycle_count() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.IGNITION.213": "The function ppr_get_ign_cycle_count() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.IGNITION.014": "The function  shall  return the value of the ignition cycle count.",
    "LLR.PLAT.PPR.IGNITION.007": "The platform shall provide a Simulink interface block named\n                ppr_IgnitionCycle that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionupdateInportBoolean\n        \n          Set to 1 if the ignition cycle counter is to be incremented, set to zero otherwise.\n          Note that the platform's ignition cycle counter will be incremented only once per ignition cycle.  Therefore,\n          it is important that this inport is set to 0 before a new ignition cycle event occurs, if an ignition cycle counter update\n          is not required.\n        \n        \n          Range: 0 or 1\n        \n      ignition_cycle_countOutportInteger\n        \n          The value of the ignition cycle counter that is held by the platform.\n        \n        \n          Range: [0, 65535]",
    "LLR.PLAT.PPR.IGNITION.107": "The block ppr_IgnitionCycle shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.IGNITION.207": "The block ppr_IgnitionCycle shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.IGNITION.008": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.IGNITION.010": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPR.IGNITION.011": "The block  shall  update the ignition cycle count in accordance with\n                requirements LLR.PLAT.PPR.IGNITION.002, LLR.PLAT.PPR.IGNITION.003, LLR.PLAT.PPR.IGNITION.004 and LLR.PLAT.PPR.IGNITION.007.",
    "LLR.PLAT.PPR.IGNITION.012": "The block  shall  update the outport ignition_cycle_count\n                in accordance with requirement LLR.PLAT.PPR.IGNITION.007.",
    "LLR.PLAT.PPR.DENOMINATOR.001": "On startup, the platform  shall  retrieve the general denominator from non-volatile storage.",
    "LLR.PLAT.PPR.DENOMINATOR.014": "If PPR data was not succesfully retrieved from non-volatile storage, the platform  shall  reset the\n              general denominator to zero.",
    "LLR.PLAT.PPR.DENOMINATOR.002": "When requested by the application, the platform  shall  increment the general denominator by one.",
    "LLR.PLAT.PPR.DENOMINATOR.003": "If the general denominator reaches the maximum value of 65,535, the general denominator  shall  rollover and increment to zero on the next driving\n              cycle that meets the general denominator definition to avoid overflow problems.",
    "LLR.PLAT.PPR.DENOMINATOR.004": "The general denominator  shall  be incremented only once per drive cycle.",
    "LLR.PLAT.PPR.DENOMINATOR.005": "The platform shall provide a C interface function named\n                ppr_update_gen_denominator() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_gen_den_update_enable\n          in\n        BOOL\nIndicates whether the denominator has to be updated\n                The function returns void.",
    "LLR.PLAT.PPR.DENOMINATOR.105": "The function ppr_update_gen_denominator() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.DENOMINATOR.205": "The function ppr_update_gen_denominator() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.DENOMINATOR.006": "The function  shall  update the general  denominator in accordance with requirements LLR.PLAT.PPR.DENOMINATOR.002,\n                LLR.PLAT.PPR.DENOMINATOR.003 and LLR.PLAT.PPR.DENOMINATOR.004if the parameter pprf_gen_den_update_enable\n                is set to true otherwise no action is taken.",
    "LLR.PLAT.PPR.DENOMINATOR.012": "The platform shall provide a C interface function named\n                ppr_get_gen_denominator() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U16\n                with a value of:\n              The general denominator.",
    "LLR.PLAT.PPR.DENOMINATOR.112": "The function ppr_get_gen_denominator() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.DENOMINATOR.212": "The function ppr_get_gen_denominator() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.DENOMINATOR.013": "The function  shall  return the value of the general denominator.",
    "LLR.PLAT.PPR.DENOMINATOR.007": "The platform shall provide a Simulink interface block named\n                ppr_GeneralDenominator that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionupdateInportBoolean\n        \n          Set to 1 if the general denominator is to be incremented, set to zero otherwise.\n          Note that the platform's general denominator will be incremented only once per drive cycle.  Therefore,\n          it is important that this inport is set to 0 before a new drive cycle event occurs, if a general denominator update\n          is not required.\n        \n        \n          Range: 0 or 1\n        \n      general_denominatorOutportInteger\n        \n          The value of the general denominator that is held by the platform.\n        \n        \n          Range: [0, 65535]",
    "LLR.PLAT.PPR.DENOMINATOR.107": "The block ppr_GeneralDenominator shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.DENOMINATOR.207": "The block ppr_GeneralDenominator shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.DENOMINATOR.008": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.DENOMINATOR.009": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPR.DENOMINATOR.010": "The block  shall  update the general denominator in accordance with requirements LLR.PLAT.PPR.DENOMINATOR.002,\n                LLR.PLAT.PPR.DENOMINATOR.003, LLR.PLAT.PPR.DENOMINATOR.004 and LLR.PLAT.PPR.DENOMINATOR.007.",
    "LLR.PLAT.PPR.DENOMINATOR.011": "The block  shall  update the outport general_denominator\n                in accordance with requirement LLR.PLAT.PPR.DENOMINATOR.007.",
    "LLR.PLAT.PPR.MONITOR.002": "On startup, the platform  shall  retrieve the NVM data for each defined DME from non-volatile storage.",
    "LLR.PLAT.PPR.MONITOR.039": "If PPR data was not succesfully retrieved from non-volatile storage, the platform  shall  set each\n              DME's data to default values.",
    "LLR.PLAT.PPR.MONITOR.003": "When requested, the platform  shall  increment the number of times a DME has been run if the DME is enabled and the\n              application indicates that the DME has been run.",
    "LLR.PLAT.PPR.MONITOR.004": "When requested, the platform  shall  set the DME status to readiness complete if the DME is enabled and its run count\n              is equal to or exceeds the minmum value of count required.",
    "LLR.PLAT.PPR.MONITOR.005": "The platform  shall  force the DME status to readiness complete when requested by the application.\n            Note: \n              Ref Section 4.1.1 CARB OBD fro19711.pdf",
    "LLR.PLAT.PPR.MONITOR.006": "The platform  shall  force the DME status to readiness not complete when requested by the application.\n            Note: \n              Ref Section 4.1 CARB OBD fro19711.pdf",
    "LLR.PLAT.PPR.MONITOR.007": "When requested, the platform  shall  set the DME's status to completed if the DME is enabled and the application indicates that the DME has been run.\n            Note: \n              See ref J1979\/ISO-15031-5 PID $41 definition and CARB OBD Section 4.2.2, (C)\n            Note: \n              Later we may need to break this into two functions, one for all monitors and one for non-continuous ones only.",
    "LLR.PLAT.PPR.MONITOR.008": "When requested, the platform  shall  calculate and report a performance ratio for the desired DME in accordance\n              with requirements LLR.PLAT.PPR.RATIOS.001, LLR.PLAT.PPR.RATIOS.002, LLR.PLAT.PPR.RATIOS.003 and LLR.PLAT.PPR.RATIOS.004.\n            Note: \n              See section (d)(4.4.1) of fro19711.pdf for reference.",
    "LLR.PLAT.PPR.MONITOR.009": "When requested, if a DME has multiple DTEs that are required to report an IUPR, the platform  shall  report the ratio,\n              numerator and denominator of the DTE which has the lowest ratio.\n            Note: \n              (Ref CARB OBD section (D) 5.2.2)\n            \n              Only DTEs that are in use by the application will be considered in calculating the ratio.",
    "LLR.PLAT.PPR.MONITOR.010": "When requested, if two or more DTEs belonging to the same DME have identical ratios, the platform  shall  report the\n              ratio, numerator and denominator of the DTE that has the highest denominator.",
    "LLR.PLAT.PPR.MONITOR.040": "In C, DMEs  shall  be defined by appropriate definition of structures.\n            Note: \n              The detail of these structures is considered to be implementation, and as such should not be specified in requirements.",
    "LLR.PLAT.PPR.MONITOR.011": "The platform shall provide a C interface function named\n                ppr_update_dme_data() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dme_id\n          in\n        U8\nThe DME identifier for which the data is to be updatedpprf_monitor_run\n          in\n        BOOL\nIndicates whether the monitor has been run. When the application asks for forceful Readiness COMPLETE or NOT COMPLETE, the flag indicating whether the monitoring conditions for the DME are met (completed) is set depending on the value of this parameter.pprf_force_complete\n          in\n        BOOL\nIndicates whether the monitor has to be forced to COMPLETE readiness statusTRUE - indicates that the readiness status should be forced to COMPLETE independent of the number of times monitor has been run.FALSE - indicates that the readiness status has to be set depending on the number of times the monitor has been run and if it is enabled.\npprf_force_not_complete\n          in\n        BOOL\nIndicates whether the monitor has to be forced to NOT COMPLETE readiness statusTRUE - indicates that the readiness status should be forced to NOT COMPLETE independent of the number of times monitor has been run.FALSE - indicates that the readiness status has to be set depending on the number of times the monitor has been run and if it is enabled. Both pprf_force_complete and pprf_force_not_complete should not be set to TRUE in the same time.\npprf_monitor_enabled\n          in\n        BOOL\nIndicates whether the monitor is EnabledTRUE - indicates that the monitor is enabled.FALSE - indicates that the monitor is disabled for some reason.Readiness complete count will not be computed if the monitor is DISabled\n\n\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.MONITOR.111": "The function ppr_update_dme_data() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MONITOR.211": "The function ppr_update_dme_data() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITOR.012": "The function  shall  reject calls with both pprf_force_complete and pprf_force_not_complete set to true\n                and return PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.013": "The function  shall  check that pprf_dme_id exists and if not it  shall  return PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.014": "If the parameter pprf_force_complete is set to true then\n                the function  shall  set the DME's readiness complete status to true, its enabled\n                status to the value of input parameter pprf_monitor_enabled and its completed status to the value of input parameter pprf_monitor_run.\n                Otherwise, no action is taken.",
    "LLR.PLAT.PPR.MONITOR.015": "If the parameter pprf_force_not_complete is set to true then\n                the function  shall  set the DME's readiness complete status to false, its enabled\n                status to the value of input parameter pprf_monitor_enabled and its completed status to the value of input parameter pprf_monitor_run.\n                Otherwise, no action is taken.",
    "LLR.PLAT.PPR.MONITOR.016": "The function  shall  set the DME's readiness complete status to true if\n                parameter pprf_monitor_enabled is true and the\n                DME's run count is equal to or exceeds the readiness count limit.",
    "LLR.PLAT.PPR.MONITOR.017": "The function  shall  set the DME status to completed if parameter pprf_monitor_enabled\n                is true and parameter pprf_monitor_run is true.",
    "LLR.PLAT.PPR.MONITOR.018": "The platform shall provide a C interface function named\n                ppr_get_dme_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dme_id\n          in\n        U8\nThe DME for which data is neededpprf_dme_nv_data\n          in\/out\n        PPR_DME_NV_T *\nPointer to the DME data - which will be updated Cannot be NULL\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.MONITOR.118": "The function ppr_get_dme_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MONITOR.218": "The function ppr_get_dme_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITOR.019": "The function  shall  reject calls if pprf_dme_nv_data has\n                a NULL pointer by returning PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.020": "The function  shall  check that pprf_dme_id exists and if not it\n                 shall  return PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.021": "If the parameter checks pass then the function  shall  update pprf_dme_nv_data with the DME's\n                enabled, readiness complete and completed status.",
    "LLR.PLAT.PPR.MONITOR.022": "The platform shall provide a C interface function named\n                ppr_get_dme_ratio() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dme_id\n          in\n        U8\nThe DME for which the ratio, numerator and denominator data is neededpprf_dme_data\n          in\/out\n        PPR_DME_DATA_T *\nPointer to the DME data - which will be updated Cannot be NULL\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.MONITOR.122": "The function ppr_get_dme_ratio() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MONITOR.222": "The function ppr_get_dme_ratio() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITOR.023": "The function  shall  reject calls if pprf_dme_data has\n                a NULL pointer by returning PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.024": "The function  shall  check that pprf_dme_id exists and if not it\n                 shall  return PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.041": "If all the DTEs belonging to the requested DME are not in use, then the platform\n                 shall  return PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.MONITOR.025": "If the parameter checks pass then the function  shall  calculate the DME's performance ratio in accordance with the\n                requirements LLR.PLAT.PPR.MONITOR.008, LLR.PLAT.PPR.TEST.009 and LLR.PLAT.PPR.MONITOR.010.",
    "LLR.PLAT.PPR.MONITOR.026": "If the parameter checks pass then the function  shall  update pprf_dme_data with the DME's\n                numerator, denominator and calculated ratio.",
    "LLR.PLAT.PPR.MONITOR.027": "The platform shall provide a Simulink interface block named\n                ppr_DiagnosticMonitorEntity that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionmonitor_runInportBoolean\n        \n          Set to 1 if the monitor has run, set to zero otherwise.  This is used by the the platform to determine\n          the monitor completion and readiness status.  The platform increments the number of times a monitor has been run\n          on each 0 to 1 transition of this inport, provided that inport monitor_enabled is set to 1 and\n          force_complete and force_not_complete are both set to 0.\n        \n        \n          Range: 0 or 1\n        \n      force_completeInportBoolean\n        \n          Set to 1 to force the monitor readiness status to complete, independent of the number of times the\n          monitor has been run. Set to 0 otherwise.  The block responds on the rising edge of this inport.\n        \n        \n          Range: 0 or 1\n        \n      force_not_completeInportBoolean\n        \n          Set to 1 to force the monitor readiness status to incomplete, independent of the number of times the\n          monitor has been run. Set to 0 otherwise.  The block responds on the rising edge of this inport.\n        \n        \n          Range: 0 or 1\n        \n      monitor_enabledInportBoolean\n        \n          Set to 1 to indicate the monitor is enabled, 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      enabledOutportBoolean\n        \n          Set to 1 if the DME is enabled, set to 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      readiness_completeOutportBoolean\n        \n          Set to 1 if this DME's run count is greater than or equal to\n          its Readiness count limit parameter, set to 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      completedOutportBoolean\n        \n          Set to 1 if all monitoring conditions required for this DME have been tested\n          and a result has been obtained, set to 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      numeratorOutportInteger\n        \n          If there is only one DTE for this monitor then the numerator will be set to that DTE's specific\n          numerator.  If there is more than one DTE, then the value of this outport will be the\n          specific numerator corresponding to the lowest ratio found in the set of DTEs for this monitor.\n        \n        \n          Range: [0, 65535]\n        \n      denominatorOutportInteger\n        \n          If there is only one DTE for this monitor then the denominator will be set to that DTE's specific\n          denominator.  If there is more than one DTE, then the value of this outport will be the\n          specific denominator corresponding to the lowest ratio found in the set of DTEs for this monitor.\n        \n        \n          Range: [0, 65535]\n        \n      ratioOutportReal\n        \n          If there is only one DTE for this monitor then the ratio will be set to that DTE's specific\n          ratio.  If there is more than one DTE, then the value of this outport will be the\n          lowest ratio found in the set of DTEs for this monitor.\n        \n        \n          Range: [0.0, 7.99527]\n        \n      DME identifierParamInteger\n        \n          The unique identifier for this DME.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              Readiness count limitParamInteger\n        \n          The minimum number of times the monitor must be run before the monitor readiness status is set to complete.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              ISO Type?ParamBoolean\n        \n          If this box is checked then the parameters pertaining to ISO specific DMEs are available.\n          Note that a DME can be ISO type, J1939 type or both.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Monitor identifierParamInteger\n        \n          The ISO-15765 monitor identifier (OBDMID - see J1979 spec dated Sept 2010 appendix D).\n          It is used for reporting over ISO-15765 diagnostics in response to service $06.\n          Only available if the ISO Type? option is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              Monitor groupParamList\n        \n          A drop down to specify the ISO-15765 monitor group as described in J1979 spec dated Sept 2010 appendix G.\n          It is used for reporting performance ratio data over ISO-15765 diagnostics, in response to service $09.\n          Only available if the ISO Type? option is checked.\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              J1939 Type?Param-\n        \n          If this box is checked then the parameters pertaining to J1939 specific DMEs are available.\n          Note that a DME can be ISO type, J1939 type or both.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              \n              Value-type: incorrectly specified in user guide XML.\n            J1939 SPNParamInteger\n        \n          The value of the J1939 SPN for this DME.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PPR.MONITOR.127": "The block ppr_DiagnosticMonitorEntity shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.MONITOR.227": "The block ppr_DiagnosticMonitorEntity shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITOR.028": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.029": "If the parameter DME identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.030": "If the parameter Monitor identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.031": "If the parameter Readiness count limit is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.032": "If the parameter J1939 SPN is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.033": "If more than one ppr_DiagnosticMonitorEntity block exists in the model then the parameter DME identifier\n                is checked to see that it is only used in one block, if this is not the case then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.034": "If more than one ppr_DiagnosticMonitorEntity block exists in the model then the parameter Monitor identifier\n                is checked to see that it is only used in one block, if this is not the case then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.035": "If more than one ppr_DiagnosticMonitorEntity block exists in the model then the parameter J1939 SPN\n                is checked to see that it is only used in one block, if this is not the case then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITOR.036": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPR.MONITOR.037": "If any of the inports monitor_run,\n                force_complete, force_not_complete\n                monitor_enabled have changed state since the previous\n                schedule then the block  shall  update the DME's status in accordance with requirements LLR.PLAT.PPR.MONITOR.003,\n                LLR.PLAT.PPR.MONITOR.004, LLR.PLAT.PPR.MONITOR.005, LLR.PLAT.PPR.MONITOR.006,\n                LLR.PLAT.PPR.MONITOR.007 and LLR.PLAT.PPR.MONITOR.027.\n                Otherwise no action is taken.",
    "LLR.PLAT.PPR.MONITOR.038": "The block  shall  update the outports enabled,\n                readiness_complete, completed,\n                numerator,\n                denominator and ratio\n                in accordance with requirements LLR.PLAT.PPR.MONITOR.008, LLR.PLAT.PPR.MONITOR.009, LLR.PLAT.PPR.MONITOR.010 and LLR.PLAT.PPR.MONITOR.027.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.001": "When requested by the application software, the platform  shall  output the number\n              of monitors (DMEs) that are enabled and have a readiness status of not complete.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.002": "The platform shall provide a C interface function named\n                ppr_get_dme_incomplete_count() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U16\n                with a value of:\n              The number of enabled and incomplete monitors (DMEs)",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.102": "The function ppr_get_dme_incomplete_count() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.202": "The function ppr_get_dme_incomplete_count() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.003": "The platform  shall  return the number of monitors (DMEs) that are enabled and have\n                a readiness status of not complete.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.004": "The platform shall provide a Simulink interface block named\n                ppr_MonitorsIncomplete that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptioncountOutportInteger\n        \n          The count of the number of monitors (DMEs) that are enabled and incomplete.\n        \n        \n          Range: [0, 65535]\n        \n      Sample timeParamReal\n        \n          The periodicity of the block execution in seconds.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.104": "The block ppr_MonitorsIncomplete shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.204": "The block ppr_MonitorsIncomplete shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.005": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.006": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.007": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PPR.MONITORSINCOMPLETE.008": "The block  shall  update the outport count with\n                the number of DMEs that are enabled and have a readiness status of not complete.",
    "LLR.PLAT.PPR.TEST.002": "On startup, the platform  shall  retrieve the NVM data for each defined DTE from non-volatile storage.",
    "LLR.PLAT.PPR.TEST.003": "If PPR data was not succesfully retrieved from non-volatile storage, the platform  shall  set each\n              DTE's data to default values.",
    "LLR.PLAT.PPR.TEST.046": "For each of the defined DTEs, if the DTE data retrieved from non-volatile storage indicates a DTE status of\n              'test run this drive cycle', the platform  shall  set the DTE's test run status to 'test run'.\n            Note: \n              The NVM store will have the state set to 'test run this drive cycle' if the test has been run in the cycle\n              preceding this initialise.  So, after a successful restore from non-volatile storage at initialisation,\n              we must change the state to 'test run'.",
    "LLR.PLAT.PPR.TEST.004": "When requested, the platform  shall  set test value and min and max limits, for the desired DTE,\n              to the values supplied by the application.",
    "LLR.PLAT.PPR.TEST.005": "When requested by the application, the platform  shall  set the test run status to 'test not run',\n              reset the test value to an initial value (0) and the minimum & maximum limits to an initial value (0), for the desired DTE.\n            Note: \n              The source of this is section 8.6.1 of J1979 document dated Sept 2010 states that - After the monitor completes, (the application must)\n              update all Monitor ID\/Test ID combinations that were utilized by the monitor with appropriate passing or failing results.\n              If a test result was not utilized during the monitoring event, set the Test Values and Minimum and Maximum Test Limits to their initial values.\n              Test results from previous completed monitoring events must not be mixed with test results from current completed monitoring event.",
    "LLR.PLAT.PPR.TEST.006": "When requested, the platform  shall  set the test run status to 'test not run', reset the test value to an initial value (0)\n              and the minimum & maximum test limits to an initial value (0), for all of the defined DTEs in the platform.\n            Note: \n              The source of this is section 8.6.1 of J1979 document dated Sept 2010 states that - If an On-Board Diagnostic Monitor has not been completed at least\n              once since a 'Clear\/reset emission-related diagnostic information' request was carried out....., then the parameters Test Value (Results),\n              Minimum Test Limit, and Maximum Test Limit shall be set to zero values.",
    "LLR.PLAT.PPR.TEST.007": "When requested, the platform  shall  increment the specific numerator of the desired DTE by an integer of one.\n            Note: \n              The application should request this when every monitoring condition necessary for the monitor of the specific component to detect\n              a malfunction and store a pending fault code has been satisfied, including enable criteria, presence or absence of related fault codes,\n              sufficient length of monitoring time, and diagnostic executive priority assignments.\n              See section d (4.2) of fro19711.pdf for reference",
    "LLR.PLAT.PPR.TEST.008": "The numerator increment  shall  be permitted only once per drive cycle.",
    "LLR.PLAT.PPR.TEST.009": "The numerator  shall  have a minimum value of zero and a maximum value of 65,535 with a resolution of one.",
    "LLR.PLAT.PPR.TEST.010": "The numerator  shall  not be reset to zero under any circumstances including when a scan tool command to clear fault codes or reset Keep Alive Memory\n              is received.",
    "LLR.PLAT.PPR.TEST.011": "If the numerator reaches the maximum value of 65,535, both numerator and denominator  shall  be divided by 2.\n            Note: \n              Both numerator and denominator are divided by two to avoid the ratio from doubling.",
    "LLR.PLAT.PPR.TEST.012": "When requested, the platform  shall  increment the denominator of the desired DTE by an integer of one.",
    "LLR.PLAT.PPR.TEST.013": "The DTE denominator increment  shall  permitted only once per drive cycle.",
    "LLR.PLAT.PPR.TEST.014": "The DTE denominator  shall  have a minimum value of zero and a maximum value of 65,535 with a resolution of one.",
    "LLR.PLAT.PPR.TEST.015": "The DTE denominator  shall  not be reset to zero under any circumstances including when a scan tool command to clear fault codes or reset Keep Alive Memory  is received.",
    "LLR.PLAT.PPR.TEST.016": "If the DTE denominator reaches the maximum value of 65,535, both numerator and denominator  shall  be divided by 2.\n            Note: \n              Both numerator and denominator are divided by two to avoid the ratio from halving.",
    "LLR.PLAT.PPR.TEST.047": "In C, DTEs  shall  be defined by appropriate definition of structures.\n            Note: \n              The detail of these structures is considered to be implementation, and as such should not be specified in requirements.",
    "LLR.PLAT.PPR.TEST.017": "The platform shall provide a C interface function named\n                ppr_update_dte_data() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dte_id\n          in\n        U8\nThe DTE ID for which the N & R are to be updatedpprf_sp_den_update_enable\n          in\n        BOOL\nIndicates whether the Denominator is ready to be updatedpprf_sp_num_update_enable\n          in\n        BOOL\nIndicates whether the Numerator is ready to be updated\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.TEST.117": "The function ppr_update_dte_data() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.TEST.217": "The function ppr_update_dte_data() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.TEST.018": "The platform  shall  reject calls if a DTE corresponding to pprf_dte_id does not exist by\n                  returning PPR_RC_BAD_ARGS.  Otherwise it  shall  return PPR_RC_OK.",
    "LLR.PLAT.PPR.TEST.019": "If the parameter pprf_sp_den_update_enable is true then the denominator of the DTE, with ID\n                pprf_dte_id,  shall  be incremented\n                in accordance with requirements LLR.PLAT.PPR.TEST.012, LLR.PLAT.PPR.TEST.013,\n                LLR.PLAT.PPR.TEST.016.  Otherwise no action.",
    "LLR.PLAT.PPR.TEST.020": "If the parameter pprf_sp_num_update_enable is true then the numerator of the DTE, with ID\n                pprf_dte_id,  shall  be incremented\n                in accordance with requirements LLR.PLAT.PPR.TEST.007, LLR.PLAT.PPR.TEST.008,\n                and LLR.PLAT.PPR.TEST.011.  Otherwise no action.",
    "LLR.PLAT.PPR.TEST.021": "The platform shall provide a C interface function named\n                ppr_update_dte_test_value() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dte_id\n          in\n        U8\nThe DTE ID for which the test value is to be updatedpprf_test_value\n          in\n        U16\nThe test value, supplied by the applicationpprf_test_limit_min\n          in\n        U16\nThe minimum test limit for this test, supplied by the applicationpprf_test_limit_max\n          in\n        U16\nThe maximum test limit for this test, supplied by the applicationpprf_test_run\n          in\n        BOOL\nIndicates whether the test has been run and new values are available. If set to TRUE, the stored test values will be set to the values passed. If set to FALSE, the stored values will be left unchanged.pprf_reset_dte\n          in\n        BOOL\nIf set to TRUE, the stored test values will be reset. This will typically be used by the application when starting a new monitor cycle (see note). If set to FALSE, the stored values will be left unchanged. If both pprf_test_run and pprf_reset_dte are set TRUE, pprf_test_run takes precedence.\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.TEST.121": "The function ppr_update_dte_test_value() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.TEST.221": "The function ppr_update_dte_test_value() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.TEST.022": "The platform  shall  reject calls if a DTE corresponding to pprf_dte_id does not exist by\n                  returning PPR_RC_BAD_ARGS.  Otherwise it  shall  return PPR_RC_OK.",
    "LLR.PLAT.PPR.TEST.023": "If the parameter pprf_test_run is true, then the test value, test limit min and test limit max\n                of the DTE with ID pprf_dte_id  shall  be updated with the values in parameters\n                pprf_test_value, test_lim_min and test_lim_max respectively.",
    "LLR.PLAT.PPR.TEST.048": "If the parameter pprf_reset_dte is true and pprf_test_run is false, then the test value, test limit min and test limit max\n                of the DTE with ID pprf_dte_id  shall  be set to zero and the test run status set to 'test not run'.",
    "LLR.PLAT.PPR.TEST.024": "The platform shall provide a C interface function named\n                ppr_get_dte_status() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpprf_dte_id\n          in\n        U8\nThe DTE for which data is neededpprf_dte_nv_data\n          in\/out\n        PPR_DTE_NV_T *\nPointer to the DTE data - which will be updated Cannot be NULL\n                The function returns a value of type\n                PPR_RC_T\n                with a value of:\n              PPR_RC_BAD_ARGS - if the input parameters are invalidPPR_RC_OK - if operation is successful",
    "LLR.PLAT.PPR.TEST.124": "The function ppr_get_dte_status() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PPR.TEST.224": "The function ppr_get_dte_status() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.TEST.025": "The function  shall  reject calls if pprf_dte_nv_data has\n                a NULL pointer by returning PPR_RC_BAD_ARGS.",
    "LLR.PLAT.PPR.TEST.026": "The platform  shall  reject calls if a DTE corresponding to pprf_dte_id does not exist by\n                  returning PPR_RC_BAD_ARGS.  Otherwise it  shall  return PPR_RC_OK.",
    "LLR.PLAT.PPR.TEST.027": "If the parameter checks pass then the function  shall  update pprf_dte_nv_data with the DTE's\n                numerator, denominator, test value, test limit min, test_lim_max, numerator updated this cycle flag,\n                denominator updated this cycle flag, and test run status flag.",
    "LLR.PLAT.PPR.TEST.028": "The platform shall provide a Simulink interface block named\n                ppr_DiagnosticTestEntity that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionnumerator_updateInportBoolean\n        \n          Set to 1 if the numerator for this DTE is to be updated, set to zero otherwise.  The block responds to a rising edge\n          on this inport.  This is used by\n          the block to increment the specific numerator for the DTE.  Note that the DTE specific numerator will be\n          incremented only once per drive cycle.  Therefore, it is important that this inport is returned to level 0\n          before a new drive cycle event, if a numerator update\n          is not required.  The signal passed to this inport\n          should be connected to all DTEs which contain the same Monitor identifier in order that\n          the specific numerator is updated simultaneously for all those DTEs.\n        \n        \n          Range: 0 or 1\n        \n      denominator_updateInportBoolean\n        \n          Set to 1 if the denominator for this DTE is to be updated, set to zero otherwise.  The block responds to a rising edge\n          on this inport.  This is used by\n          the block to increment the specific denominator for the DTE.  The user should set this inport to 1 only\n          when every monitoring condition necessary for the monitor of the specific component to detect a malfunction\n          and store a pending fault code has been satisfied.  Note that the DTE specific denominator will be\n          incremented only once per drive cycle.  Therefore, it is important that this inport is returned to level 0\n          before a new drive cycle event, if a denominator update\n          is not required.  The signal passed to this inport\n          should be connected to all DTEs which contain the same Monitor identifier in order that\n          the specific denominator is updated simultaneously for all those DTEs.\n        \n        \n          Range: 0 or 1\n        \n      test_valueInportInteger\n        \n          The test value collected during the test.\n        \n        \n          Range: [0, 65535]\n        \n      test_limit_minInportInteger\n        \n          The threshold which the test value must be above in order to pass the test.\n        \n        \n          Range: [0, 65535]\n        \n      test_limit_maxInportInteger\n        \n          The threshold which the test value must be below in order to pass the test.\n        \n        \n          Range: [0, 65535]\n        \n      test_runInportBoolean\n        \n          Sets whether the test has been run at this time step.\n        \n        \n          When this input is 1, the block sets the test value and min and max limits for the DTE to the\n          values on inports test_value, test_limit_min and\n          test_limit_max respectively.\n          When this input is 0, the stored test value and min and max limits are held unchanged.\n          Note that this input is level-triggered and not edge-triggered.  This is required so that\n          results for continuously-monitored tests such as range checks on sensors may be\n          updated at every step.\n        \n        \n          Range: 0 or 1\n        \n      resetInportBoolean\n        \n          Sets whether the test is to be reset at this time step.\n        \n        \n          Set to 1 to cause the block to reset the test value, test min and test max\n          for this DTE to initial values of 0 and its test run status to 'test not run'.\n          Set to 0, otherwise.\n          Note that this input is level-triggered and not edge-triggered.  This is required so that\n          test results may be repeatedly reset if necessary.  Note also that test_run\n          takes precedence over this input.\n        \n        \n          Range: 0 or 1\n        \n      dte_numeratorOutportInteger\n        \n          The specific numerator for this DTE.  Used internally for calculation of the DME's In-Use\n          performance ratio which this DTE belongs to.\n        \n        \n          Range: [0, 65535]\n        \n      dte_denominatorOutportInteger\n        \n          The specific denominator for this DTE.  Used internally for calculation of the DME's In-Use\n          performance ratio which this DTE belongs to.\n        \n        \n          Range: [0, 65535]\n        \n      numerator_updated_this_dcOutportBoolean\n        \n          Set to 1 if the specific numerator for this DTE has been updated this drive cycle, set to 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      denominator_updated_this_dcOutportBoolean\n        \n          Set to 1 if the specific denominator for this DTE has been updated this drive cycle, set to 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      dte_test_valueOutportInteger\n        \n          The test value that the platform holds for this DTE.\n        \n        \n          Range: [0, 65535]\n        \n      dte_test_limit_minOutportInteger\n        \n          The test minimum threshold that the platform holds for this DTE.\n        \n        \n          Range: [0, 65535]\n        \n      dte_test_limit_maxOutportInteger\n        \n          The test maximum threshold that the platform holds for this DTE.\n        \n        \n          Range: [0, 65535]\n        \n      dte_test_run_statusOutportInteger\n        \n          The test run status that the platform holds for this DTE.\n          A value of 0 indicates that the test has never run.\n          A value of 1 indicates that a test has run on this drive cycle.\n          A value of 2 indicates that a test has run but not on this drive cycle.\n        \n        \n          Range: [0, 2]\n        \n      DTE identifierParamInteger\n        \n          The unique identifier for this DTE.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              DME identifierParamList\n        \n          The identity of the DME that this DTE belongs to.  For example, an Exhaust gas sensor monitor will have\n          a subset of DTEs.  This DTE needs to have a matching\n          DME identifier parameter with its parent DME.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              ISO Type?ParamBoolean\n        \n          If this box is checked then the parameters pertaining to ISO specific DTEs are available.\n          Note that a DTE can be ISO type, J1939 type or both.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              Monitor identifierParamInteger\n        \n          The ISO-15765 monitor identifier (OBDMID - see J1979 spec dated Sept 2010 appendix D) that this DTE\n          belongs to.  It is used for reporting over ISO-15765 diagnostics in response to service $06.\n          Only available if the ISO Type? option is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              ISO scaling identifierParamInteger\n        \n          This identifier is used to reference the scaling and unit to be used by the external test equipment\n          in order to calculate and display the test values (results), Minimum Test Limit, and the Maximum\n          for the DTE.  Only available if the ISO Type? option is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              ISO test identifierParamInteger\n        \n          The ISO specific test identifier (TID).  Only available if the ISO Type? option is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              J1939 Type?ParamBoolean\n        \n          If this box is checked then the parameters pertaining to J1939 specific DTEs are available.\n          Note that a DTE can be ISO type, J1939 type or both.\n        \n        \n          Range: 0 or 1\n        \n      \n                Calibratable: no.\n              J1939 test identifierParamInteger\n        \n          The J1939 specific test identifier (TID).  See J1939-73 Sept 2010 section 5.7.7.1 for details.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [0, 255]\n        \n      \n                Calibratable: no.\n              J1939 slot identifierParamInteger\n        \n          This is the scaling, limit, offset, and transfer function for the DTE.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [0, 64255]\n        \n      \n                Calibratable: no.\n              J1939 SPNParamInteger\n        \n          This is the SPN number associated with the DTE.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [0, 524287]\n        \n      \n                Calibratable: no.\n              J1939 FMIParamInteger\n        \n          This is the FMI number associate with the DTE.  See J1939-73 Sept 2010 Appendix A.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [0, 31]\n        \n      \n                Calibratable: no.\n              J1939 component identifierParamInteger\n        \n          This identifies the non-continuously monitored component identifier.  Component identifiers are\n          used to distinguish DTEs that have the same J1939 slot identifier\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [1, 64]\n        \n      \n                Calibratable: no.\n              DM10 bit positionParamInteger\n        \n          This is the bit position to set in a requested DM10 message response, to indicate test supported.\n          Refer to J1939-73 FEB2010 section 5.7.10 for details.  The assignment of a given test identifier\n          (as provided in the J1939 test identifier parameter) to a given bit position\n          is manufacturer specific.  This parameter is optional and may be left blank, in which case the\n          DM10 bit position will default to the value provided in the J1939 test identifier\n          parameter, provided it lies in the range specified below.\n          Only available if the J1939 Type? option is checked.\n        \n        \n          Range: [1, 64]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PPR.TEST.128": "The block ppr_DiagnosticTestEntity shall support the targets:\n            All targets.",
    "LLR.PLAT.PPR.TEST.228": "The block ppr_DiagnosticTestEntity shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PPR.TEST.029": "If the target does not support this block then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.030": "If the parameter DTE identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.031": "If the parameter Monitor identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.032": "If the parameter ISO test identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.033": "If the parameter ISO scaling identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.034": "If the parameter J1939 test identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.035": "If the parameter J1939 slot identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.036": "If the parameter J1939 SPN is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.037": "If the parameter J1939 FMI is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.038": "If the parameter J1939 component identifier is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.050": "If the parameter DM10 bit position is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.039": "If more than one ppr_DiagnosticTestEntity block is in the model then the parameter DTE identifier\n                is checked to see that it is only used in one block, if this is not the case them the block  shall  raise an error.",
    "LLR.PLAT.PPR.TEST.040": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PPR.TEST.041": "If inport numerator_update is true and has changed state since the previous\n                schedule then the block  shall  update the DTE's numerator in accordance with requirements\n                LLR.PLAT.PPR.TEST.007, LLR.PLAT.PPR.TEST.008,\n                LLR.PLAT.PPR.TEST.011 and LLR.PLAT.PPR.TEST.028.\n                Otherwise no action is taken.",
    "LLR.PLAT.PPR.TEST.042": "If inport denominator_update is true and has changed state since the previous\n                schedule then the block  shall  update the DTE's denominator in accordance with requirements\n                LLR.PLAT.PPR.TEST.012, LLR.PLAT.PPR.TEST.013,\n                LLR.PLAT.PPR.TEST.016 and LLR.PLAT.PPR.TEST.028.\n                Otherwise no action is taken.",
    "LLR.PLAT.PPR.TEST.043": "If inport test_run is true,\n                then the block  shall  mark the DTE's test run status as having run this drive cycle and update the DTE's test value, test limit min and test limit max to the values\n                presented at inports test_value,\n                test_limit_min, test_limit_max\n                and test_run respectively, in accordance with requirements LLR.PLAT.PPR.TEST.004\n                and LLR.PLAT.PPR.TEST.028.",
    "LLR.PLAT.PPR.TEST.049": "If inport reset is true and\n                inport test_run is false,\n                then the block  shall  reset the DTE's test value, test limit min and test limit max to zero, and test run status\n                to 'test not run', in accordance with requirement LLR.PLAT.PPR.TEST.005.  Otherwise, no action.",
    "LLR.PLAT.PPR.TEST.045": "The block  shall  update the outports dte_numerator,\n                dte_denominator,\n                numerator_updated_this_dc\n                denominator_updated_this_dc,\n                dte_test_value,\n                dte_test_limit_min,\n                dte_test_limit_max and\n                dte_test_run_status\n                with data held by the platform, in accordance with requirement LLR.PLAT.PPR.TEST.028.",
    "LLR.PLAT.PPR.RATIOS.001": "The ratio for a specific DTE  shall  be defined as specific numerator divided by the specific denominator.\n            Note: \n              See section (d)(4.4.1) of fro19711.pdf for reference.",
    "LLR.PLAT.PPR.RATIOS.002": "The ratio for a specific DTE  shall  have a minimum value of zero and a maximum value of 7.99527.",
    "LLR.PLAT.PPR.RATIOS.003": "The ratio for a specific DTE  shall  be considered to be zero whenever the corresponding numerator is equal to zero and the corresponding\n              denominator is not zero.",
    "LLR.PLAT.PPR.RATIOS.004": "The ratio for a specific DTE  shall  be considered to be the maximum value of 7.99527 if the corresponding denominator is zero or if the actual\n              value of the numerator divided by the denominator exceeds the maximum value of 7.99527.\n            Note: \n              See section (h)(5.1.2)(B) point (iv) of fro19711.pdf for reference.",
    "LLR.PLAT.REG.AVAIL.001": "The platform  shall  check if the registry is available by verifying the registry checksum during initialisation.",
    "LLR.PLAT.REG.AVAIL.002": "The platform  shall  provide the status of the registry availability upon request from the application.",
    "LLR.PLAT.REG.AVAIL.003": "The platform shall provide a C interface function named\n                preg_is_data_available() that takes\n                no parameters.\n              \n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if registry data available, false otherwise.",
    "LLR.PLAT.REG.AVAIL.103": "The function preg_is_data_available() shall support the targets:\n                      All targets.",
    "LLR.PLAT.REG.AVAIL.203": "The function preg_is_data_available() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.REG.AVAIL.004": "The platform  shall  return TRUE if the registry is available, and FALSE otherwise.",
    "LLR.PLAT.REG.READ.001": "The platform  shall  provide the status of the registry availability if the registry is\n                not available when a read is requested by the application.",
    "LLR.PLAT.REG.READ.002": "If the Registry Key Request of ECU Serial is requested, the platform  shall  return\n                the value of the ECU's serial number from the registry to the application.",
    "LLR.PLAT.REG.READ.003": "If the Registry Key Request of ECU date of manufacture is requested, the platform  shall  return\n                the value of the ECU's date of manufacture from the registry to the application.",
    "LLR.PLAT.REG.READ.004": "If the Registry Key Request of ECU engineering part number is requested, the platform  shall  return\n                the value of the ECU's engineering part number from the registry to the application.",
    "LLR.PLAT.REG.READ.005": "If the Registry Key Request of ECU PCB issue and modification number is requested, the platform  shall  return\n                the value of the ECU's hardware issue and mod number from the registry to the application.",
    "LLR.PLAT.REG.READ.006": "If the Registry Key Request of ECU factory part number is requested, the platform  shall  return\n                the value of the ECU's factory part number from the registry to the application.",
    "LLR.PLAT.REG.READ.007": "If the Registry Key Request of ECU factory part number build type is requested, the platform  shall  return\n                the value of the ECU's factory build type from the registry to the application.",
    "LLR.PLAT.REG.READ.008": "The platform shall provide a C interface function named\n                preg_retrieve_value_from_key() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpregf_key\n          in\n        PREG_KEY_T\nThe key to retrieve information about. Must be one of the PREG_KEY_T enumerations.pregf_value_buffer\n          out\n        void *\nA pointer to an object declared of suitable type for the key. The object is written with the data values related to the key if the key is found in the registry. \n\n The object for a key can be derived from the key enumeration literal. Keys that match PREG_KEY_* correspond to struct types named PREG_VALUE_*_T. \n\n For instance, if pregf_key is set to PREG_KEY_SERIAL_NUM then pregf_value_buffer must point to an object of type PREG_VALUE_SERIAL_NUM_T. \n Cannot be NULL.\n                The function returns a value of type\n                PREG_RC_T\n                with a value of:\n              PREG_RC_OK if value retrieved from registryanother enumeration from PREG_RC_T otherwise.",
    "LLR.PLAT.REG.READ.108": "The function preg_retrieve_value_from_key() shall support the targets:\n                      All targets.",
    "LLR.PLAT.REG.READ.208": "The function preg_retrieve_value_from_key() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.REG.READ.009": "If any of the input parameters are pointers to NULL then the\n                interface  shall  consider this an error and report this error using return code\n                PREG_RC_BAD_ARGS.",
    "LLR.PLAT.REG.READ.010": "The platform  shall  return a return code of PREG_RC_NOT_FOUND if the registry is\n                not available when a read is requested by the application.",
    "LLR.PLAT.REG.READ.011": "The platform  shall  return a return code of PREG_RC_INVALID_KEY if the\n                key that is requested is not supported, and the registry is available.",
    "LLR.PLAT.REG.READ.018": "The platform  shall  return a return code of PREG_RC_NOT_FOUND if the\n                key that is requested is supported, and the registry is available, but the key is not\n                present in the registry.",
    "LLR.PLAT.REG.READ.012": "For each supported Registry Key and pregf_key value given in the following table,\n                the platform  shall  set the application supplied buffer, pregf_value_buffer\n                to the value of the parameter read from the ECU registry.\n              Registry Keypregf_key valueApplication supplied buffer valueData typeECU SerialPREG_KEY_SERIAL_NUMserial numberPREG_VALUE_SERIAL_NUM_TECU date of manufacturePREG_KEY_DATE_OF_MANUFACTUREdate of manufacturePREG_VALUE_DATE_OF_MANUFACTURE_TECU engineering part numberPREG_KEY_ENG_PART_NUMengineering part numberPREG_VALUE_ENG_PART_NUM_TECU PCB issue and modification numberPREG_KEY_HW_ISSUE_MOD_NUMhardware issue and mod numberPREG_VALUE_HW_ISSUE_MOD_NUM_TECU factory part numberPREG_KEY_FACTORY_PART_NUMfactory part numberPREG_VALUE_FACTORY_PART_NUM_TECU factory part number buid typePREG_KEY_FACTORY_BUILD_TYPEfactory build typePREG_VALUE_FACTORY_BUILD_TYPE_T",
    "LLR.PLAT.REG.READ.013": "The platform shall provide a Simulink interface block named\n                preg_RetrieveKey that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_availableInportBoolean\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport available is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: 0 or 1\n        \n      sim_serialInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport serial is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [0, 4294967295]\n        \n      sim_shiftInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport shift is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [1, 3]\n        \n      sim_dayInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport day is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [1, 31]\n        \n      sim_monthInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport month is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [1, 12]\n        \n      sim_yearInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport year is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [1970, 3000]\n        \n      sim_prefixInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport prefix is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [0, 99]\n        \n      sim_idInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport id is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      sim_partInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport part is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [0, 999999]\n        \n      sim_issueInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport issue is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      sim_modInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport mod is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      sim_fpart_aInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outports fpart_a are set to the value of\n          these inports for simulation purposes.\n        \n        \n          Range: [0, 65535]\n        \n      sim_fpart_bInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outports fpart_b are set to the value of\n          these inports for simulation purposes.\n        \n        \n          Range: [0, 65535]\n        \n      sim_fid_aInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport fid_a is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: ['A', 'Z'] ASCII characters\n        \n      sim_fid_bInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport fid_b is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: ['A', 'Z'] ASCII characters\n        \n      sim_build_type_aInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport build_type_a is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: ['A', 'Z'] ASCII characters\n        \n      sim_build_type_bInportInteger\n        \n          Only used under simulation and when the parameter Provide simulation inports\n          is ticked. The outport build_type_b is set to the value of\n          this inport for simulation purposes.\n        \n        \n          Range: ['A', 'Z'] ASCII characters\n        \n      availableOutportBoolean\n        \n          Whether the key could be retrieved or not. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to zero.\n          The signal attached to the outport must be set as ExportedGlobal.\n        \n        \n          Range: 0 or 1\n        \n      serialOutportInteger\n        \n          The ECU's serial number. Outport available if the Registry key mask\n          parameter is set to ECU serial number. Under simulation, if the\n          Provide simulation inports parameter isn't ticked, the outport is set\n          to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 4294967295]\n        \n      shiftOutportInteger\n        \n          The team shift at the point of manufacture. Outport available if the\n          Registry key mask parameter is set to ECU date of\n          manufacture. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal attached to the\n          outport must be set as ExportedGlobal.\n        \n        \n          Range: [1, 3]\n        \n      dayOutportInteger\n        \n          The day of the month at the point of manufacture. Outport available if the\n          Registry key mask parameter is set to ECU date of\n          manufacture. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal attached to the\n          outport must be set as ExportedGlobal.\n        \n        \n          Range: [1, 31]\n        \n      monthOutportInteger\n        \n          The month of the year at the point of manufacture. Outport available if the\n          Registry key mask parameter is set to ECU date of\n          manufacture. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal attached to the\n          outport must be set as ExportedGlobal.\n        \n        \n          Range: [1, 12]\n        \n      yearOutportInteger\n        \n          The year at the point of manufacture. Outport available if the Registry key\n          mask parameter is set to ECU date of manufacture. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [1970, 3000]\n        \n      prefixOutportInteger\n        \n          The prefix of the engineering part number, e.g., 01 from\n          01T-068165. Outport available if the Registry key\n          mask parameter is set to ECU date of manufacture. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 99]\n        \n      idOutportInteger\n        \n          The letter of the engineering part number, e.g., T from\n          01T-068165. Outport available if the Registry key\n          mask parameter is set to ECU date of manufacture. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      partOutportInteger\n        \n          The remainder of the engineering part number, e.g., 068165 from\n          01T-068165. Outport available if the Registry key\n          mask parameter is set to ECU date of manufacture. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 999999]\n        \n      issueOutportInteger\n        \n          The ECU's PCB issue number, representing the PCB design. Outport available if the Registry key mask parameter is set to ECU PCB issue and modification\n          number. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal attached to the\n          outport must be set as ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      modOutportInteger\n        \n          The ECU's PCB modification number, representing hand modifications to the PCB to match the\n          PCB design intent. Outport available if the Registry key mask\n          parameter is set to ECU PCB issue and modification number. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      fpart_aOutportInteger\n        \n          The pre numerical part to the factory part number, which represents a detailed\n          build specification for the ECU. Outport available if the Registry key\n          mask parameter is set to ECU factory part number. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 65535]\n        \n      fpart_bOutportInteger\n        \n          The post numerical part to the factory part number, which represents a detailed\n          build specification for the ECU. Outport available if the Registry key\n          mask parameter is set to ECU factory part number. Under\n          simulation, if the Provide simulation inports parameter isn't ticked,\n          the outport is set to zero.  The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 65535]\n        \n      fid_aOutportInteger\n        \n          The first letter identifier that separates the pre and post factory part number. Outport\n          available if the Registry key mask parameter is set to ECU\n          factory part number. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal\n          attached to the outport must be set as ExportedGlobal.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      fid_bOutportInteger\n        \n          The second letter identifier that separates the pre and post factory part number. Outport\n          available if the Registry key mask parameter is set to ECU\n          factory part number. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal\n          attached to the outport must be set as ExportedGlobal.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      build_type_aOutportInteger\n        \n          The first letter of a two letter identifier representing the factory part number build type. Outport\n          available if the Registry key mask parameter is set to ECU\n          factory part number. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal\n          attached to the outport must be set as ExportedGlobal.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      build_type_bOutportInteger\n        \n          The second letter of a two letter identifier representing the factory part number build type. Outport\n          available if the Registry key mask parameter is set to ECU\n          factory part number. Under simulation, if the Provide simulation inports\n          parameter isn't ticked, the outport is set to zero.  The signal\n          attached to the outport must be set as ExportedGlobal.\n        \n        \n          Range: ['A', 'Z'] ASCII character\n        \n      Registry keyParamList\n        \n          A drop down to specify the registry key to retrieve.\n        \n        ECU serial\n                  The serial number is a 32-bit positive integer. Serial numbers across different\n                  families of ECUs do not overlap.\n                ECU date of manufacture\n                  The date is composed as (shift) dd:mm:yy, where the\n                  shift identifies the team involved in the manufacturing\n                  process.\n                ECU engineering part number\n                  The engineering part number matches the pattern: prefix letter\n                  engineering-part-number.  For instance, the engineering part number\n                  assigned to the M250-000 is 01T068165, where\n                  01 represents the prefix, T represents\n                  the letter and 068165 represents the engineering part number.\n                ECU PCB issue and modification number\n                  The issue level represents a specific design of PCB. Changes to the issue level\n                  may have an effect on the platform library.\n                \n                  The modification level represents what changes were performed to the PCB after\n                  manufacturing to correct issue level design mistakes. Changes to the modification\n                  level should not have an effect on the platform library.\n                ECU factory part number\n                  The identifier for the build specification used to create the ECU, matching the\n                  pattern value letter value, e.g., 450FT1024.\n                ECU factory part number build type\n                  An indication of the build type, usually appended to the factory part number, e.g.,\n                  450FT1024-E2, where E2 indicates second\n                  spec. engineering build.\n                \n      \n                Calibratable: no.\n              Provide simulation inportsParamBoolean\n        \n          Tick to enable simulation inports.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.REG.READ.113": "The block preg_RetrieveKey shall support the targets:\n            All targets.",
    "LLR.PLAT.REG.READ.213": "The block preg_RetrieveKey shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.REG.READ.014": "The block  shall  schedule itself to run with a constant sample time.",
    "LLR.PLAT.REG.READ.015": "For each Registry key value given in the following table,\n                if the Provide simulation inports is checked\n                the platform  shall  set the corresponding outports to the value of the corresponding inports from the table.\n              Registry KeyOutportsInportsECU Serialserialsim_serialECU date of manufactureshiftsim_shiftdaysim_daymonthsim_monthyearsim_yearECU engineering part numberprefixsim_prefixidsim_idpartsim_partECU PCB issue and modification numberissuesim_issuemodsim_modECU factory part numberfpart_asim_fpart_afpart_bsim_fpart_bfid_asim_fid_afid_bsim_fid_bECU factory part number build typebuild_type_asim_build_type_abuild_type_bsim_build_type_b",
    "LLR.PLAT.REG.READ.016": "The block  shall  set the outport available to TRUE,\n                if the registry key is available, and FALSE otherwise.",
    "LLR.PLAT.REG.READ.017": "For each Registry key value given in the following table,\n                the platform  shall  set the corresponding outports to the value of the parameter read from the ECU registry.\n              Registry Key RequestOutportsECU registry parameterAll Key Valuesavailableis registry availableECU Serialserialserial numberECU date of manufactureshiftshiftdaydaymonthmonthyearyearECU engineering part numberprefixprefixididpartpartECU PCB issue and modification numberissueissuemodmodECU factory part numberfpart_afpart_afpart_bfpart_bfid_afid_afid_bfid_bECU factory part number build typebuild_type_abuild type abuild_type_bbuild type b",
    "LLR.PLAT.PRG.ENTRY.001": "For MPC5534 and MPC5565 based ECUs, reprogramming mode  shall  declare in its header a\n              watchdog period of no more than 419.4 milliseconds and a processor clock frequency of\n              80 MHz (see [LLR.PLAT.PBT.INVOKE.002]).\n            Note: \n              A likely future enhancement would be to request a checksum of code and data belonging\n              to the reprogramming component.",
    "LLR.PLAT.PRG.ENTRY.002": "For MPC5674F based ECUs, reprogramming mode  shall  declare in its header a\n              watchdog period of no more than 508.4 milliseconds and a processor clock frequency of\n              264 MHz (see [LLR.PLAT.PBT.INVOKE.002]).",
    "LLR.PLAT.PRG.EXCEP.001": "When the processor takes an exception then reprogramming mode  shall  reset the\n              processor.",
    "LLR.PLAT.PRG.FCODE.001": "When reprogramming mode is invoked and the last reset was due to the watchdog,\n              reprogramming mode  shall  log the flash code '122'.",
    "LLR.PLAT.PRG.REPROG.001": "The reprogramming software  shall  support\n              the CCP protocol as described in\n              LLR.PLAT.PCP.CALBASE.001\n              for reprogramming the ECU.\n              TODO - The above link is also broken on the CR6166 branch.",
    "LLR.PLAT.PRG.REPROG.005": "The reprogramming software  shall  not drive any output\n              except the flash code output if available.\n            Rationale: \n              If the reprogramming software is entered accidentally,\n              the system must not drive any actuator. Applications may\n              use this property in their safety case analysis.\n              However, from an application point of view a fault has\n              already occurred if reprogramming mode is entered\n              unexpectedly. A defect in the reprogramming software\n              leading to unexpected output actuation would be a second\n              independent fault, a combination of very low\n              probability. Therefore this requirement does not imply\n              the reprogramming software requires the same SIL as\n              application.\"",
    "LLR.PLAT.PRG.REPROG.004": "On MPC5534 implementation, the reprogramming software  shall  accept\n              CLEAR_MEMORY,\n              PROGRAM, and\n              PROGRAM_6 commands in the following address ranges:\n            writable_flash:              origin = 0x00010000, length = 0x0EFFC0",
    "LLR.PLAT.PRG.J1939.001": "The programming software  shall  accept DM14 and DM16 messages only from a\n              Service Tool with a J1939 source address of 0xF9.",
    "LLR.PLAT.PRG.J1939.002": "The programming software  shall  send DM15 and DM16 message with a J1939\n              source address of 0x3D and priority of 6.",
    "LLR.PLAT.PRG.J1939.003": "The programming software  shall  send ACL (Address Claiming) messages with a J1939 NAME of:\n              Arbitrary Address Capable = 0, Industry Group = 0, Vehicle System Instance = 1, Function = 44,\n              Function Instance = 1, ECU Instance = 1, Manufacturer Code = 2047, Identity Number = 0,\n              Vehicle System = 127.",
    "LLR.PLAT.PRG.J1939.004": "If the method of entering reprogramming mode was from a jump from application,\n              the programming software  shall  automatically send an 'Operation Completed' DM15\n               message to acknowledge that the jump is completed.\n            Rationale: \n               This is required by J1939-73 section C.2.8 and C.2.9. After the DM15 'Operation\n               Completed' is sent by the ECU, the Service Tool is expected to acknowledge with\n               a DM14 'Operation Complete'. If the Service Tool doesn't do that, the ECU will\n               not do anything because it already considered the operation as completed.",
    "LLR.PLAT.PRG.J1939.005": "If a 'Boot Load' DM14 command is received and the ECU is in reprogramming mode,\n              the programming software  shall  respond to this command with a positive response\n               on a DM15 message. (A positive response is a 'Proceed' status followed by a\n               'Operation Complete' status).\n            Rationale: \n               This provides transparency to the Service Tool and it does not need to know which\n                mode is the ECU in.",
    "LLR.PLAT.PRG.J1939.006": "If an 'Erase' DM14 command with valid destination address and size is received and\n              the ECU is in reprogramming mode, the programming software  shall  erase the requested\n               memory and shall respond with a positive response on a DM15 message if the erase\n               succeeded. (Note that the programming software should validate the destination\n               address and size)\n            Rationale: \n               Erase commands need to be supported for a flash procedure. The erase commands should\n               be consecutive and all memory sections should first be erased before they are written.\n               It is recommended that the Service Tool will issue erase commands to exhaust all\n               available memory sections and only then it can start issuing write commands.",
    "LLR.PLAT.PRG.J1939.007": "If a 'Write' DM14 command with valid destination address and size is received and the\n              ECU is in reprogramming mode, the programming software  shall  wait for a DM16 data\n              message containing the data bytes to be written in memory.\n              (Note that the programming software should validate the destination address and size).\n            Rationale: \n               Memory Data Bytes are to be sent in DM16 messages but these messages are expected only\n               when a successful DM14 Write Command has been performed. If DM16 messages are received\n               prior or after to such command, they will be ignored by the programming software (However,\n               the J1939 stack will acknowledge their reception.)",
    "LLR.PLAT.PRG.J1939.008": "The programming software  shall  ignore received DM16 messages except when a 'Write' DM14 command\n               was previously received and acknowledged.\n            Rationale: \n               Memory Data Bytes are to be sent in DM16 messages but these messages are expected only\n               when a successful DM14 Write Command has been performed. If DM16 messages are received\n               prior or after to such command, they will be ignored by the programming software (However,\n               the J1939 stack will acknowledge their reception.)",
    "LLR.PLAT.PRG.J1939.009": "The programming software  shall  write ECU memory at the specified address and with the\n               specified size previously received in a DM14 message with the specified data bytes received\n               in a DM16 message and shall respond with a positive response on a DM15 message if the\n               write succeeded.\n            Rationale: \n               Write commands need to be supported for a flash procedure. When a write command is sent and\n               data bytes transferred, the programming software will write the bytes in memory at the desired\n               location.",
    "LLR.PLAT.PRG.J1939.010": "If a 'Read' DM14 command with valid destination address and size is received and the\n               ECU is in reprogramming mode, the programming software  shall  fetch the data from ECU\n               memory at the specified address and with the specified size and send it in a DM16 message\n               and then it shall respond with a positive response on a DM15 message if the read succeeded.\n               (Note that the programming software should validate the source address and size values).\n            Rationale: \n               Read commands are a good support for confirming that the flash succeded. The Service Tool\n               can use the read command to verify that memory has been written. Read command is also\n               supported because non-volatile memory read needs to be supported.",
    "LLR.PLAT.PRG.J1939.011": "If a 'Read' DM14 command with 'Pointer Type' equal to 'Directed Spacial Addressing' (0x01) is\n               received and the ECU is in reprogramming mode, the programming software  shall  access the\n               non-volatile memory space at the specified pointer and send the object data in a DM16 message\n               and it shall respond with a positive response on a DM15 message if the read succeeded.\n            Rationale: \n               Non-volatile memory (Object Space) is supported to retrieve J1939 SPNs from NVM memory during\n               manufacturing process. These SPNs can be written by an application and they are persistent in\n               memory even after an application wipe.",
    "LLR.PLAT.PRG.J1939.012": "The reprogramming mode  shall  allow a direct-memory 'Read' DM14 command of a size of up to\n              1784 data bytes at a time.\n              (Note the service tool needs to issue multiple read commands to read more than 1784 data bytes).\n            Rationale: \n               The data bytes read from memory are sent by DM16 messages. One DM16 message has a maximum length of\n               1785 byte (1784 data bytes and one control byte). Only one DM16 message can be sent in a read request\n               and therefore only 1784 data bytes can be read at a time.",
    "LLR.PLAT.PRG.J1939.013": "The programming software  shall  allow a spacial-memory (non-volatile) 'Read' DM14 command of a\n              size of up to one object at a time.\n              (Note the service tool needs to issue multiple read commands to read more objects).\n            Rationale: \n               Spacial objects (like SPNs) are variable-length (and up to 255 bytes in size). The programming software\n               does not support reading multiple objects in a single command because there is no delimiter between objects\n               specified in the standards and it would be significantly harder for a Servce Tool to determine where\n               one object ends and where the other one starts.",
    "LLR.PLAT.PRG.J1939.014": "The programming software  shall  support only SPN Space 'Pointer Extension' states in a DM14 'Read' command.\n            Rationale: \n              See J1939-73 section 5.7.14.2 for details on 'Pointer Extension' states.",
    "LLR.PLAT.PRG.J1939.030": "If a 'Write' DM14 command with 'Pointer Type' equal to 'Directed Spacial Addressing' (0x01) is\n               received and the ECU is in reprogramming mode, the programming software  shall  deny this access\n               and respond with a DM15 'Busy' status.\n            Rationale: \n               Non-volatile memory (Object Space) is read-only in the bootloader.",
    "LLR.PLAT.PRG.J1939.015": "The programming software  shall  allow a 'Write' DM14 command of a size of up to\n              1784 data bytes at a time.\n            Rationale: \n              The data bytes written to memory are sent by DM16 messages. One DM16 message has a maximum length of\n              1785 bytes (1784 data bytes and one control byte). Only one DM16 message should be received in a write\n              request and therefore only 1784 data bytes can be written at a time. Multiple consecutive DM16\n              messages can be supported (in cases where the Service Tool does not support Transport Protocol) but it\n              is not recommended because PCAN feature overwrites consecutive DM16 messages and if they arrive with a\n              frequency faster than the PCAN can read, messages can be lost and there is no easy way to detect that.",
    "LLR.PLAT.PRG.J1939.016": "If a 'Status Request' DM14 command is received and the ECU is in reprogramming mode,\n              the programming software  shall  respond with a DM15 message containing the last status\n              of the previous operation.\n            Rationale: \n              Status Request is a good indication on whether and how the ECU finished the last operation.\n              However, it is not required to support a status request while the ECU is in the middle of\n              an operation - this might cause the ECU to abort the operation just to respond to the Service Tool\n              what is the status. Baed on J1939-73 standards, the status request should be required in a\n              'close sequence'.",
    "LLR.PLAT.PRG.J1939.017": "If an 'Operation Complete' or 'Operation Failed' DM14 command is received and the ECU is in\n              reprogramming mode, the programming software  shall  clear the status of the previous operation.\n            Rationale: \n                A close sequence should always wipe the status of the operation because at that point, the\n                operation is considered done.",
    "LLR.PLAT.PRG.J1939.018": "If an 'EDCP Generation' DM14 command is received and the ECU is in reprogramming mode, the\n              programming software  shall  respond with a 'Busy' status DM15 message and 'EDCP Extension' set to\n              'Data in Error Indicator\/EDC Parameter is an Error Indicator' (0x06) and the 'Error Indicator'\n              set to 'Internal Failure Preventing Request' (0x24) indicating that this command is not supported.\n            Rationale: \n                At this point, this command is not supported.",
    "LLR.PLAT.PRG.J1939.019": "If any requested DM14 command fails, the programming software  shall  respond with a negative\n              response. (A negative response is an 'Operation Failed' status on a DM15 message).\n            Rationale: \n               Unsuccessful operations are terminated by a negative response. The Service Tool should consider\n               this a failure and should repeat the last command or abort.",
    "LLR.PLAT.PRG.J1939.020": "If the destination address ('Pointer' combined with 'Pointer Extension' per J1939-73 specification,\n              sections 5.7.14.1, 5.7.14.2 and 5.7.14.3) in the 'Erase', 'Write' and 'Read' DM14 commands is\n              determined by the programming software to be an address that is outside of the memory bounds of\n              the ECU memory, the programming software  shall  ignore the command and shall send a DM15 'Busy'\n              response with 'EDCP Extension' set to 'Data in Error Indicator\/EDC Parameter is an Error Indicator'\n              (0x06) and the 'Error Indicator' set to an appropriate error code defined by the J1939-73\n              specification section 5.7.15.3.\n            Rationale: \n               Reading, writing or erasing outside of the ECU's memory bounds is not allowed.",
    "LLR.PLAT.PRG.J1939.021": "If the destination address ('Pointer' combined with 'Pointer Extension' per J1939-73\n              specification, sections 5.7.14.1, 5.7.14.2 and 5.7.14.3) added with the size ('Length\/Number\n              Requested' per J1939-73 specification, section 5.7.14.5) in the 'Erase', 'Write' and 'Read'\n              DM14 commands is determined by the programming software to be outside of the memory bounds\n              of the ECU memory but the destination address alone is within memory bounds, the\n              reprogramming software  shall  adjust the allowed size and shall send a DM15 'Proceed'\n              response with 'EDCP Extension' set to 'Data in Error Indicator\/EDC Parameter is an Error\n              Indicator' (0x06) and the 'Error Indicator' set to an appropriate error code defined by the\n              J1939-73 specification section 5.7.15.3 and the 'Length\/Number Allowed' set to the adjusted\n              size. (see J1939-73 section C.2.2.2).\n            Rationale: \n               Reading, writing or erasing outside of the ECU's memory bounds is not allowed.",
    "LLR.PLAT.PRG.J1939.029": "If the data length in a received DM16 message is not equal with the length sent in a DM15 'Proceed'\n              acknowledge for a 'Write' command, the programming software  shall  cancel the write to memory request\n              and send a DM15 'Operation Failed' response with 'EDCP Extension' set to 'Data in Error Indicator\/EDC\n              Parameter is an Error Indicator' (0x06) and the 'Error Indicator' set to 'Data Error - data does not\n              conform to the expected or allowed value ranges' (0x109).\n            Rationale: \n              The data length in DM16 messages needs to be equal with the requested or adjusted length previously established\n              in the DM14, DM15 handshake.",
    "LLR.PLAT.PRG.J1939.023": "On a MPC5534 target, the programming software  shall  accept memory read, write and erase\n              J1939 commands on the following address range: 0x10000 to 0xFFFC0.\n            Rationale: \n                Other ranges are not allowed to be written and erased because they will corrupt the\n                programming software. However, read commands are allowed to read a wider range but this\n                should not be stated explicitely because it can be disallowed at a later time due to the\n                programming software confidentiality.",
    "LLR.PLAT.PRG.J1939.024": "If the method of entering reprogramming mode was from a jump from application, the programming\n              software  shall  wait for an 'Operation Completed' DM14 command for no longer than 125 ms.\n            Rationale: \n                This is the wait time for an operation closure. See J1939-73 section C.2.8.1 (rev FEB2010).",
    "LLR.PLAT.PRG.J1939.025": "The programming software  shall  wait for a key to be transmitted in a DM14 command for no\n              longer than T1 time. T1 is defined by J1939-21 specifications section 5.10.2.4 (rev DEC2010)\n              and is equal to 750 ms.\n            Rationale: \n                See also J1939-73 section figure E1 (rev FEB2010).",
    "LLR.PLAT.PRG.J1939.026": "The programming software  shall  wait for a complete DM16 message to be received after a DM14\n              'Write' command, no longer than 13 times T2. T2 is defined by J1939-21 specifications section\n              5.10.2.4 (rev DEC2010) and is equal to 1250 ms.\n            Rationale: \n                The Noregon stack is handling the Transport protocol time-outs. According to J1939-73 Figure E1 (rev FEB2010)\n                there is a T2 time-out between 'Proceed' and RTS. Since there could be as many as 13 RTS\/CTS handshakes in a\n                DM16 message (each handshake agreeing for 21 packets (this is the current maximum)), it makes sense to consider\n                that it will take no longer than 13 * T2 to receive an entire DM16 message. However, there is a maximum time allowed\n                by the J1939 standards between data packets (T1) which is not taken in consideration. If this time would have been\n                taken into consideration, the maximum time allowed for a DM16 message to be received would have to be in the\n                order of minutes.",
    "LLR.PLAT.PRG.J1939.027": "If a time-out occurs by waiting for a key value to be transmitted in a DM14 command,\n              the programming software  shall  send a 'Busy' DM15 status with 'EDCP Extension' set to\n              'Data in Error Indicator\/EDC Parameter is an Error Indicator' (0x06) and the 'Error\n              Indicator' set to 'NO response in the time allowed' and it shall return to waiting for\n              new commands.\n            Rationale: \n              Unlike the platform software, the PRG software does not implement a retry mechanism for\n              the seed\/key exchange because of space constaints and to keep the algorithm simple.\n              Moreover, a seed\/key exchange in the PRG occurs only if there was something wrong or if\n              the method of entering bootloader was different than a jump from the application (which is\n              a rare situation outside bench testing). Also see J1939-73 section C.2.2.4 (rev FEB2010).",
    "LLR.PLAT.PRG.J1939.028": "If a time-out occurs by waiting for a DM16 message to be completely transmitted, the programming\n              software  shall  send an 'Operation Failed' DM15 status with 'EDCP Extension' set to 'Data in Error\n              Indicator\/EDC Parameter is an Error Indicator' (0x06) and the 'Error Indicator' set to either 'NO\n              response in the time allowed' if the expected DM16 message had a data length less than or equal to\n              7 bytes or 'Transport of data NOT completed within the time allowed' if the expected DM16 message\n              had a data length higher than 7 bytes and it shall return to waiting new commands.\n            Rationale: \n               It is considered that when a DM16 is transfer is waited that proper handshake already took place\n               using DM14 and DM15 and therefore an operation can begin. However, if the transfer does not succeed,\n               the operation needs to be deemed failed (that's why a 'Busy' status is not appropriate here).\n               The error indicatior needs to be appropriate based on the size of the DM16 message for the Service\n               Tool to properly diagnose the problem.",
    "LLR.PLAT.PRG.J1939security.001": "The programming software  shall  implement a security algorithm that generates a random\n                2-byte seed.\n            Rationale: \n                The seed values need to be compliant with the Seed requirements in the\n                J1939-73 specification section 5.7.15.4.",
    "LLR.PLAT.PRG.J1939security.002": "The programming software  shall  implement a security algorithm function that\n                calculates a 2-byte key based on an arbitrary 2-byte seed.\n            Rationale: \n                The key values need to be compliant with the Key requirements in the J1939-73 specification\n                section 5.7.14.4",
    "LLR.PLAT.PRG.J1939security.003": "The 2-byte Seed values  shall  be generated on the DM15 message.\n            Rationale: \n                Security algorithms need to be compliant with the J1939 security standards.",
    "LLR.PLAT.PRG.J1939security.004": "The 2-byte Key values  shall  be expected on a DM14 message.\n            Rationale: \n                Security algorithms need to be compliant with the J1939 security standards.",
    "LLR.PLAT.PRG.J1939security.005": "If security is required, the programming software  shall  deny the current DM14\n                command if the received Key mismatches a previously generated Seed.\n            Rationale: \n                Access is allowed only on a matching Seed\/Key pair.",
    "LLR.PLAT.PRG.J1939security.006": "If security is required, the programming software  shall  allow the current DM14\n               command only if a received Key matches a previously generated Seed and it shall\n               deem the security credentials to be established.\n            Rationale: \n                Access is allowed only on a matching Seed\/Key pair.",
    "LLR.PLAT.PRG.J1939security.007": "If security credentials have been previously established, the programming software\n                shall  not require any more security (Seed\/Key exchanges) for future DM14 commands\n               except when:\n            \n                    A reset occurred OR\n                  \n                    A time-out occurred and the method of entering reprogramming mode was\n                    different from a jump from application OR\n                  \n                    A requested operation failed and the method of entering reprogramming\n                    mode was different from a jump from application (per the J1939-73 section C.2.8.4);\n                  Rationale: \n                Security credentials are reset only when the method of entering bootloader was different\n                than an execution jump from the application. This happens because if the application\n                disables J1939 security, the bootloader shall not be able to reenable it back.",
    "LLR.PLAT.PRG.J1939security.008": "If security credentials have never been established and the method of entering\n              reprogramming mode was different than a jump from application, the programming\n              software  shall  generate a Seed on a DM15 message for any command received on\n              the DM14 message until the security credentials are established.\n            Rationale: \n                Access is allowed only on a matching Seed\/Key pair for any DM14 command.",
    "LLR.PLAT.PRG.J1939security.009": "If security credentials were previously established and the method of entering\n              reprogramming mode was from a jump from application, the programming software  shall \n              generate a Seed value of 'No further key required of Tool' (0xFFFF) or 'Seed Completed'\n              (0x0000) (per the J1939-73 specifications) on all the DM15 messages for any command\n              received on the DM14 message.\n            Rationale: \n               When no more security is required Seed values should not be generated anymore.",
    "LLR.PLAT.PRG.ISO.001": "By default the platform  shall  allow ISO flash reprogramming if ISO diagnostics\n              has been enabled by the application.\n            \n              \n                Note: this follows the same model as CCP reprogramming.",
    "LLR.PLAT.PRG.ISO.002": "The platform  shall  provide a function for application use to turn programming\n              on or off.\n            \n              \n                Note: this is so that the application can (for example) disallow flash\n                reprogramming when a vehicle engine is running.",
    "LLR.PLAT.PRG.ISO.003": "See:\n              0x10 StartDiagnosticSession (KW2000-3) ; DiagnosticSessionControl(UDS)",
    "LLR.PLAT.PRG.ISO.004": "On transition from the application software to the boot loader, the platform\n               shall  provide the boot loader with the current CAN settings in use for the\n              diagnostic session.\n            Rationale: \n              The boot loader can then continue talking to the test tool using whatever\n              settings were defined by the application. This avoids the boot loader requiring\n              customisation for particular applications, especially (as in Quantum) where two\n              OpenECUs are present in the same vehicle, using different CAN IDs.",
    "LLR.PLAT.PRG.ISO.005": "The boot loader  shall  copy the settings described above to a reserved\n              area of NVM so that it can use them even after erasing the application should\n              an unexpected power cycle occur.",
    "LLR.PLAT.PRG.ISO.006": "On transition from the application software to the boot loader, the platform\n               shall  provide the boot loader with the currently supported PIDs and their\n              values.\n            Rationale: \n              This allows the application to define PIDs such as part numbers which the boot\n              loader will later be required to report to the programming tool, without the\n              boot loader requiring customisation for the particular application.",
    "LLR.PLAT.PRG.ISO.007": "The boot loader  shall  make a copy of the PID information (including the current\n              values of each PID) in a reserved area of NVM, so a static snapshot of the values\n              current at the time the application exited can be reported.",
    "LLR.PLAT.PRG.ISO.008": "The boot loader  shall  respond to some PIDs by itself (e.g. current diagnostic session\n              type) as special cases.",
    "LLR.PLAT.RPRG.ISO.001": "The platform  shall  support the KW2000-3 SecurityAccess (0x27) request from the diagnostic tool.",
    "LLR.PLAT.RPRG.ISO.002": "The platform  shall  support the KW2000-3 RoutineControl (0x31) request from the diagnostic tool.",
    "LLR.PLAT.RPRG.ISO.003": "The platform  shall  support the KW2000-3 RoutineControl (0x31) request only for Start of routines\n              EraseMemory (0xFF00), CheckProgrammingDependencies (0xFF01) and CheckMemory (0x0202) in reprogramming mode only. If requested\n              in application mode, the platform shall return a RequestOutOfRange error (0x31) response.\n            Rationale: \n               HIS spec disallows this in application mode.",
    "LLR.PLAT.RPRG.ISO.021": "The platform  shall  support the KW2000-3 RoutineControl (0x31) request for Start of CheckProgrammingPreconditions (0x0203).",
    "LLR.PLAT.RPRG.ISO.022": "If the ECU is in default diagnostic session when a KW2000-3 RoutineControl (0x31) request for Start of routines\n              EraseMemory (0xFF00), CheckProgrammingDependencies (0xFF01), CheckMemory (0x0202) or CheckProgrammingPreconditions (0x0203)\n              is received, the platform  shall  return a ConditionsNotCorrect (0x22) error response.\n            Rationale: \n               HIS spec disallows this in Default diagnostic session.",
    "LLR.PLAT.RPRG.ISO.023": "If the KW2000-3 RoutineControl (0x31) request for Start of routines EraseMemory (0xFF00), CheckProgrammingDependencies (0xFF01),\n              CheckMemory (0x0202) or CheckProgrammingPreconditions (0x0203) is of incorrect length, the platform  shall  return a\n              IncorrectMessageLength (0x13) error response.",
    "LLR.PLAT.RPRG.ISO.024": "If the KW2000-3 RoutineControl (0x31) request received for routines EraseMemory (0xFF00), CheckProgrammingDependencies (0xFF01),\n              CheckMemory (0x0202) or CheckProgrammingPreconditions (0x0203) has control parameter other than 'Start', the platform  shall  return a\n              SubFunctionNotSupported (0x12) error response.",
    "LLR.PLAT.RPRG.ISO.025": "The platform  shall  support the KW2000-3 RoutineControl (0x31) request for Start of routine EraseMemory only\n              when secure access has been granted (via service 0x27); otherwise the platform shall return a\n              SecurityAccessDenied (0x33) error response.",
    "LLR.PLAT.RPRG.ISO.004": "Upon receipt of a valid KW2000-3 RoutineControl (0x31) request for routine EraseMemory, the platform\n               shall  erase the memory block as per request. Prior to the erase being performed, a pending response\n              shall be sent. If successful, the platform shall send a positive response as needed\n              by the request format used; otherwise it shall return a TransferAborted (0x72) error response.",
    "LLR.PLAT.RPRG.ISO.026": "Upon receipt of a valid KW2000-3 RoutineControl (0x31) request for routine CheckMemory, the platform\n               shall  calculate CRC for data defined in the previous RequestDownload request for reprogramming.\n              The platform shall always send a positive response with the CRC result in the response.",
    "LLR.PLAT.RPRG.ISO.027": "Upon receipt of a valid KW2000-3 RoutineControl (0x31) request for routine CheckProgrammingDependencies,\n              the platform  shall  always send a positive response.\n            Rationale: \n               If in fact either the application or the calibration area were not downloaded, subsequent startup\n               checksums (or repeated reset catch) should leave us in the boot loader anyway.",
    "LLR.PLAT.RPRG.ISO.028": "Upon receipt of a valid KW2000-3 RoutineControl (0x31) request for routine CheckProgrammingPreconditions,\n              the platform  shall  always send a positive response that shall include 'control active' (0x06) byte if\n              ECU does not allow reflash.\n            Rationale: \n               HIS-UDS spec offers a list of constants for engine running, too hot, etc, but we only know if the application allows reflash or not,\n               so have chosen a generic option fairly arbitrarily here.",
    "LLR.PLAT.RPRG.ISO.005": "The platform  shall  support the KW2000-3 ECU Reset (0x11), RequestDownload (0x34), TransferData (0x36) and RequestTransferExit (0x37) requests\n              in reprogramming mode only when secure access has been granted (via service 0x27).",
    "LLR.PLAT.RPRG.ISO.006": "The platform  shall  support the KW2000-3 ECU Reset (0x11), RequestDownload (0x34), TransferData (0x36)\n               and RequestTransferExit (0x37) requests only when the service requests are physically addressed.\n            Rationale: \n               These actions have to take place on a particular ECU.",
    "LLR.PLAT.RPRG.ISO.007": "The platform  shall  not service any other request from the diagnostic tool while it is servicing the\n              KW2000-3 RequestDownload (0x34) request and shall return a ConditionsNotCorrect (0x22) error response.\n            Rationale: \n               These actions have to take place on a particular ECU.",
    "LLR.PLAT.RPRG.ISO.008": "The platform  shall  only support download of uncompressed and unencrypted data. Any other setting for\n              the data compression and encryption in the request message shall result in a RequestOutOfRange error (0x31).",
    "LLR.PLAT.RPRG.ISO.020": "The platform  shall  only support request to transfer data into valid memory areas for flash programming.\n              Any other address range in the request message shall result in a RequestOutOfRange error (0x31).",
    "LLR.PLAT.RPRG.ISO.009": "If a download is already in progress at the time of this request, then the platform  shall  signal a ConditionsNotCorrect error (0x22).",
    "LLR.PLAT.RPRG.ISO.010": "The platform  shall  expect the data bytes to be downloaded onto the ECU as the request parameters of the TransferData request.",
    "LLR.PLAT.RPRG.ISO.011": "If a block sequence counter in the TransferData request is out of sync, then the platform  shall  signal a\n              WrongBlockSequenceCounter error (0x73) and abort the transfer.",
    "LLR.PLAT.RPRG.ISO.012": "If the total number of bytes in the sequence of TransferData requests is greater than that specified in\n              the RequestDownload request, then the platform  shall  signal a IncorrectMessageLength error (0x13) and abort the transfer.",
    "LLR.PLAT.RPRG.ISO.013": "If the TransferData request is received without an earlier request for RequestDownload,\n              then the platform  shall  report a requestSequenceError (0x24) error.",
    "LLR.PLAT.RPRG.ISO.014": "The platform  shall  discard any downloaded data and abort download when the error specified in\n              [LLR.PLAT.RPRG.ISO.011] or [LLR.PLAT.RPRG.ISO.012] is signalled.",
    "LLR.PLAT.RPRG.ISO.015": "Upon receipt of RequestTransferExit service, if total number of data bytes downloaded does not match\n              that specified in the RequestDownload request, the platform  shall  report a requestSequenceError (0x24) error.",
    "LLR.PLAT.RPRG.ISO.016": "If the RequestTransferExit request is received when a download is not in progress,\n              then the platform  shall  report a requestSequenceError (0x24) error.",
    "LLR.PLAT.RPRG.ISO.017": "Upon receipt of valid RequestDownload request the platform  shall  initiate flash reprogramming, and report\n              a positive response with the maximum number of bytes that it can handle per TransferData request if successful.",
    "LLR.PLAT.RPRG.ISO.018": "Upon receipt of valid TransferData request the platform  shall  transfer the required data for flash reprogramming, and report\n              a positive response with the next expected block sequence counter if successful.",
    "LLR.PLAT.RPRG.ISO.019": "Upon receipt of valid RequestTransferExit request the platform  shall  calculate the CRC of the downloaded data, and\n              report a positive response with the CRC if successful.",
    "LLR.PLAT.PSC.LIC.002": "If the signature is invalid, the platform  shall  continue into non-valid license sequence.",
    "LLR.PLAT.PSC.LIC.005": "If the signature is valid, the ECU  shall  continue into the feature decoding sequence.",
    "LLR.PLAT.PSC.LIC.003": "As part of the non-valid signature sequence, if the firmware on the ECU is version 2.1.3 or newer, psc  shall \n              reset into reprogramming mode with the \u201cinvalid license\u201d flash code.",
    "LLR.PLAT.PSC.LIC.004": "As part of the non-valid signature sequence, if the firmware on the ECU is version 2.1.2 or older, psc  shall \n              flash the \"invalid license\" flash code one full time, then reset into reprogramming mode and flash the \"no\n              valid app\" flash code.\n            Rationale: \n              In version 2.1.3, a new flashcode was added to the boot code to indicate invalid\n              license,  if the application runs with older firmware, then it cannot flash that sequence in prg.\n              (See [LLR.PLAT.PFC.FL.012])",
    "LLR.PLAT.PSC.LIC.006": "If a library function that depends on the extended diagnostics platform feature is called and the first\n              value in the feature array is equal to 0x5A, then that function  shall  behave with its primary behaviour.",
    "LLR.PLAT.PSC.LIC.007": "If a library function that depends on the extended diagnostics platform feature is called and the first\n              value in the feature array is not equal to 0x5A, then that function  shall  behave with its \"no license\"\n              behaviour.",
    "LLR.PLAT.PSC.CPULOAD.001": "The platform shall provide a C interface function named\n                psc_get_cpu_loading() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U8\n                with a value of:\n              The last calculated CPU loading. \n Range: [0, 100] %",
    "LLR.PLAT.PSC.CPULOAD.101": "The function psc_get_cpu_loading() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.CPULOAD.201": "The function psc_get_cpu_loading() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.CPULOAD.002": "The CPU load  shall  be calculated on a 50ms period by measuring the time spent in idle\n              compared to the 50ms reference period. It is presented as a value between 0 and 100%\n              with a resolution of 1% per LSB.",
    "LLR.PLAT.PSC.CPULOAD.003": "When an application is built, the build tools  shall  add an ASAP2 displayable called\n              mpl_cpu_loaded that corresponds to the CPU loading calculated in\n              [LLR.PLAT.PSC.CPULOAD.002].\n            Rationale: \n              This is a convenience to allow the CPU loading to be easily viewed via a service or\n              calibration tool, without the application having to explicitly export the CPU loading\n              itself.",
    "LLR.PLAT.PSC.CPULOAD.004": "The function  shall  return the measure of the CPU load.",
    "LLR.PLAT.PSC.CPUMAXLOAD.001": "The platform shall provide a C interface function named\n                psc_get_max_cpu_loading() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U8\n                with a value of:\n              The maximum value of any previously calculated CPU loading since reset. \n Range: [0, 100] %",
    "LLR.PLAT.PSC.CPUMAXLOAD.101": "The function psc_get_max_cpu_loading() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.CPUMAXLOAD.201": "The function psc_get_max_cpu_loading() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.CPUMAXLOAD.004": "The function  shall  determine the maximum CPU load since reset. This occurs every time\n              the CPU load is calculated.",
    "LLR.PLAT.PSC.CPUMAXLOAD.003": "When an application is built, the build tools  shall  add an ASAP2 displayable called\n              mpl_max_cpu_loaded that corresponds to the maximum CPU loading\n              calculated in [LLR.PLAT.PSC.CPUMAXLOAD.004].\n            Rationale: \n              This is a convenience to allow the maximum CPU loading to be easily viewed via a service\n              or calibration tool, without the application having to explicitly export the CPU loading\n              itself.",
    "LLR.PLAT.PSC.CPUMAXLOAD.002": "The function  shall  return the measure of the maximum CPU load since reset as a\n              percentage between 0 and 100.",
    "LLR.PLAT.PSC.RESET.001": "The platform shall provide a C interface function named\n                psc_decode_reset() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_power_reset\n          out\n        U8 *\nPointer to where the boolean result of whether the reset occurred due to a power cycle will be written. Set true if so, false otherwise. \n Cannot be NULL.pscf_watchdog_reset\n          out\n        U8 *\nPointer to where the boolean result of whether the reset occurred due to a watchdog timeout will be written. Set true if so, false otherwise. \n Cannot be NULL.pscf_access_reset\n          out\n        U8 *\nPointer to where the boolean result of whether the reset occurred due to an illegal memory access will be written. Set true if so, false otherwise. \n Cannot be NULL.pscf_fp_reset\n          out\n        U8 *\nPointer to where the boolean result of whether the reset occurred due to a floating point exception will be written. Set true if so, false otherwise. \n Cannot be NULL.pscf_mem_reset\n          out\n        U8 *\nPointer to where the Boolean result of whether the reset occurred due to an unrecoverable corruption of internal memory. \n Cannot be NULL.pscf_forced_reset\n          out\n        U8 *\nPointer to where the boolean result of whether the reset occurred due to a forced reset will be written. Set true if so, false otherwise. \n Cannot be NULL.pscf_other_reset\n          out\n        U8 *\nPointer to where the boolean result of whether an undetermined reset occurred. Set true if the reset could not be determined, false otherwise. \n Cannot be NULL.pscf_boot_duration\n          out\n        F32 *\nA pointer to where the boot duration in seconds will be written. The boot duration is a rough estimate of time between the boot code starting to run and the scheduler starting all tasks (including the application tasks). \n Cannot be NULL.\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.RESET.101": "The function psc_decode_reset() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.RESET.201": "The function psc_decode_reset() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.RESET.002": "The function  shall  reject the call if any of the input pointers is NULL and return\n              something different from PSC_RC_OK.",
    "LLR.PLAT.PSC.RESET.010": "The platform  shall  write 1 in *pscf_power_reset if the reset is\n              caused by turning the power on.",
    "LLR.PLAT.PSC.RESET.011": "The platform  shall  write 1 in *pscf_watchdog_reset if the reset was\n              triggered by the watchdog.",
    "LLR.PLAT.PSC.RESET.006": "The platform  shall  write 1 in *pscf_access_reset if the reset was\n              caused by a memory access exception.",
    "LLR.PLAT.PSC.RESET.007": "The platform  shall  write 1 in *pscf_fp_reset if the reset was caused\n              by a floating point exception.",
    "LLR.PLAT.PSC.RESET.008": "The platform  shall  write 1 in *pscf_forced_reset if the reset was\n              caused because the application requested the platform to reset.",
    "LLR.PLAT.PSC.RESET.009": "The platform  shall  write 1 in *pscf_other_reset in all other cases.",
    "LLR.PLAT.PSC.RESET.003": "The platform  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.RESET.004": "The platform  shall  write an estimate of the time taken from the last reset to starting\n              the application into *pscf_boot_duration. Boot duration is expressed\n              in seconds with a resolution of at least 1 millisecond.",
    "LLR.PLAT.PSC.APPVER.001": "The platform shall provide a C interface function named\n                psc_get_application_version() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_major_ver\n          in\n        U16 *\nPointer to a variable the function will write the major version to. \n Cannot be NULL.pscf_minor_ver\n          in\n        U16 *\nPointer to a variable the function will write the minor version to. \n Cannot be NULL.pscf_sub_minor_ver\n          in\n        U16 *\nPointer to a variable the function will write the sub-minor version to. \n Cannot be NULL.\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.APPVER.101": "The function psc_get_application_version() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.APPVER.201": "The function psc_get_application_version() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.APPVER.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_VERSION_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.APPVER.003": "The function  shall  write in each field the appropriate value for the application\n              component.",
    "LLR.PLAT.PSC.APPVER.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.BOOTVER.001": "The platform shall provide a C interface function named\n                psc_get_boot_version() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_major_ver\n          out\n        U16 *\nPointer to a variable the function will write the major version to. \n Cannot be NULL.pscf_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the minor version to. \n Cannot be NULL.pscf_sub_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the sub-minor version to. \n Cannot be NULL.\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.BOOTVER.101": "The function psc_get_boot_version() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSC.BOOTVER.201": "The function psc_get_boot_version() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.BOOTVER.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_VERSION_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.BOOTVER.003": "The function  shall  write in each field the appropriate value for the bootloader\n              component.",
    "LLR.PLAT.PSC.BOOTVER.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PRGVER.001": "The platform shall provide a C interface function named\n                psc_get_prg_version() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_major_ver\n          out\n        U16 *\nPointer to a variable the function will write the major version to. \n Cannot be NULL.pscf_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the minor version to. \n Cannot be NULL.pscf_sub_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the sub-minor version to. \n Cannot be NULL.\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PRGVER.101": "The function psc_get_prg_version() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PRGVER.201": "The function psc_get_prg_version() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PRGVER.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_VERSION_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PRGVER.003": "The function  shall  write in each field the appropriate value for the reprogramming\n              component.",
    "LLR.PLAT.PSC.PRGVER.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PLATVER.001": "The platform shall provide a C interface function named\n                psc_get_platform_version() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_major_ver\n          out\n        U16 *\nPointer to a variable the function will write the major version to. \n Cannot be NULL.pscf_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the minor version to. \n Cannot be NULL.pscf_sub_minor_ver\n          out\n        U16 *\nPointer to a variable the function will write the sub-minor version to. \n Cannot be NULL.\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PLATVER.101": "The function psc_get_platform_version() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PLATVER.201": "The function psc_get_platform_version() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PLATVER.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_VERSION_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PLATVER.003": "The function  shall  write in each field the appropriate value for the platform library\n              component.",
    "LLR.PLAT.PSC.PLATVER.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.APPDATE.001": "The platform shall provide a C interface function named\n                psc_get_application_build_date() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_year\n          in\n        U16 *\nPointer to a variable the function will write the build year to. \n Cannot be NULL. \n Range: 0, 65535pscf_month\n          in\n        U16 *\nPointer to a variable the function will write the build month to. \n Cannot be NULL. \n Range: [1, 12] (representing January through December)pscf_day\n          in\n        U16 *\nPointer to a variable the function will write the build day to. \n Cannot be NULL. \n Range: [1, 31]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.APPDATE.101": "The function psc_get_application_build_date() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.APPDATE.201": "The function psc_get_application_build_date() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.APPDATE.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_BUILD_DATE_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.APPDATE.003": "The function  shall  write in each field the appropriate value for the application\n              component.",
    "LLR.PLAT.PSC.APPDATE.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.BOOTDATE.001": "The platform shall provide a C interface function named\n                psc_get_boot_build_date() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_year\n          out\n        U16 *\nPointer to a variable the function will write the build year to. \n Cannot be NULL. \n Range: 0, 65535pscf_month\n          out\n        U16 *\nPointer to a variable the function will write the build month to. \n Cannot be NULL. \n Range: [1, 12] (representing January through December)pscf_day\n          out\n        U16 *\nPointer to a variable the function will write the build day to. \n Cannot be NULL. \n Range: [1, 31]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.BOOTDATE.101": "The function psc_get_boot_build_date() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSC.BOOTDATE.201": "The function psc_get_boot_build_date() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.BOOTDATE.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_BUILD_DATE_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.BOOTDATE.003": "The function  shall  write in each field the appropriate value for the bootloader\n              component.",
    "LLR.PLAT.PSC.BOOTDATE.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PRGDATE.001": "The platform shall provide a C interface function named\n                psc_get_prg_build_date() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_year\n          out\n        U16 *\nPointer to a variable the function will write the build year to. \n Cannot be NULL. \n Range: 0, 65535pscf_month\n          out\n        U16 *\nPointer to a variable the function will write the build month to. \n Cannot be NULL. \n Range: [1, 12] (representing January through December)pscf_day\n          out\n        U16 *\nPointer to a variable the function will write the build day to. \n Cannot be NULL. \n Range: [1, 31]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PRGDATE.101": "The function psc_get_prg_build_date() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PRGDATE.201": "The function psc_get_prg_build_date() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PRGDATE.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_BUILD_DATE_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PRGDATE.003": "The function  shall  write in each field the appropriate value for the reprogramming\n              component.",
    "LLR.PLAT.PSC.PRGDATE.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PLATDATE.001": "The platform shall provide a C interface function named\n                psc_get_platform_build_date() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_year\n          out\n        U16 *\nPointer to a variable the function will write the build year to. \n Cannot be NULL. \n Range: 0, 65535pscf_month\n          out\n        U16 *\nPointer to a variable the function will write the build month to. \n Cannot be NULL. \n Range: [1, 12] (representing January through December)pscf_day\n          out\n        U16 *\nPointer to a variable the function will write the build day to. \n Cannot be NULL. \n Range: [1, 31]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PLATDATE.101": "The function psc_get_platform_build_date() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PLATDATE.201": "The function psc_get_platform_build_date() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PLATDATE.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_BUILD_DATE_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PLATDATE.003": "The function  shall  write in each field the appropriate value for the platform library\n              component.",
    "LLR.PLAT.PSC.PLATDATE.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.BOOTPART.001": "The platform shall provide a C interface function named\n                psc_get_boot_part_number() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_group\n          out\n        U8 *\nPointer to a variable the function will write the group id number to. \n Cannot be NULL. \n Range: 0, 99pscf_letter\n          out\n        U8 *\nPointer to a variable the function will write the group letter to. \n Cannot be NULL. \n Range: 0, 255pscf_id\n          out\n        U32 *\nPointer to a variable the function will write the part id number to. \n Cannot be NULL. \n Range: 0, 999999pscf_issue\n          out\n        U16 *\nPointer to a variable the function will write the part issue number to. \n Cannot be NULL. \n Range: [0, 65535]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.BOOTPART.101": "The function psc_get_boot_part_number() shall support the targets:\n                      M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSC.BOOTPART.201": "The function psc_get_boot_part_number() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.BOOTPART.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_PART_NUMBER_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.BOOTPART.003": "The function  shall  write in each field the appropriate value for the bootloader\n              component part number.",
    "LLR.PLAT.PSC.BOOTPART.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.BOOTPART.005": "The platform shall provide a Simulink interface block named\n                psc_BootPartNumber that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_group_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_group_letterInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_letter\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_part_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport part_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_issueInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport issue\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_idOutport-\n        \n          The Group Identification number of the part number of the boot code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_letterOutport-\n        \n          The Group Identification letter of the part number of the boot code. The value represents the ASCII\n          code of the letter. Under simulation, if the Provide simulation inports parameter\n          isn't ticked, the outport is set to the minimum of its range. The signal attached to the outport must\n          be set as ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            part_idOutport-\n        \n          The Part Identification number of the part number of the boot code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            issueOutport-\n        \n          The Issue number of the part number of the boot code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            Provide simulation inportsParam-\n        \n          Tick to\n          enable inports sim_group_id, sim_group_letter,\n          sim_part_id and sim_issue.\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              \n              Value-type: incorrectly specified in user guide XML.",
    "LLR.PLAT.PSC.BOOTPART.105": "The block psc_BootPartNumber shall support the targets:\n            M110-000, M220-000, M221-000, M250-000, M460-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSC.BOOTPART.205": "The block psc_BootPartNumber shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSC.BOOTPART.006": "The block  shall  schedule itself to run under simulation and on target at the rate\n               specified by the subsystem that the block is in.",
    "LLR.PLAT.PSC.BOOTPART.007": "If parameter Provide simulation inports\n                is true then the sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue  inports  shall  be available on the block,\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PSC.BOOTPART.008": "If parameter Provide simulation inports\n                is true then the block  shall  set the value of outports\n                sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue to the value of inports\n                group_id,\n                group_letter,\n                part_id and\n                issue, scaled and clipped\n                to match the range of the outport.",
    "LLR.PLAT.PSC.BOOTPART.009": "The block  shall  set each outport to the corresponding value for the bootloader\n              component part number.",
    "LLR.PLAT.PSC.PRGPART.001": "The platform shall provide a C interface function named\n                psc_get_prg_part_number() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_group\n          out\n        U8 *\nPointer to a variable the function will write the group id number to. \n Cannot be NULL. \n Range: 0, 99pscf_letter\n          out\n        U8 *\nPointer to a variable the function will write the group letter to. \n Cannot be NULL. \n Range: 0, 255pscf_id\n          out\n        U32 *\nPointer to a variable the function will write the part id number to. \n Cannot be NULL. \n Range: 0, 999999pscf_issue\n          out\n        U16 *\nPointer to a variable the function will write the part issue number to. \n Cannot be NULL. \n Range: [0, 65535]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PRGPART.101": "The function psc_get_prg_part_number() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PRGPART.201": "The function psc_get_prg_part_number() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PRGPART.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_PART_NUMBER_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PRGPART.003": "The function  shall  write in each field the appropriate value for the reprogramming\n              component part number.",
    "LLR.PLAT.PSC.PRGPART.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PRGPART.005": "The platform shall provide a Simulink interface block named\n                psc_PrgPartNumber that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_group_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_group_letterInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_letter\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_part_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport part_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_issueInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport issue\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_idOutport-\n        \n          The Group Identification number of the part number of the reprogramming code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_letterOutport-\n        \n          The Group Identification letter of the part number of the reprogramming code. The value represents the ASCII\n          code of the letter. Under simulation, if the Provide simulation inports parameter\n          isn't ticked, the outport is set to the minimum of its range. The signal attached to the outport must\n          be set as ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            part_idOutport-\n        \n          The Part Identification number of the part number of the reprogramming code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            issueOutport-\n        \n          The Issue number of the part number of the reprogramming code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            Provide simulation inportsParam-\n        \n          Tick to\n          enable inports sim_group_id, sim_group_letter,\n          sim_part_id and sim_issue.\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              \n              Value-type: incorrectly specified in user guide XML.",
    "LLR.PLAT.PSC.PRGPART.105": "The block psc_PrgPartNumber shall support the targets:\n            All targets.",
    "LLR.PLAT.PSC.PRGPART.205": "The block psc_PrgPartNumber shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSC.PRGPART.006": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is in.",
    "LLR.PLAT.PSC.PRGPART.007": "If parameter Provide simulation inports\n                is true then the sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue  inports  shall  be available on the block,\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PSC.PRGPART.008": "If parameter Provide simulation inports\n                is true then the block  shall  set the value of outports\n                sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue to the value of inports\n                group_id,\n                group_letter,\n                part_id and\n                issue, scaled and clipped\n                to match the range of the outport.",
    "LLR.PLAT.PSC.PRGPART.009": "The block  shall  set each outport to the corresponding value for the bootloader\n              component part number.",
    "LLR.PLAT.PSC.PLATPART.001": "The platform shall provide a C interface function named\n                psc_get_platform_part_number() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_group\n          out\n        U8 *\nPointer to a variable the function will write the group id number to. \n Cannot be NULL. \n Range: 0, 99pscf_letter\n          out\n        U8 *\nPointer to a variable the function will write the group letter to. \n Cannot be NULL. \n Range: 0, 255pscf_id\n          out\n        U32 *\nPointer to a variable the function will write the part id number to. \n Cannot be NULL. \n Range: 0, 999999pscf_issue\n          out\n        U16 *\nPointer to a variable the function will write the part issue number to. \n Cannot be NULL. \n Range: [0, 65535]\n                The function returns a value of type\n                PSC_RC_T\n                with a value of:\n              PSC_RC_OK - if successful actionPSC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSC.PLATPART.101": "The function psc_get_platform_part_number() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.PLATPART.201": "The function psc_get_platform_part_number() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.PLATPART.002": "The function  shall  reject calls if any of the pointers are NULL and raise a recoverable\n              error PSY_PSC\/PSC_ERR_PART_NUMBER_INVALID_PARAM and return PSC_RC_BAD_ARGS in that case.",
    "LLR.PLAT.PSC.PLATPART.003": "The function  shall  write in each field the appropriate value for the platform library\n              component part number.",
    "LLR.PLAT.PSC.PLATPART.004": "The function  shall  return PSC_RC_OK.",
    "LLR.PLAT.PSC.PLATPART.005": "The platform shall provide a Simulink interface block named\n                psc_PlatformPartNumber that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsim_group_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_group_letterInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport group_letter\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_part_idInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport part_id\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            sim_issueInport-\n        \n          Only used under simulation and\n          when the parameter Provide simulation inports is ticked. The outport issue\n          is set to the value of this inport for simulation purposes.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_idOutport-\n        \n          The Group Identification number of the part number of the platform code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            group_letterOutport-\n        \n          The Group Identification letter of the part number of the platform code. The value represents the ASCII\n          code of the letter. Under simulation, if the Provide simulation inports parameter\n          isn't ticked, the outport is set to the minimum of its range. The signal attached to the outport must\n          be set as ExportedGlobal.\n        \n        \n          Range: [0, 255]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            part_idOutport-\n        \n          The Part Identification number of the part number of the platform code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 4294967295]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            issueOutport-\n        \n          The Issue number of the part number of the platform code. Under simulation, if the Provide simulation inports parameter isn't ticked, the outport is set to the\n          minimum of its range. The signal attached to the outport must be set as\n          ExportedGlobal.\n        \n        \n          Range: [0, 65535]\n        \n      \n              Value-type: incorrectly specified in user guide XML.\n            Provide simulation inportsParam-\n        \n          Tick to\n          enable inports sim_group_id, sim_group_letter,\n          sim_part_id and sim_issue.\n        \n      \n                Calibratable: incorrectly specified in user guide XML.\n              \n              Value-type: incorrectly specified in user guide XML.",
    "LLR.PLAT.PSC.PLATPART.105": "The block psc_PlatformPartNumber shall support the targets:\n            All targets.",
    "LLR.PLAT.PSC.PLATPART.205": "The block psc_PlatformPartNumber shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSC.PLATPART.006": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is in.",
    "LLR.PLAT.PSC.PLATPART.007": "If parameter Provide simulation inports\n                is true then the sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue  inports  shall  be available on the block,\n                otherwise no inport shall appear on the block.",
    "LLR.PLAT.PSC.PLATPART.008": "If parameter Provide simulation inports\n                is true then the block  shall  set the value of outports\n                sim_group_id,\n                sim_group_letter,\n                sim_part_id and\n                sim_issue to the value of inports\n                group_id,\n                group_letter,\n                part_id and\n                issue, scaled and clipped\n                to match the range of the outport.",
    "LLR.PLAT.PSC.PLATPART.009": "The block  shall  set each outport to the corresponding value for the bootloader\n              component part number.",
    "LLR.PLAT.PSC.RUNTIME.001": "The platform shall provide a C interface function named\n                psc_get_run_time() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U32\n                with a value of:\n              The run time. \n Range: [0, 4294967295] seconds",
    "LLR.PLAT.PSC.RUNTIME.101": "The function psc_get_run_time() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.RUNTIME.201": "The function psc_get_run_time() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.RUNTIME.004": "The function  shall  set the run-time to zero at application\n              start.",
    "LLR.PLAT.PSC.RUNTIME.002": "The function  shall  return the number of seconds since the application was started. The\n              range is 0 to 4294967295.",
    "LLR.PLAT.PSC.RUNTIME.003": "When an application is built, the build tools  shall  add an ASAP2 displayable called\n              mpl_run_time that corresponds to the maximum time calculated in\n              [LLR.PLAT.PSC.RUNTIME.002].",
    "LLR.APP.PSC.STACK.001": "The application  will  declare the stack size to be allocated during initialisation in the\n              C-API interface specification file.",
    "LLR.PLAT.PSC.STACK.004": "When the software detects that the stack size has been exceeded then the software  shall \n              reset the ECU.\n            Rationale: \n              Resetting the ECU is an attempt to prevent undefined behaviour from the software and\n              therefore the ECU in a situation where the software has exceeded its design limits.",
    "LLR.PLAT.PSC.STACK.001": "The platform shall provide a C interface function named\n                psc_get_used_stack_size() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U32\n                with a value of:\n              The size of stack used by the application and library code. \n Range: [0, 4294967295] bytes",
    "LLR.PLAT.PSC.STACK.101": "The function psc_get_used_stack_size() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.STACK.201": "The function psc_get_used_stack_size() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSC.STACK.002": "The function  shall  return the measure of the maximum used stack size since reset,\n              expressed in bytes between 0 and 4294967295.",
    "LLR.PLAT.PSC.STACK.003": "When an application is built, the build tools  shall  add an ASAP2 displayable called\n              mpl_max_used_stack that corresponds to the maximum stack depth\n              calculated in [LLR.PLAT.PSC.STACK.002].",
    "LLR.PLAT.PSC.KICK.001": "The platform shall provide a C interface function named\n                psc_kick_watchdog() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PSC.KICK.101": "The function psc_kick_watchdog() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.KICK.201": "The function psc_kick_watchdog() shall be in the license group:\n                      None (Main library).",
    "LLR.APP.PSC.KICK.001": "If the C-API interface specification requires application handling of the watchdog then\n              the application  shall  kick the watchdog at least every 200ms.",
    "LLR.PLAT.PSC.KICK.002": "If the C-API interface specification requires library handling of the watchdog then the\n              platform  shall  kick the watchdog at least every 200ms.",
    "LLR.PLAT.PSC.CVN.001": "When the ECU powers up, the platform  shall  initialise retrieve the calibration verification number from NVM.",
    "LLR.PLAT.PSC.CVN.002": "When requested by the application software, the platform  shall  trigger the calculation\n              of a calibration verification number using the algorithm defined in [HLR.PLAT.INFO.008].",
    "LLR.PLAT.PSC.CVN.029": "The platform  shall  maintain a copy of the latest calculated CVN in NVM.\n            Rationale: \n              This allows the platform to be able to supply a CVN value immediately when requested by\n              the application.\n              This satifies the CARB requirement - \"Except as provided for below, the on-board computer\n              may not use delayed timing in sending the CVN and may not respond with a message indicating\n              that the CVN value is not currently available\".",
    "LLR.PLAT.PSC.CVN.016": "The CVN  shall  consist of four bytes of which the most significant two bytes shall be a check\n              value calculated over the calibration read-only memory and the least significant two bytes shall\n              be a check value calculated over the strategy read-only memory.",
    "LLR.PLAT.PSC.CVN.003": "The platform  shall  always make available to the application the most recent calibration verification\n              number to have been calculated since retrieval from NVM. The stored value in NVM shall be used if\n              the CVN has not been calculated yet since power cycle.",
    "LLR.PLAT.PSC.CVN.030": "If no CVN computation has completed since last invalidated or has never been calculated, then the platform\n              software  shall  indicate this to the application via a flag to indicate that the value is invalid.",
    "LLR.PLAT.PSC.CVN.017": "The platform  shall  compare the CVN value computed at each cycle to the previous value (if available).\n              If any unexpected (see below) change occurs in the CVN, it shall raise an unrecoverable error,\n              unless the C-API option to skip memory checks is set.\n            Rationale: \n              See also [LLR.PLAT.PSC.BGRAM.007] concerning opt-out from memory checks.",
    "LLR.PLAT.PSC.CVN.018": "The CVN calculation  shall  provide a means for other features to invalidate the current CVN.\n              If done, no unrecoverable error will be raised if the next value differs from the last,\n              or if the value resulting from the in-progress calculation differs from the next one after\n              that.\n            Rationale: \n              This allows expected changes in calibration values at run time to be ignored (e.g. because\n              of CCP download).",
    "LLR.PLAT.PSC.CVN.027": "The platform shall provide a C interface function named\n                psc_start_cvn_calc() that takes\n                no parameters.\n              \n                The function returns void.",
    "LLR.PLAT.PSC.CVN.127": "The function psc_start_cvn_calc() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.CVN.227": "The function psc_start_cvn_calc() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PSC.CVN.028": "Calling the function  shall  initiate a CVN calculation.",
    "LLR.PLAT.PSC.CVN.019": "The platform shall provide a C interface function named\n                psc_check_cvn_availability() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpscf_cvn\n          in\/out\n        U32 *\nThe resultant CVN of both the code & calibration areas. The calibration area CRC occupies the 2 most significant bytes. The code area CRC occupies the 2 least significant bytes.pscf_being_calculated\n          out\n        BOOL *\nTrue if the CVN is currently being calculated, otherwise false.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              TRUE - indicating a CVN is available. Once a CVN has been calculated returns TRUE until ECU reset, i.e. triggering further CVN calculations does not alter the returned value.FALSE - When there is no valid CVN either currently calculated the function returns FALSE.",
    "LLR.PLAT.PSC.CVN.119": "The function psc_check_cvn_availability() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSC.CVN.219": "The function psc_check_cvn_availability() shall be in the license group:\n                      EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PSC.CVN.020": "If no CVN calculation is underway, the function  shall  write\n                the value FALSE through the\n                pscf_being_calculated pointer.",
    "LLR.PLAT.PSC.CVN.021": "If a CVN calculation is underway, the function  shall  write the\n                value TRUE through the\n                pscf_being_calculated pointer.",
    "LLR.PLAT.PSC.CVN.022": "Once a CVN calculation has completed the function  shall  write\n                the value of the calculated CVN through the pointer\n                pscf_cvn.",
    "LLR.PLAT.PSC.CVN.023": "Once a CVN calculation has completed the function  shall  return\n                TRUE until ECU reset.",
    "LLR.PLAT.PSC.CVN.026": "Prior to the completion of the first CVN calculation the function\n                 shall  return FALSE.",
    "LLR.PLAT.PSC.CVN.010": "The platform shall provide a Simulink interface block named\n                psc_CvnCalc that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiontriggerInportBoolean\n        \n          A boolean flag to trigger the CVN calculation, apply a rising edge to this inport.\n        \n      cvnOutportInteger\n        \n          The calculated CVN is supplied to the application from this port.\n          The supplied CVN is composed of the code area CRC and calibration area CRC.\n          The calibration area CRC occupies the 2 most significant bytes.\n          The code area CRC occupies the 2 least significant bytes.\n        \n      availableOutportBoolean\n        \n          This port indicates the availability of the CVN.\n        \n        FALSE - CVN not available.TRUE - CVN available.\n        \n           Once a CVN has been calculated returns TRUE until ECU reset,\n           i.e. triggering further CVN calculations does not alter this value.\n        \n      calculatingOutportBoolean\n        \n          True if the CVN is currently being calculated, otherwise false.",
    "LLR.PLAT.PSC.CVN.110": "The block psc_CvnCalc shall support the targets:\n            All targets.",
    "LLR.PLAT.PSC.CVN.210": "The block psc_CvnCalc shall be in the license group:\n            EXT_DIAG (Extended diagnostics library).",
    "LLR.PLAT.PSC.CVN.011": "If the target subtype (as identified by the put_Identification block\n                ECU type,\n                Part Number and\n                Issue Number mask parameters)\n                is unsupported for this block, then the block  shall  raise an error.",
    "LLR.PLAT.PSC.CVN.012": "If the outport cvn\n                is not of the type u32 then the block  shall  raise an error.",
    "LLR.PLAT.PSC.CVN.013": "The block  shall  schedule itself to run under simulation and on target at the rate\n                specified by the subsystem that the block is in.",
    "LLR.PLAT.PSC.CVN.014": "When the inport trigger changes state from zero\n                to non-zero, then if no CVN calculation is currently underway, the block  shall  initiate\n                one.",
    "LLR.PLAT.PSC.CVN.015": "The block  shall  output the CVN value as defined by LLR.PLAT.PSC.CVN.003 through the outport\n                cvn.",
    "LLR.PLAT.PSC.CVN.024": "Through the outport available\n                the block  shall  indicate whether the CVN is available or not.\n              Note: \n                The CVN is considered as available if it has been calculated\n                at least once since ECU reset.",
    "LLR.PLAT.PSC.CVN.025": "Through the outport calculating\n                the block  shall  indicate whether the CVN calculation is underway or not.",
    "LLR.PLAT.PSC.BGRAM.007": "The platform  shall  perform the initialisation and background memory checks\n              defined below by default, but shall not if a user C-API option is set to\n              skip such checks. This option applies also to run-time flash and NVM checks.\n            Rationale: \n              The end-of-line test application does its own memory testing and remapping\n              which conflicts with these tests; also, this gives an opportunity for C-API users\n              to reduce idle task work if they are performing some processing there of\n              their own. (Neither affects Simulink however.)\n            \n              See also [LLR.PLAT.PSC.CVN.017] and [LLR.PLAT.PFS.BGCHECK.001].",
    "LLR.PLAT.PSC.BGRAM.006": "When the ECU powers up, the platform  shall  test all external RAM locations\n              according to the tests detailed below before they are used by application\n              software.\n            Rationale: \n              Internal RAM is first tested by the boot loader on power-up\n              (see [LLR.PLAT.PBT.CHECK.001]\n              and[LLR.PLAT.PBT.CHECK.002]).\n              Therefore internal RAM is excluded from the start-up test here to avoid a duplicated\n              test that would unnecessarily extend boot-up time.",
    "LLR.PLAT.PSC.BGRAM.001": "The platform  shall  continually test all external areas of RAM used in\n              production applications (i.e.any external RAM areas\n              present in the current ECU other than those used for calibration\n              shadowing).\n            Rationale: \n              Production ECUs are assumed to use flash storage for calibrations and\n              not shadow RAM. Therefore testing the shadow RAM area used for calibrations\n              is not required.  Internal RAM is protected in\n              any case by Error Correcting Codes (ECC), and cannot be\n              manipulated at run-time due to DMA operations.",
    "LLR.PLAT.PSC.BGRAM.002": "For targets in which more than one area of external (non-microcontroller)\n              RAM are used, the platform  shall  test that those areas have not been\n              made to overlap (e.g. by accidental fitting of a lower-capacity device\n              or address line fault).",
    "LLR.PLAT.PSC.BGRAM.003": "The platform  shall  test every external RAM location for its ability to retain bit values\n              of both 0 and 1.\n            Rationale: \n              This captures a fault such as cosmic ray damage affecting only one or\n              a small number of RAM cells. Care must be taken not to read back apparently\n              valid data due to floating data bus lines, which can retain the last\n              voltage driven for some time and so simulate memory.\n            \n              See also [LLR.PLAT.PBT.CHECK.002].",
    "LLR.PLAT.PSC.BGRAM.004": "The platform  shall  test every external RAM area used for address bus faults,\n              covering all address lines necessary to uniquely address any location\n              in that area.\n            Rationale: \n              External RAM areas may have address bus faults due to manufacturing errors, PCB\n              damage or the fitting of incorrect components.\n              See also[LLR.PLAT.PBT.CHECK.001].",
    "LLR.PLAT.PSC.BGRAM.005": "The platform  shall  test every external RAM area used for data bus faults,\n              covering all data bus lines required to write the full machine word width.\n            Rationale: \n              External RAM areas may have data bus faults due to manufacturing errors, PCB\n              damage or the fitting of incorrect components.\n              See also [LLR.PLAT.PBT.CHECK.001].",
    "LLR.PLAT.PSMC.INIT.001": "The platform  shall  configure the secondary micro UART port to:\n            ParameterValuebaud19200bits8paritynonestop bit1",
    "LLR.PLAT.PSMC.CCP.001": "When a CCP message is received within the address range reserved for the secondary\n              micro, the platform  shall  send the contents in a message to the secondary micro\n              using the port number 0b1010.",
    "LLR.PLAT.PSMC.CCP.002": "When the platform receives a message from the secondary micro with the port number\n              0b1010, the CCP response message  shall  be sent with the contents in a message.",
    "LLR.PLAT.PSMC.HEARTBEAT.001": "The platform shall provide a C interface function named\n                psmc_send_heart_beat() that takes\n                no parameters.\n              \n                The function returns a value of type\n                PSMC_RC_T\n                with a value of:\n              PSMC_RC_OK - if successful actionPSMC_RC_SW_ERROR - if channel not supportedPSMC_RC_HW_ERROR - if error initialising channel",
    "LLR.PLAT.PSMC.HEARTBEAT.002": "The function psmc_send_heart_beat() shall support the targets:\n                      M550-000.",
    "LLR.PLAT.PSMC.HEARTBEAT.003": "The function psmc_send_heart_beat() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSMC.HEARTBEAT.004": "When the function is called, the platform  shall  send a message to the secondary\n                micro with port number 0b1111 and length 0.",
    "LLR.PLAT.PSMC.HEARTBEAT.005": "The platform shall provide a Simulink interface block named\n                psmc_HeartBeat that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionsendInportBoolean\n        \n          Set to 1 to trigger transmit of heart beat message to secondary microcontroller.\n        \n        \n          Range: 0 or 1",
    "LLR.PLAT.PSMC.HEARTBEAT.006": "The block psmc_HeartBeat shall support the targets:\n            M550-000.",
    "LLR.PLAT.PSMC.HEARTBEAT.007": "The block psmc_HeartBeat shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSMC.HEARTBEAT.008": "If the inport send is set to 1, the\n                platform  shall  send a message to the secondary micro with port number 0b1111 and\n                length 0.",
    "LLR.PLAT.PSMC.TX.001": "The platform shall provide a C interface function named\n                psmc_transmit() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpsmcf_size\n          in\n        U8\nLength of message to send\n Range: [x, y] units @ fixed point resolutionpsmcf_data\n          in\n        const U8 *\nArray of data bytes to send\n Range: [x, y] units @ fixed point resolution\n                The function returns a value of type\n                PSMC_RC_T\n                with a value of:\n              PSMC_RC_OK - if successful actionPSMC_RC_SW_ERROR - if channel not supportedPSMC_RC_HW_ERROR - if error initialising channelPSMC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSMC.TX.002": "The function psmc_transmit() shall support the targets:\n                      M550-000.",
    "LLR.PLAT.PSMC.TX.003": "The function psmc_transmit() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSMC.TX.004": "When the function is called, the platform  shall  write a message of the specified\n                length, psmcf_size, to the SCI transmit buffer, with the port\n                number, 0b0101. With contents from the array,\n                psmcf_data.",
    "LLR.PLAT.PSMC.TX.005": "The platform shall provide a Simulink interface block named\n                psmc_TransmitMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiontx_triggerInportBoolean\n        \n          Set to 1 to trigger transmit of user application message to secondary microcontroller.\n        \n        \n          Range: 0 or 1\n        \n      dataInportInteger\n        \n          Array of bytes of length Message length of the data to transmit.\n        \n        \n          Range: [0, 255]\n        \n      Message lengthParamInteger\n        \n          the length in bytes of the data in the message to be sent.\n        \n        \n          Range: [0, 15]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PSMC.TX.006": "The block psmc_TransmitMessage shall support the targets:\n            M550-000.",
    "LLR.PLAT.PSMC.TX.007": "The block psmc_TransmitMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSMC.TX.008": "If the inport send is set to 1, the\n                platform  shall  send a message to the secondary micro with port number\n                0b0101, length psmcf_size , and contents from\n                the array psmcf_data.",
    "LLR.PLAT.PSMC.RX.002": "The platform shall provide a C interface function named\n                psmc_receive() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpsmcf_size\n          in\n        U8\nWidth of psmcf_data and Expected length of message received\n Range: [0, 15]psmcf_data\n          out\n        U8 *\nArray of data bytes received\n Range: [x, y] units @ fixed point resolutionpsmcf_actual_size\n          out\n        U8 *\nLength of message received\n Range: [0, 15]psmcf_received\n          out\n        BOOL *\nWhether data was actually receivedpsmcf_error\n          out\n        BOOL *\nError in received frame\n                The function returns a value of type\n                PSMC_RC_T\n                with a value of:\n              PSMC_RC_OK - if successful actionPSMC_RC_SW_ERROR - if channel not supportedPSMC_RC_HW_ERROR - if error initialising channelPSMC_RC_BAD_ARGS - if configuration error",
    "LLR.PLAT.PSMC.RX.003": "The function psmc_receive() shall support the targets:\n                      M550-000.",
    "LLR.PLAT.PSMC.RX.004": "The function psmc_receive() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSMC.RX.001": "When the platform receives a message with port 0b0101, it  shall \n              store that message in a buffer.",
    "LLR.PLAT.PSMC.RX.005": "When the function is called, and no received message is available, the parameter\n                psmcf_received  shall  be set to 0.",
    "LLR.PLAT.PSMC.RX.006": "When the function is called, and a received message is available, the parameter\n                psmcf_received  shall  be set to 1, psmcf_size\n                 shall  be set to the length of the received message, and\n                psmcf_data  shall  be set to the data in the received message.",
    "LLR.PLAT.PSMC.RX.007": "After the block is called, the received message  shall  be removed from the buffer.",
    "LLR.PLAT.PSMC.RX.008": "The platform shall provide a Simulink interface block named\n                psmc_ReceiveMessage that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionrx_flagOutportBoolean\n        \n          Set to 1 if message data has been received at this iteration without any error,\n          or 0 otherwise.\n        \n        \n          Range: 0 or 1\n        \n      actual_lengthOutportInteger\n        \n          Actual length of message read by block. if less than\n          Expected message length, additional bytes of\n          data will be 0.\n        \n        \n          Range: [0, 15]\n        \n      dataOutportInteger\n        \n          Array of bytes of length Expected message length of the data that\n          was read.\n        \n        \n          Range: [0, 255]\n        \n      Expected message lengthParamInteger\n        \n          The expected length in bytes of the data in the message to be read.\n        \n        \n          Range: [0, 15]\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PSMC.RX.009": "The block psmc_ReceiveMessage shall support the targets:\n            M550-000.",
    "LLR.PLAT.PSMC.RX.010": "The block psmc_ReceiveMessage shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSMC.RX.011": "If Expected message length is\n                outside, the range [0, 15], the block  shall  raise an appropriate error.",
    "LLR.PLAT.PSMC.RX.012": "If Expected message length is\n                within, the range [0, 15], the block  shall  allocate the corresponding width of\n                data to equal\n                Expected message length.",
    "LLR.PLAT.PSMC.RX.013": "When the block is called, and no received message is available, the outport\n                rx_flag  shall  be set to 0.",
    "LLR.PLAT.PSMC.RX.014": "When the block is called, and a received message is available, the outport\n                rx_flag  shall  be set to 1,\n                actual_length  shall  be set to the\n                length of the received message, and\n                data  shall  be set to the data in the\n                received message.",
    "LLR.PLAT.PSMC.RX.015": "After the block is called, the received message  shall  be removed from the buffer.",
    "LLR.PLAT.PSS.RESETTRIP.001": "The platform  shall  clear the over-current trip latches for the outputs supported by the target.\n            Rationale: \n              The HSIS requires that the over-current trip latches are cleared after reset, so that\n              the latches operate correctly thereafter. The software clears the latches prior to the\n              application using them.",
    "LLR.PLAT.PSS.RESETTRIP.002": "If there is a pending request to clear the over-current trip latches and at least 50\n              milliseconds have past since the last time the over-current trip latches were reset, then\n              the platform  shall  clear the over-current trip latches for the outputs supported by the target.\n            Rationale: \n              The HSIS requires a delay between clearing latches to ensure that permanently\n              over-current conditions do not lead to a build up of temperature or other stress to the\n              ECU's circuitry.",
    "LLR.PLAT.PSS.RESETTRIP.004": "The platform shall provide a C interface function named\n                pss_overcur_trip_reset() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpssf_request_trip_reset\n          in\n        BOOL\nNeed to cause a transition from false to true to generate an over-current trip reset.\n                The function returns void.",
    "LLR.PLAT.PSS.RESETTRIP.104": "The function pss_overcur_trip_reset() shall support the targets:\n                      M220-000, M221-000, M250-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSS.RESETTRIP.204": "The function pss_overcur_trip_reset() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSS.RESETTRIP.005": "If parameter pssf_request_trip_reset is true and this is the first\n                call to the interface, then the platform  shall  request that the over-current trip\n                latches are cleared.",
    "LLR.PLAT.PSS.RESETTRIP.006": "If parameter pssf_request_trip_reset is true and in the previous call\n                to the same interface pssf_request_trip_reset was false, then the\n                platform  shall  request that the over-current trip latches are cleared.",
    "LLR.PLAT.PSS.RESETTRIP.007": "The platform shall provide a Simulink interface block named\n                pss_OvercurTripReset that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionovercur_trip_resetInportBoolean\n        \n          Change from 0 to 1\n          to request a reset of the over-current trip latches. The request is buffered\n          by the blockset and actioned when enough time has past since the last over-current\n          trip reset (ensuring time for sufficient ECU heat dissipation).\n        \n        \n          Range: 0 or 1",
    "LLR.PLAT.PSS.RESETTRIP.107": "The block pss_OvercurTripReset shall support the targets:\n            M220-000, M221-000, M250-000, M461-000, M550-000 and M670-000.",
    "LLR.PLAT.PSS.RESETTRIP.207": "The block pss_OvercurTripReset shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSS.RESETTRIP.008": "The block  shall  schedule itself to run on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PSS.RESETTRIP.009": "The block  shall  use the inport overcur_trip_reset\n                value when requesting resets of over-current trip latches.\n              Note: \n                Resets are only auctioned on a 0 to 1 transition.",
    "LLR.PLAT.PSS.SETSWITCH.007": "The platform  shall  disable the high-side switched outputs supported by the target.",
    "LLR.PLAT.PSS.SETSWITCH.008": "When requested, the platform  shall  enable the high-side switched outputs supported by the target,\n              otherwise they shall remain disabled.",
    "LLR.PLAT.PSS.SETSWITCH.001": "The platform shall provide a C interface function named\n                pss_set_safety_switch() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpssf_enable\n          in\n        BOOL\nTrue to enable the safety switch and enable the output drivers, false otherwise.\n                The function returns void.",
    "LLR.PLAT.PSS.SETSWITCH.101": "The function pss_set_safety_switch() shall support the targets:\n                      M250-000 and M460-000.",
    "LLR.PLAT.PSS.SETSWITCH.201": "The function pss_set_safety_switch() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSS.SETSWITCH.002": "The platform  shall  disable the high-side switch if the\n                pssf_enable parameter is false.",
    "LLR.PLAT.PSS.SETSWITCH.003": "The platform  shall  enable the high-side switch if the pssf_enable\n                parameter is true.",
    "LLR.PLAT.PSS.SETSWITCH.004": "The platform shall provide a Simulink interface block named\n                pss_OutputControl that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionenableInportBoolean\n        \n          Set to 1 to enable\n          the output drivers, set to 0 to disable the output drivers.\n        \n        \n          Range: 0 or 1",
    "LLR.PLAT.PSS.SETSWITCH.104": "The block pss_OutputControl shall support the targets:\n            M250-000 and M460-000.",
    "LLR.PLAT.PSS.SETSWITCH.204": "The block pss_OutputControl shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PSS.SETSWITCH.005": "The block  shall  schedule itself to run on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PSS.SETSWITCH.006": "If the inport enable is 1\n                then the platform  shall  request that the sensor power is applied, otherwise the sensor power shall be disabled.",
    "LLR.PLAT.PSY.RECO.001": "The platform shall provide a C interface function named\n                psy_recoverable_error() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpsyf_feature_id\n          in\n        U8\nA unique identifier for the feature which is declaring the error. \n Range: [0, 255] unitlesspsyf_error_id\n          in\n        U16\nA unique identifier for the error the feature has found. \n Range: [0, 65535] unitless \n                The function returns void.",
    "LLR.PLAT.PSY.RECO.002": "For units that have persistent error log storage, upon reset, the platform  shall  check\n              the error-log checksum.",
    "LLR.PLAT.PSY.RECO.005": "For units that have persistent error log storage, if the checksum is incorrect, the\n              function  shall  clear the log.",
    "LLR.PLAT.PSY.RECO.006": "The platform  shall  allow for 16 entries in the log.",
    "LLR.PLAT.PSY.RECO.004": "If the error is log full, the function  shall  do nothing.",
    "LLR.PLAT.PSY.RECO.003": "If the error log is not full, the function  shall  append the error data\n              (psyf_feature_id\/psyf_error_id) to the error log.",
    "LLR.PLAT.PSY.UNRECO.001": "The platform shall provide a C interface function named\n                psy_unrecoverable_error() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpsyf_feature_id\n          in\n        U8\nA unique identifier for the feature which is declaring the error. \n Range: [0, 255] unitlesspsyf_error_id\n          in\n        U16\nA unique identifier for the error the feature has found. \n Range: [0, 65535] unitless \n                The function returns void.",
    "LLR.PLAT.PSY.UNRECO.002": "Similarly to the psy_recoverable_error function, the error is added\n              to the log if there is space.",
    "LLR.PLAT.PSY.UNRECO.003": "After logging the error, the function  shall  reset the processor.\n            Note: \n              For units without persistent error log storage, when the unit resets, the log is cleared\n              upon reset. We suggest developer to set a breakpoint in the\n              psc_reset_box function and took a look at the log.\n            \n              Alternatively, for MPC5xxx family units without persistent error log storage,\n              the error log associated with the last unrecoverable error is remembered over a reset\n              and recovered into the error log post reset. If the unit is forced to stay in the PRG\n              due to an invalid application following the unrecoverable error, the last error log\n              is also available via CCP debugging.\n              Also note that the error code is clipped to 0xFF in this case.\n            \n              For unit with persistent error log storage, the psy_get_num_error()\n              and psy_get_error() can be used to read the log after the reset.",
    "LLR.PLAT.PSY.ERRLOG.001": "The platform shall provide a C interface function named\n                psy_get_num_errors() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U8\n                with a value of:\n              Number of declared errors. \n Range: [0, PSY_MAX_NUM_STORED_ERRORS] errors",
    "LLR.PLAT.PSY.ERRLOG.101": "The function psy_get_num_errors() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSY.ERRLOG.201": "The function psy_get_num_errors() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSY.ERRLOG.002": "The function  shall  return the number of logged errors.",
    "LLR.PLAT.PSY.ERRLOG.003": "The platform shall provide a C interface function named\n                psy_get_error() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionpsyf_error_index\n          in\n        U8\nThe index into the error log to retrieve error information from. \n Range: [0, PSY_MAX_NUM_STORED_ERRORS - 1] unitlesspsyf_log\n          out\n        PSY_ERROR_LOG_T *\nPointer to store for error information. \n Cannot be NULL.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if the error information could be retrieved, false otherwise.",
    "LLR.PLAT.PSY.ERRLOG.103": "The function psy_get_error() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PSY.ERRLOG.203": "The function psy_get_error() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PSY.ERRLOG.005": "The function  shall  check that the psyf_error_index corresponds to a\n              filled entry (i.e. less than psy_get_num_errors()) and return FALSE\n              if it isn't.",
    "LLR.PLAT.PSY.ERRLOG.006": "The function  shall  check that the psyf_log pointer is not NULL and\n              return FALSE if it is NULL.",
    "LLR.PLAT.PSY.ERRLOG.007": "The function  shall  copy the error data identified by parameter\n              psyf_error_index to the location pointed by parameter\n              psyf_log.",
    "LLR.PLAT.PSY.ERRLOG.008": "The function  shall  return TRUE.",
    "LLR.PLAT.PSY.ETPUMEM.001": "After writing the eTPU code to the shared code memory, the platform  shall  read it\n              back and compare it to the original copy.",
    "LLR.PLAT.PSY.ETPUMEM.002": "If the values read back from the shared code memory do not match the original values\n              stored in flash, the platform  shall  raise an unrecoverable error.",
    "LLR.PLAT.PSY.ETPUMEM.003": "Before initialising the shared data memory, the platform  shall  write an arbitrary\n              pattern to each memory cell and read the value back.",
    "LLR.PLAT.PSY.ETPUMEM.004": "If the pattern read back does not match what was written, the platform  shall  raise an\n              unrecoverable error.",
    "LLR.PLAT.PSY.ETPUMEM.005": "At initialisation time, the platform  shall  enable the MISC functionality in the eTPU.",
    "LLR.PLAT.PSY.ETPUMEM.006": "If the values read back from the shared code memory do not match the original values\n              stored in flash, the platform  shall  raise an unrecoverable error.",
    "LLR.PLAT.PSY.ETPUMEM.007": "At runtime in the background task, the platform  shall  check the status of the\n              MISC-complete bit, incrementing the MISC-completion counter and clearing the bit if\n              it is set by the eTPU.",
    "LLR.PLAT.PSY.ETPUMEM.008": "The platform  shall  provide a digital data input channel to report the value of the\n              MISC-completion counter to the application.",
    "LLR.PLAT.PSY.ETPUMEM.009": "The platform  shall  keep a checksum value of necessary internal eTPU parameter variables",
    "LLR.PLAT.PSY.ETPUMEM.010": "The platform  shall  recalculate and update the checksum value each time one of the\n              variables is updated.",
    "LLR.PLAT.PSY.ETPUMEM.011": "If the calculated checksum does not match the expected checksum value, the platform\n               shall  increment the eTPU checksum fault counter.",
    "LLR.PLAT.PSY.ETPUMEM.012": "The platform  shall  provide a digital data input channel to report the value of the\n              eTPU checksum fault counter to the application.",
    "LLR.PLAT.PTM.SYSTIME.001": "The platform shall provide a C interface function named\n                ptm_get_sys_time() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U32\n                with a value of:\n              The current value of the system timer. \n Range: [0, 4294967295] ticks",
    "LLR.PLAT.PTM.SYSTIME.101": "The function ptm_get_sys_time() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PTM.SYSTIME.201": "The function ptm_get_sys_time() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PTM.SYSTIME.002": "The function  shall  return the number of ticks since the last reset.",
    "LLR.PLAT.PTM.SYSTIMEMS.001": "The platform shall provide a C interface function named\n                ptm_get_ms_time() that takes\n                no parameters.\n              \n                The function returns a value of type\n                U32\n                with a value of:\n              The current value of the millisecond timer. \n Range: [0, 4294967295] milliseconds",
    "LLR.PLAT.PTM.SYSTIMEMS.101": "The function ptm_get_ms_time() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PTM.SYSTIMEMS.201": "The function ptm_get_ms_time() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PTM.SYSTIMEMS.002": "The function  shall  return the number of milliseconds since the last reset.",
    "LLR.APP.PUT.MAP1D.001": "The application  shall  provide a monotonic series (increasing or decreasing) of index\n                axis values.",
    "LLR.PLAT.PUT.MAP1D.003": "The 1d interpolation routine  shall  not support extrapolation outside the maps\n                bounds. An input value exceeding the index axis limits shall result in an output\n                clipped to the map value corresponding to the exceeded index axis limit.",
    "LLR.PLAT.PUT.MAP1D.004": "A 1d linear interpolated value  shall  be deduced from the 1d map series when the\n                input value is within the bounds of the index axis.",
    "LLR.PLAT.PUT.MAP1D.001": "The platform shall provide a C interface function named\n                put_cal_map_1d_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_x\n          in\n        F32\nThe argument to z(x), a point on the x-axis for interpolation.putf_n\n          in\n        S32\nThe number of elements in the x-axis and z-data. If the number of elements is less than 1, the output is set to zero. If the number of elements is 1, the output it set to the only z-data value. If the number of elements is greater than 1, then the x-axis is searched for bounding breakpoints to perform the interpolation.putf_px\n          in\n        volatile const F32 *const\nPointer to array of the map's x-axis data. The values stored in the x-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.putf_pz\n          in\n        volatile const F32 *const\nPointer to array of the map's z-data. \n Cannot be NULL.putf_pzz\n          out\n        F32 *\nPointer to interpolated output. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.MAP1D.101": "The function put_cal_map_1d_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.MAP1D.201": "The function put_cal_map_1d_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.MAP1D.002": "The function  shall  reject calls with NULL pointers for any of its\n                pointer arguments and raise a recoverable error\n                PSY_PUT\/PUT_CALMAP_INVALID_ARG.",
    "LLR.PLAT.PUT.MAP1D.015": "The function  shall  linearly interpolate the value at point putf_x on the 1d lookup\n                table x-axis, and then write the result to putf_pzz.",
    "LLR.PLAT.PUT.MAP1D.016": "If the size of elements putf_n is specified as zero then zero  shall  be written\n                to the address pointed to by putf_pzz.",
    "LLR.PLAT.PUT.MAP1D.017": "The function  shall  use the putf_px and putf_pz arrays of size\n                putf_n as its 1d lookup table x-axis and z-data respectively.",
    "LLR.PLAT.PUT.MAP1D.005": "The platform shall provide a Simulink interface block named\n                put_Calmap1d that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionxInportReal\n        \n          The x-value at which a z-value is to be interpolated.\n          May be a scalar or a vector.\n        \n      z(x)OutportReal\n        \n          The value or values interpolated from\n          parameter Z Data at x.\n        \n      X-axis DataParamReal\n        \n          The name of the map's x axis\n          (e.g. vftm_mymap_x, see Section \"Naming rules\"). There\n          must be two or more elements in this parameter and that must be the same as the\n          number of elements in parameter Z data. The values of X-axis Data must increase\n          monotonically but adjacent  values may be the same.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Z DataParamReal\n        \n          The name of the map's z axis\n          (e.g. vftm_mymap_z, see Section \"Naming rules\"). There\n          must be two or more elements in this parameter and that must be the same as the\n          number of elements in X-axis Data.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PUT.MAP1D.105": "The block put_Calmap1d shall support the targets:\n            All targets.",
    "LLR.PLAT.PUT.MAP1D.205": "The block put_Calmap1d shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PUT.MAP1D.006": "If the parameters X-axis Data and\n                Z Data are not 1d vectors of (finite) single or double reals\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP1D.007": "If the parameter X-axis Data is not monotonically increasing or\n                decreasing then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP1D.008": "If the parameters X-axis Data and\n                Z Data array lengths are found to be unequal\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP1D.009": "If the parameters X-axis Data and\n                Z Data array length are found to be less than two elements\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP1D.010": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP1D.011": "The block  shall  schedule itself to run on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PUT.MAP1D.012": "The block  shall  linearly interpolate using the inport value x\n                between elements of the lookup table defined by the parameters X-axis Data\n                and Z Data, and write the result to the outport\n                z(x).",
    "LLR.APP.PUT.MAP2D.001": "The application  shall  provide a monotonic series (increasing or decreasing) of index\n              axis values, for both the x and y axes.",
    "LLR.PLAT.PUT.MAP2D.003": "The 2d interpolation routine  shall  not support extrapolation outside the maps bounds. An\n              input value exceeding the index axis limits shall result in an output clipped to the map\n              value corresponding to the exceeded index axis limit.",
    "LLR.PLAT.PUT.MAP2D.004": "A 2d bilinear interpolated value  shall  be deduced from the 2d map series when both input\n              values are within the bounds of their respective index axis.",
    "LLR.PLAT.PUT.MAP2D.001": "The platform shall provide a C interface function named\n                put_cal_map_2d_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_x\n          in\n        F32\nThe argument to z(x,y), a point on the x-axis for interpolation.putf_y\n          in\n        F32\nThe argument to z(x,y), a point on the y-axis for interpolation.putf_nx\n          in\n        S32\nThe number of elements in the x-axis and z(x,) data. If the number of elements is less than 1, the output is set to zero. If the number of elements is 1 (i.e., a 1d lookup if putf_ny is greater than one), the output it set to the first z-data value (call put_calmap_1d_f32() for a 1d table lookup and interpolate function). If the number of elements is greater than 1, then the x-axis is searched for bounding breakpoints to perform the interpolation.putf_ny\n          in\n        S32\nThe number of elements in the y-axis and z(,y) data. If the number of elements is less than 1, the output is set to zero. If the number of elements is 1 (i.e., a 1d lookup if putf_nx is greater than one), the output it set to the first z-data value (call put_calmap_1d_f32() for a 1d table lookup and interpolate function). If the number of elements is greater than 1, then the y-axis is searched for bounding breakpoints to perform the interpolation.putf_px\n          in\n        volatile const F32 *\nPointer to array of the map's x-axis data. The values stored in the x-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.putf_py\n          in\n        volatile const F32 *\nPointer to array of the map's y-axis. The values stored in the y-axis array must be monotonically increasing or decreasing. \n Cannot be NULL.putf_pz\n          in\n        volatile const F32 *\nPointer to array of the map's z-data. The array lookup is performed as { putf_pz[(x-index * putf_ny) + y-index] } and the data definition must correspond. \n Cannot be NULL.putf_pzz\n          out\n        F32 *\nPointer to interpolated output. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.MAP2D.101": "The function put_cal_map_2d_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.MAP2D.201": "The function put_cal_map_2d_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.MAP2D.002": "The function  shall  reject calls with NULL pointer for any of its\n              arguments and raise a recoverable error\n              PSY_PUT\/PUT_CALMAP_INVALID_ARG.",
    "LLR.PLAT.PUT.MAP2D.015": "The function  shall  linearly interpolate the value at point putf_x and\n                putf_y on the 2d lookup table, and then write the result to putf_pzz.",
    "LLR.PLAT.PUT.MAP2D.018": "If the size of elements putf_nx or putf_ny is specified as zero then\n                zero  shall  be written to the address pointed to by putf_pzz.",
    "LLR.PLAT.PUT.MAP2D.019": "The function  shall  use the putf_px, putf_py and putf_pz\n                arrays as its 2d lookup table x-axis, y-axis and z-data respectively.",
    "LLR.PLAT.PUT.MAP2D.005": "The platform shall provide a Simulink interface block named\n                put_Calmap2d that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionxInportReal\n        \n          The x-value at which a z-value is to be interpolated.\n          May be a scalar or a vector the same size as inport y.\n        \n      yInportReal\n        \n          The y-value at which a z-value is to be interpolated.\n          May be a scalar or a vector the same size as inport x.\n        \n      z(x,y)OutportReal\n        \n          The value or values interpolated from\n          parameter Z Data at x and y.\n        \n      X-axis DataParamReal\n        \n          The name of the map's x axis\n          (e.g. vftm_mymap_x, see Section \"Naming rules\"). There\n          must be two or more elements in this parameter and that must be the same as the\n          number of elements as columns in parameter Z Data. The values of X-axis Data\n          must increase monotonically but adjacent values may be the same.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Y-axis DataParamReal\n        \n          The name of the map's y axis\n          (e.g. vftm_mymap_y, see Section \"Naming rules\"). There\n          must be two or more elements in this parameter and that must be the same as the\n          number of elements as rows in parameter Z Data. The values of Y-axis Data must\n          increase monotonically but adjacent values may be the same.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Z DataParamReal\n        \n          The name of the map's z matrix\n          (e.g. vftm_mymap_z, see Section \"Naming rules\").\n          There must be the same number of rows as  elements in parameter Y-axis Data\n          and number of columns as elements in parameter X-axis Data.\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.\n              Sample timeParamReal\n        \n          The periodicity of the block execution.\n        \n        \n          Range: [0.001, 3600] seconds\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PUT.MAP2D.105": "The block put_Calmap2d shall support the targets:\n            All targets.",
    "LLR.PLAT.PUT.MAP2D.205": "The block put_Calmap2d shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PUT.MAP2D.006": "If the parameters X-axis Data and\n                Y-axis Data are not 1d vectors of (finite) single or double reals then\n                the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.007": "If the parameters X-axis Data and\n                Y-axis Data are not monotonically increasing or decreasing then\n                the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.008": "If the parameter Z Data is not a 2d vector of\n                (finite) single or double reals then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.009": "If the length of X-axis Data is not equal to the number of\n                columns in the Z Data array, then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.010": "If the length of Y-axis Data is not equal to the number of\n                rows in the Z Data array, then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.011": "If the parameters X-axis Data and\n                Y-axis Data array lengths are found to be less than two elements,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.012": "If the parameter Sample time is outside its\n                range and resolution then the block  shall  raise an error.",
    "LLR.PLAT.PUT.MAP2D.014": "The block  shall  schedule itself to run on target at the rate\n                specified by parameter Sample time.",
    "LLR.PLAT.PUT.MAP2D.016": "The block  shall  linearly interpolate using the inport values x and\n                y\n                between elements of the lookup table defined by the parameters X-axis Data,\n                Y-axis Data and\n                Z Data, and write the result to the outport\n                z(x,y).",
    "LLR.APP.PUT.DEBCYCINIT.002": "The following stores  shall  be initialised:\n              \n                  The state of the input last time the debounce function was invoked to PUT_INVALID_STATE\n                  The debounced steady state of the input to PUT_INVALID_STATE\n                  The number of cycles the input has been steady for to 1",
    "LLR.PLAT.PUT.DEBCYCLE.010": "The debounce function  shall  only debounce binary states.",
    "LLR.PLAT.PUT.DEBCYCLE.003": "On the first call, the function  shall  set the debounced output state to the logical\n              input state.",
    "LLR.PLAT.PUT.DEBCYCLE.005": "When the logical input state is unchanged for the cycle\n              threshold (the signal is deemed steady) the\n              debounced output state  shall  change to the logical input state.",
    "LLR.PLAT.PUT.DEBCYCINIT.001": "The platform shall provide a C interface function named\n                put_debounce_by_cycles_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_store\n          in\/out\n        PUT_DEBOUNCE_CYCLE_T *const\nA pointer to a store of information relating to the input signal. Not to be accessed by the application. Initialise the store by calling put_debounce_by_cycles_init(). \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.DEBCYCINIT.101": "The function put_debounce_by_cycles_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.DEBCYCINIT.201": "The function put_debounce_by_cycles_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.DEBCYCINIT.002": "The function put_debounce_by_cycles_init  shall  reject calls with a NULL pointer\n                for the following parameter putf_store by raising a recoverable error\n                PSY_PUT\/PUT_DEBOUNCE_BY_CYCLES_INVALID_ARG.",
    "LLR.PLAT.PUT.DEBCYCINIT.003": "The function  shall  initialise the stored\n              state of the input last time the debounce function was invoked to\n              PUT_INVALID_STATE.",
    "LLR.PLAT.PUT.DEBCYCINIT.004": "The function  shall  initialise the stored\n              debounced steady state of the input to PUT_INVALID_STATE.",
    "LLR.PLAT.PUT.DEBCYCINIT.005": "The function  shall  initialise the stored\n              number of cycles the input has been steady for to 1.",
    "LLR.PLAT.PUT.DEBCYCLE.001": "The platform shall provide a C interface function named\n                put_debounce_by_cycles() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_input\n          in\n        U8\nThe current state. \n Range: [0, 1] unitlessputf_cycle_threshold\n          in\n        U16\nThe number of cycles of unchanging input required before the input state (putf_input) is deemed steady. Set to zero or one for no debounce. \n Range: [0, 65535] cyclesputf_store\n          in\/out\n        PUT_DEBOUNCE_CYCLE_T *const\nA pointer to a store of information relating to the input signal. Not to be accessed by the application. Initialise the store by calling put_debounce_by_cycles_init(). \n Cannot be NULL.\n                The function returns a value of type\n                U8\n                with a value of:\n              The debounced state. \n Range: [0, 1] unitless",
    "LLR.PLAT.PUT.DEBCYCLE.101": "The function put_debounce_by_cycles() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.DEBCYCLE.201": "The function put_debounce_by_cycles() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.DEBCYCLE.002": "The function put_debounce_by_cycles  shall  reject calls with a NULL pointer\n                for the following parameter putf_store by raising a recoverable error\n              PSY_PUT\/PUT_DEBOUNCE_BY_CYCLES_INVALID_ARG.",
    "LLR.PLAT.PUT.DEBCYCLE.011": "The function  shall  use the storage space pointed to by putf_store parameter\n                to retain debounce information for the specific input channel across calls.",
    "LLR.PLAT.PUT.DEBCYCLE.012": "On the first call, the function  shall  set the debounced output state to the logical\n              input state putf_input.",
    "LLR.PLAT.PUT.DEBCYCLE.013": "When the logical input state, putf_input is unchanged for the cycle\n              threshold putf_cycle_threshold, the function  shall  return the value\n              of the logical input state putf_input.",
    "LLR.PLAT.PUT.DEBCYCLE.006": "The platform shall provide a Simulink interface block named\n                put_Debounce that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptiontransient_stateInportBoolean\n        \n          Transient state to debounce.\n        \n      debounced_stateOutportBoolean\n        \n          The\n          debounced state. On the first iteration, the internal debounced state\n          is set to the input transient_state.\n        \n      Debounce wait cyclesParamInteger\n        \n          The number of block\n          iterations (cycles) for which the input has to be steady before the output\n          follows it.\n        \n        \n          Range: [0, 65535] cycles\n        \n      \n                Calibratable: used during initialisation (power-up) and run-time.",
    "LLR.PLAT.PUT.DEBCYCLE.106": "The block put_Debounce shall support the targets:\n            All targets.",
    "LLR.PLAT.PUT.DEBCYCLE.206": "The block put_Debounce shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PUT.DEBCYCLE.007": "If the parameter Debounce wait cycles is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.DEBCYCLE.008": "The block  shall  schedule itself to run on target at the rate\n                specified by the subsystem that the block is within.",
    "LLR.PLAT.PUT.DEBCYCLE.009": "The block  shall  debounce the value of the inport transient_state\n                over the number of cycles defined by parameter Debounce wait cycles and\n                write the result to the outport debounced_state.",
    "LLR.PLAT.PUT.DEBTIMEINIT.001": "The platform shall provide a C interface function named\n                put_debounce_by_time_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_channel_wrk_data\n          out\n        PUT_DEBOUNCE_TIME_T *\nPointer to logical input signal workspace data structure. This provides persistence for data in between calls to the filter function.\n                The function returns void.",
    "LLR.PLAT.PUT.DEBTIMEINIT.101": "The function put_debounce_by_time_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.DEBTIMEINIT.201": "The function put_debounce_by_time_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.DEBTIMEINIT.002": "The function  shall  reject calls with a NULL pointer for the following\n              parameter putf_channel_wrk_data by raising a recoverable error\n              PSY_PUT\/PUT_DEBOUNCE_BY_TIME_INVALID_ARG.",
    "LLR.APP.PUT.DEBTIMEINIT.001": "The function put_debounce_by_time_init  shall  be invoked to initialise\n              the data store prior to calls to the debounce by time function.",
    "LLR.PLAT.PUT.DEBTIMEINIT.003": "The put_debounce_by_time_init function  shall  initialise to 1 the\n              stored accumulator which sets the debounced output state.",
    "LLR.PLAT.PUT.DEBTIMEINIT.004": "The put_debounce_by_time_init function  shall  initialise to 1 the\n              stored accumulator which resets the debounced output state.",
    "LLR.PLAT.PUT.DEBTIMEINIT.005": "The put_debounce_by_time_init function  shall  initialise the debounced\n              output state to 0.",
    "LLR.PLAT.PUT.DEBTIME.001": "The platform shall provide a C interface function named\n                put_debounce_by_time() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_raw_state\n          in\n        U8\nThe value of the logical input signal (e.g., as obtained from a call to the pdx_digital_input() function). \n Range: 0 or 1.putf_sample_rate\n          in\n        F32\nThe rate at which this function is called for debounce computation (effectively the amount of time since the last call). Ideally this function should be called at the same rate as the input state sampling but the function can be called less frequently if necessary. As an example, if an input state must be checked 5 times within a debounce period of 1 second (for both set and reset steady states) then the function could be called every 200 milliseconds. \n Range: [0.001, 3600] secondsputf_invert\n          in\n        U8\nChannel inversion. If inversion is set, then a logical NOT operation is applied to the input value before further processing.putf_set_dead_time\n          in\n        F32\nSet dead time. The time in seconds the input will have to be high, before the function switches its output from 0 to 1. A zero or negative value causes the debounced state to be set to the input state without delay.putf_reset_dead_time\n          in\n        F32\nReset dead time. The time in seconds the input will have to be low, before the function switches its output from 1 to 0. A zero or negative value causes the debounced state to be set to the input state without delay.putf_debounced_state\n          out\n        U8 *\nPointer to the value that will represent the output of the logical input debounced state. \n Cannot be NULL.putf_channel_wrk_data\n          in\/out\n        PUT_DEBOUNCE_TIME_T *\nPointer to logical signal channel workspace data structure. This provides persistence for data in between calls to the filter function. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.DEBTIME.101": "The function put_debounce_by_time() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.DEBTIME.201": "The function put_debounce_by_time() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.DEBTIME.002": "The function  shall  reject calls with a NULL pointer for any of the\n              following parameter putf_debounced_state or\n              putf_channel_wrk_data by raising a recoverable error\n              PSY_PUT\/PUT_DEBOUNCE_BY_TIME_INVALID_ARG.",
    "LLR.PLAT.PUT.DEBTIME.003": "The function  shall  reject calls where the parameter putf_sample_rate\n              is less than zero, by raising a recoverable error\n              PSY_PUT\/PUT_DEBOUNCE_BY_TIME_INVALID_ARG.",
    "LLR.APP.PUT.DEBTIME.001": "The application  shall  call the function with a putf_store previously initialised with\n              put_debounce_by_time_init.",
    "LLR.APP.PUT.DEBTIME.002": "The application  shall  only used the debounce function for binary states.",
    "LLR.PLAT.PUT.DEBTIME.004": "On the first call, the debounced output state  shall  be set to the logical input state\n              putf_raw_state.",
    "LLR.PLAT.PUT.DEBTIME.006": "When the logical input state putf_raw_state is high for a time\n              putf_set_dead_time the debounced output state  shall  change to high.",
    "LLR.PLAT.PUT.DEBTIME.007": "When the logical input state putf_raw_state is low for a time\n              putf_reset_dead_time the debounced output state  shall  change to low.",
    "LLR.PLAT.PUT.DEBTIME.008": "When channel inversion putf_invert is set, the putf_input is inverted\n              prior to all processing.",
    "LLR.PLAT.PUT.DUTYCYC.001": "The platform shall provide a C interface function named\n                put_dutycycle_processing() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_inp_duty_cycle\n          in\n        F32\nThe input duty cycle value. \n Range: [0, 1] unitlessputf_invert\n          in\n        U8\nIf inversion is set the scaled duty cycle is converted as follows: \n scaled_duty_cycle = 1.0 - scaled_duty_cycle \n Range: [0, 1] unitless flagputf_fault\n          in\n        U8\nIf true it forces the output value to be equal to putf_default, no effect otherwise. \n Range: [0, 1] unitless flagputf_default\n          in\n        F32\nUsed to set the output value when putf_fault is true, no effect otherwise. \n Range: [0, 1] unitlessputf_min\n          in\n        F32\nLower threshold value in scaling the input duty cycle. \n Range: [0, 1] unitlessputf_max\n          in\n        F32\nUpper threshold value in scaling the input duty cycle. \n Range: [0, 1] unitlessputf_out_duty_cycle\n          out\n        F32 *\nPointer to the value that will represent the output duty cycle. \n Cannot be NULL. \n Range: [0, 1] unitless\n                The function returns void.",
    "LLR.PLAT.PUT.DUTYCYC.101": "The function put_dutycycle_processing() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.DUTYCYC.201": "The function put_dutycycle_processing() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.DUTYCYC.002": "The function  shall  reject calls where a NULL pointer is passed for\n              the parameter putf_out_duty_cycle by raising a recoverable error\n              PSY_PUT\/PUT_DUTYCYCLE_PROCESSING_INVALID_ARG.",
    "LLR.PLAT.PUT.DUTYCYC.003": "The function  shall  reject calls where the parameter putf_min exceeds\n              or equals the parameter putf_max by raising a recoverable error\n              PSY_PUT\/PUT_DUTYCYCLE_PROCESSING_INVALID_ARG",
    "LLR.PLAT.PUT.DUTYCYC.004": "The function  shall  clip the parameter putf_min to 0.0 if\n              putf_min falls below 0.0.",
    "LLR.PLAT.PUT.DUTYCYC.005": "The function  shall  clip the parameter putf_max to 1.0 if\n              putf_min exceeds 1.0.",
    "LLR.PLAT.PUT.DUTYCYC.006": "The function  shall  clip the input duty cycle parameter\n              putf_inp_duty_cycle to the bounds of 0..1.",
    "LLR.PLAT.PUT.DUTYCYC.007": "This function  shall  provide a scaling of the input duty cycle as follows:\n              scaled_duty_cycle = (input_duty_cycle * (max - min)) + min",
    "LLR.PLAT.PUT.DUTYCYC.008": "If inversion is set the scaled duty cycle  shall  be converted as follows:\n              scaled_duty_cycle = 1.0 - scaled_duty_cycle",
    "LLR.PLAT.PUT.DUTYCYC.009": "If the fault parameter putf_fault is set the output duty cycle  shall \n              be set to the default value putf_default.",
    "LLR.PLAT.PUT.ENHANALOGINIT.001": "The platform shall provide a C interface function named\n                put_enh_process_analog_input_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_adc_channel_wrk_data\n          in\n        PUT_ENH_ANALOGUE_WORKSPACE_T *const\nPointer to A\/D channel workspace data structure. This provides persistence for data in between calls to the filter function. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.ENHANALOGINIT.101": "The function put_enh_process_analog_input_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.ENHANALOGINIT.201": "The function put_enh_process_analog_input_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.ENHANALOGINIT.002": "The function  shall  reject calls with a NULL pointer for the parameter\n              putf_adc_channel_wrk_data by raising a recoverable error\n              PSY_PUT\/PUT_ANALOG_INPUT_FILTER_INVALID_ARG.",
    "LLR.PLAT.PUT.ENHANALOGINIT.003": "This function initialises any persistent data for an analogue channel prior to it first\n              being called.",
    "LLR.PLAT.PUT.ENHANALOGINIT.004": "The persistent data for an analogue channel  shall  consist of the following parameters:\n            \nLast raw value read in by the analogue channel last_raw_value,\nLatched engineering value for transient faults latched_engineering_value,\nA persistent data store for a slew rate input check slew_rate_data\nA persistent data store for leaky bucket fault filtering leaky_bucket_data",
    "LLR.PLAT.PUT.ENHANALOGINIT.005": "The function  shall  initialise the stored last raw value read in by the analogue channel to zero.\n              The function shall initialise the stored latched engineering value for transient faults to zero.",
    "LLR.PLAT.PUT.ENHANALOG.001": "The platform shall provide a C interface function named\n                put_enh_process_analog_input() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_raw_adc_value\n          in\n        F32\nThe raw A\/D value as obtained from a call to the basic analogue input code. \n Range: [-4096, 4096] A\/D countsputf_adc_sample_rate\n          in\n        F32\nThe rate at which this function is called for fault filtering on the given A\/D channel raw values. \n Range: [0.001, 3600] secondsputf_analogue_value\n          out\n        F32 *const\nPointer to the value that will represent the output of the A\/D conversion to an engineering value once the fault filtering has taken place. \n Cannot be NULL.putf_confirmed_min_raw_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value being below the minimum allowed value. \n Cannot be NULL.putf_confirmed_max_raw_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value being above the maximum allowed value. \n Cannot be NULL.putf_confirmed_slew_rate_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the raw A\/D value changing faster than the maximum allowed slew rate value. \n Cannot be NULL.putf_confirmed_min_eng_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the engineering A\/D value being below the minimum allowed value. \n Cannot be NULL.putf_confirmed_max_eng_range_fault\n          out\n        U8 *const\nPointer to the flag that will indicate if a confirmed fault has been recorded due to the engineering A\/D value being above the maximum allowed value. \n Cannot be NULL.putf_transient_fault_flag\n          out\n        U8 *const\nPointer to the flag that will indicate if a transient fault has been detected. This will cause the output analogue value to be latched at the last valid engineering value or zero if the fault is present on the first iteration. \n Cannot be NULL.putf_adc_channel_cal_data\n          in\n        const PUT_ANALOGUE_CAL_DATA_T *const\nPointer to A\/D channel calibration data structure. \n Cannot be NULL.putf_adc_channel_wrk_data\n          in\n        PUT_ENH_ANALOGUE_WORKSPACE_T *const\nPointer to enhanced A\/D channel workspace data structure. This provides persistence for data in between calls to the filter function. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.ENHANALOG.101": "The function put_enh_process_analog_input() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.ENHANALOG.201": "The function put_enh_process_analog_input() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.ENHANALOG.002": "The function  shall  reject calls with a NULL\n            pointer is any of the following parameters\n            putf_analogue_value,\n            putf_confirmed_min_raw_range_fault,\n            putf_confirmed_max_raw_range_fault,\n            putf_confirmed_slew_rate_fault,\n            putf_confirmed_min_eng_range_fault,\n            putf_confirmed_max_eng_range_fault,\n            putf_transient_fault_flag,\n            putf_adc_channel_cal_data or\n            putf_adc_channel_wrk_data\n            by raising a recoverable  error PSY_PUT\/PUT_ANALOG_INPUT_FILTER_INVALID_ARG.",
    "LLR.PLAT.PUT.ENHANALOG.003": "The analogue processing function  shall  convert a raw ADC value\n            putf_raw_adc_value into an engineering value using the 1d table lookup\n            given in the data structure putf_adc_channel_cal_data.",
    "LLR.PLAT.PUT.ENHANALOG.004": "If the raw ADC value is outside the bounds of allowable raw ADC values,\n            [putf_confirmed_min_raw_range_fault\n            .. putf_confirmed_max_raw_range_fault], the transient fault error flag\n            putf_transient_fault_flag shall  be raised at the interface of the\n            analogue processing function.",
    "LLR.PLAT.PUT.ENHANALOG.005": "If the rate of change of the raw ADC value falls outside the bounds of the allowable slew\n            rates, the function  shall  raise the putf_transient_fault_flag flag.",
    "LLR.PLAT.PUT.ENHANALOG.006": "If the converted engineering value is outside the bounds of allowable values, the function\n             shall  raise the putf_transient_fault_flag.",
    "LLR.PLAT.PUT.ENHANALOG.007": "The function  shall  apply a leaky bucket routine to each transient error flag to determine if\n            a fault is persistent.",
    "LLR.PLAT.PUT.ENHANALOG.008": "Upon a fault being confirmed as persistent, the analogue processing routine  shall  set its\n            confirmed fault flag. The leaky bucket parameters passed in the cal data struct shall be\n            used.",
    "LLR.PLAT.PUT.ENHANALOG.009": "If the leaky bucket for a fault is not full, or has emptied past the hysteresis threshold\n            having previously been full, the confirmed fault flag  shall  be cleared.",
    "LLR.PLAT.PUT.LEAKYBUCKET.001": "The platform shall provide a C interface function named\n                put_leaky_bucket_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_fall_rate\n          in\n        F32\nThe leak rate of the buckets applied to all faults in this call. \n Range: [0, 1000] units per secondputf_rise_rate\n          in\n        F32\nThe fill rate of the buckets applied to all faults in this call. \n Range: [0, 1000] units per secondputf_hyst\n          in\n        F32\nThe level below which the fault is confirmed absent. If the hysteresis is negative, then the fault will be confirmed present and never become confirmed absent. \n Range: [-1, 1] unitlessputf_delta_time\n          in\n        F32\nThe difference in time since the last call to this function for all faults in this call. \n Units: secondsputf_n\n          in\n        U32\nNumber of elements in arrays putf_tff, putf_cff and putf_store.putf_tff\n          in\n        volatile const F32 *const\nPointer to array of transient fault indicators. A fault is present if the corresponding array element is true (non-zero), a fault is absent otherwise.putf_cff\n          out\n        F32 *const\nPointer to array of confirmed fault indicators. A fault is confirmed present if the corresponding array element is true (non-zero), a fault is confirmed absent otherwise.putf_store\n          in\/out\n        PUT_LEAKY_BUCKET_T *const\nA pointer to a store of information relating to a leaky bucket for each fault in putf_tff. Not to be accessed by the application. Call put_leaky_bucket_init() to initialise the store.\n                The function returns void.",
    "LLR.PLAT.PUT.LEAKYBUCKET.101": "The function put_leaky_bucket_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.LEAKYBUCKET.201": "The function put_leaky_bucket_f32() shall be in the license group:\n                      None (Main library).\n                    Rationale: \n              Simulink can potentially introduce a boolean flag of type single precision floating\n              point.  The put_leaky_bucket_f32() function supports the boolean flag of type single\n              precision floating point.",
    "LLR.PLAT.PUT.LEAKYBUCKET.002": "The function  shall  reject calls with an NULL pointer is any of the\n              following parameters putf_tff, putf_cff or\n              putf_store by raising a recoverable error\n              PSY_PUT\/PUT_LEAKY_BUCKET_INVALID_ARG.",
    "LLR.APP.PUT.LEAKYBUCKET.001": "The application  shall  call the function with a putf_store previously\n              initialised with put_leaky_bucket_init.",
    "LLR.APP.PUT.LEAKYBUCKET.002": "The application  shall  call the function with the same putf_n value as\n              used in the put_leaky_bucket_init call.",
    "LLR.APP.PUT.LEAKYBUCKET.003": "The application  shall  call the function with both arrays putf_tff and\n              putf_cff of size putf_n.",
    "LLR.PLAT.PUT.LEAKYBUCKET.003": "The leaky bucket routine  shall  operate on an array of values and output the leaky bucket\n              level.\n            Rationale: \n              To support the Simulink multiport block which can pass an array of values to the\n              platform.",
    "LLR.PLAT.PUT.LEAKYBUCKET.004": "A transient fault  shall  result in the leaky bucket level increasing by the product of\n              the fill rate  putf_rise_rate and the time difference since the last\n              call to the routine putf_delta_time.",
    "LLR.PLAT.PUT.LEAKYBUCKET.005": "Regardless of the presence of an input fault the leaky bucket level  shall  be continually\n              decreased by the product of the leak rate putf_fall_rate and\n               putf_delta_time the time difference since the last call to this\n              function for all faults in this call.",
    "LLR.PLAT.PUT.LEAKYBUCKET.006": "The leaky bucket level  shall  be clipped within the bounds of the full level of 1.0 and\n              the empty level of 0.",
    "LLR.PLAT.PUT.LEAKYBUCKET.007": "The leaky bucket routine  shall  result in a confirmed fault when the leaky bucket level\n              exceeds or equals the full level of 1.0.",
    "LLR.PLAT.PUT.LEAKYBUCKET.008": "A confirmed fault  shall  persist until the leaky bucket level falls below the hysteresis\n              level putf_hyst.",
    "LLR.PLAT.PUT.LEAKYINIT.001": "The platform shall provide a C interface function named\n                put_leaky_bucket_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_n\n          in\n        U32\nNumber of elements in arrays putf_tff, putf_cff and putf_store.putf_store\n          out\n        PUT_LEAKY_BUCKET_T *const\nA pointer to a store of information relating to a leaky bucket for each fault in putf_tff. Not to be accessed by the application. This function initialises the stores.\n                The function returns void.",
    "LLR.PLAT.PUT.LEAKYINIT.101": "The function put_leaky_bucket_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.LEAKYINIT.201": "The function put_leaky_bucket_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.LEAKYINIT.002": "The function  shall  reject calls with an NULL pointer for the\n              following parameter putf_store by raising a recoverable error\n              PSY_PUT\/PUT_LEAKY_BUCKET_INVALID_ARG.",
    "LLR.APP.PUT.LEAKYINIT.001": "The application  shall  allocate a variable of type PUT_LEAKY_BUCKET_T\n              and of size putf_n.\n            Note: \n              The function initialise several buckets simultaneously. This can be used to monitor\n              several faults, but all faults will be monitored with the same\n              rise\/fall\/hyst\/delta_time parameters.",
    "LLR.APP.PUT.LEAKYINIT.002": "Prior to calling the leaky bucket function on successive occasions, the application  will \n              invoke the put_leaky_bucket_init function to initialise the persistent data store which\n              is used to maintain information across successive calls to the function.",
    "LLR.PLAT.PUT.LEAKYINIT.003": "The function  shall  initialise all leaky bucket levels to 0.",
    "LLR.PLAT.PUT.LEAKYINIT.004": "The function  shall  initialise all confirmed fault states to false.",
    "LLR.PLAT.PUT.LEAKYBUCKET.081": "The platform shall provide a C interface function named\n                put_leaky_bucket_u8() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_fall_rate\n          in\n        F32\nThe leak rate of the buckets applied to all faults in this call. \n Range: [0, 1000] units per secondputf_rise_rate\n          in\n        F32\nThe fill rate of the buckets applied to all faults in this call. \n Range: [0, 1000] units per secondputf_hyst\n          in\n        F32\nThe level below which the fault is confirmed absent. If the hysteresis is negative, then the fault will be confirmed present and never become confirmed absent. \n Range: [-1, 1] unitlessputf_delta_time\n          in\n        F32\nThe difference in time since the last call to this function for all faults in this call. \n Units: secondsputf_n\n          in\n        U32\nNumber of elements in arrays putf_tff, putf_cff and putf_store.putf_tff\n          in\n        volatile const U8 *\nPointer to array of transient fault indicators. A fault is present if the corresponding array element is true (non-zero), a fault is absent otherwise.putf_cff\n          out\n        U8 *\nPointer to array of confirmed fault indicators. A fault is confirmed present if the corresponding array element is true (non-zero), a fault is confirmed absent otherwise.putf_store\n          in\/out\n        PUT_LEAKY_BUCKET_T *\nA pointer to a store of information relating to a leaky bucket for each fault in putf_tff. Not to be accessed by the application. Call put_leaky_bucket_init() to initialise the store.\n                The function returns void.",
    "LLR.PLAT.PUT.LEAKYBUCKET.181": "The function put_leaky_bucket_u8() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.LEAKYBUCKET.281": "The function put_leaky_bucket_u8() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.LEAKYBUCKET.102": "The function  shall  reject calls with an NULL pointer is any of the\n              following parameters putf_tff, putf_cff or\n              putf_store by raising a recoverable error\n              PSY_PUT\/PUT_LEAKY_BUCKET_INVALID_ARG.",
    "LLR.PLAT.PUT.LEAKYBUCKET.103": "The leaky bucket routine  shall  operate on an array of values and output the leaky bucket\n              level.\n            Rationale: \n              To support the Simulink multiport block which can pass an array of values to the\n              platform.",
    "LLR.PLAT.PUT.LEAKYBUCKET.104": "A transient fault  shall  result in the leaky bucket level increasing by the product of\n              the fill rate  putf_rise_rate and the time difference since the last\n              call to the routine putf_delta_time.",
    "LLR.PLAT.PUT.LEAKYBUCKET.105": "Regardless of the presence of an input fault the leaky bucket level  shall  be continually\n              decreased by the product of the leak rate putf_fall_rate and\n               putf_delta_time the time difference since the last call to this\n              function for all faults in this call.",
    "LLR.PLAT.PUT.LEAKYBUCKET.106": "The leaky bucket level  shall  be clipped within the bounds of the full level of 1.0 and\n              the empty level of 0.",
    "LLR.PLAT.PUT.LEAKYBUCKET.107": "The leaky bucket routine  shall  result in a confirmed fault when the leaky bucket level\n              exceeds or equals the full level of 1.0.",
    "LLR.PLAT.PUT.LEAKYBUCKET.108": "A confirmed fault  shall  persist until the leaky bucket level falls below the hysteresis\n              level putf_hyst.",
    "LLR.PLAT.PUT.ANALOGINIT.001": "The platform shall provide a C interface function named\n                put_process_analog_input_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_adc_channel_wrk_data\n          in\n        PUT_ANALOGUE_WORKSPACE_T *const\nPointer to A\/D channel workspace data structure. This provides persistence for data in between calls to the filter function. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.ANALOGINIT.101": "The function put_process_analog_input_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.ANALOGINIT.201": "The function put_process_analog_input_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.ANALOGINIT.002": "The function  shall  reject calls with a NULL pointer for the parameter\n              putf_adc_channel_wrk_data by raising a recoverable error\n              PSY_PUT\/PUT_ANALOG_INPUT_FILTER_INVALID_ARG.",
    "LLR.PLAT.PUT.ANALOGINIT.003": "This function initialises any persistent data for an analogue channel prior to it first\n              being called.",
    "LLR.PLAT.PUT.ANALOGINIT.004": "The persistent data for an analogue channel  shall  consist of the following parameters:\n            Last raw value read in by the analogue channel last_raw_value,\nLatched engineering value for transient faults latched_engineering_value,\nFlag to indicate if a confirmed fault has been detected confirmed_fault_present,\nFlags to indicate the latched value of a transient fault flag is due to\n        the raw value being greater than allowed latched_max_raw_range_tff\n        the raw value being less than allowed latched_min_raw_range_tff\n        the slew rate being greater than allowed latched_slew_rate_tff\n        the engineering value being greater than allowed latched_max_eng_range_tff\n        the engineering value being less than allowed latched_min_eng_range_tff\nA persistent data store for a slew rate input check slew_rate_data\nA persistent data store for leaky bucket fault filtering leaky_bucket_data",
    "LLR.PLAT.PUT.ANALOGINIT.005": "The function  shall  initialise the stored last raw value read in by the analogue channel to zero.\n              The function shall initialise the stored latched engineering value for transient faults to zero.\n              The function shall initialise the stored flag to indicate if a confirmed fault has been detected to FALSE.",
    "LLR.PLAT.PUT.ANALOGINIT.006": "The latched values for all the transient fault flags  shall  be initialised to FALSE.",
    "LLR.PLAT.PUT.INRANGEF32.001": "The platform shall provide a C interface function named\n                put_range_check_f32() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_n\n          in\n        U32\nNumber of elements in vectors putf_value, putf_max, putf_min, putf_gt and putf_lt. \n Range: [1, 4294967295] elementsputf_value\n          in\n        volatile const F32 *\nPointer to array of values. \n Cannot be NULL.putf_max\n          in\n        volatile const F32 *\nPointer to array of values. Each value is compared against the corresponding element in putf_value. \n Cannot be NULL.putf_min\n          in\n        volatile const F32 *\nPointer to array of values. Each value is compared against the corresponding element in putf_value. \n Cannot be NULL.putf_gt\n          in\n        void *\nPointer to array of flags. Each flag is the result of: putf_value[i] > putf_max[i]. The type of each flag is determined by putf_use_bool_type. \n Cannot be NULL.putf_lt\n          in\n        void *\nPointer to array of flags. Each flag is the result of: putf_value[i] < putf_min[i]. The type of each flag is determined by putf_use_bool_type. \n Cannot be NULL.putf_use_bool_type\n          in\n        U8\nTrue if boolean types are stored as 8-bit integers, false if boolean types are stored as 32-bit floating point.\n                The function returns void.",
    "LLR.PLAT.PUT.INRANGEF32.101": "The function put_range_check_f32() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.INRANGEF32.201": "The function put_range_check_f32() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.INRANGEF32.002": "The application  shall  check that none of the pointers putf_value,\n              putf_max, putf_min, putf_gt,\n              putf_lt are NULL and raise a recoverable error\n              PSY_PUT\/PUT_RANGE_CHECK_INVALID_ARG otherwise.",
    "LLR.APP.PUT.INRANGEF32.001": "The application  shall  call the function with arrays putf_max,\n              putf_min, putf_gt, putf_lt of\n              size putf_n.",
    "LLR.PLAT.PUT.INRANGEF32.003": "The routine  shall  raise the putf_gt[n] flag if the input\n              putf_value is greater than putf_max[n].",
    "LLR.PLAT.PUT.INRANGEF32.004": "The routine  shall  raise the putf_lt[n] flag if the input\n              putf_value is less than putf_min[n].",
    "LLR.PLAT.PUT.INRANGEF32.005": "The flags returned to indicate which bound has been exceeded  shall  be either of type\n              single precision floating point or unsigned byte depending on putf_use_bool_type.",
    "LLR.PLAT.PUT.SLEWINIT.001": "The platform shall provide a C interface function named\n                put_slew_rate_check_init() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_store\n          in\/out\n        PUT_SLEW_RATE_CHECK_T *const\nA pointer to a store of information relating to the input signal. Not to be accessed by the application. \n Cannot be NULL.\n                The function returns void.",
    "LLR.PLAT.PUT.SLEWINIT.101": "The function put_slew_rate_check_init() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.SLEWINIT.201": "The function put_slew_rate_check_init() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.SLEWINIT.002": "The function  shall  reject calls with a NULL pointer for the following\n              parameter putf_store by raising a recoverable error\n              PSY_PUT\/PUT_SLEW_RATE_CHECK_INVALID_ARG.",
    "LLR.APP.PUT.SLEWINIT.001": "The application  shall  invoke the put_slew_rate_check_init function to\n              initialise the data store for that slew rate check prior to any subsequent calls to\n              function put_slew_rate_check.",
    "LLR.PLAT.PUT.SLEWINIT.003": "The put_slew_rate_check_init function  shall  initialise a flag indicating the slew check\n              function has not been called previously to TRUE.",
    "LLR.PLAT.PUT.SLEWINIT.004": "The put_slew_rate_check_init function  shall  initialise the value of the input last time\n              the slew check function was invoked to zero.",
    "LLR.PLAT.PUT.SLEW.001": "The platform shall provide a C interface function named\n                put_slew_rate_check() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_input\n          in\n        F32\nThe current value of the input. \n Units: noneputf_slew_rate_limit\n          in\n        F32\nThe rate of change limit. Negative values are clipped to zero. \n Units: \/secondputf_delta_time\n          in\n        F32\nThe difference in time since the last call to this function. On the first call to this function, this parameter is ignored. \n Units: secondsputf_store\n          in\/out\n        PUT_SLEW_RATE_CHECK_T *const\nA pointer to a store of information relating to the input signal. Not to be accessed by the application. Initialise the store by calling put_slew_rate_check_init(). \n Cannot be NULL.\n                The function returns a value of type\n                BOOL\n                with a value of:\n              True if the input rate of change exceeds the limit, false otherwise.",
    "LLR.PLAT.PUT.SLEW.101": "The function put_slew_rate_check() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.SLEW.201": "The function put_slew_rate_check() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.SLEW.002": "If putf_store is NULL, the function  shall  raise recoverable error\n              PSY_PUT\/PUT_SLEW_RATE_CHECK_INVALID_ARG.",
    "LLR.PLAT.PUT.SLEW.003": "On the first call to the slew rate check function, the function  shall  return false.",
    "LLR.PLAT.PUT.SLEW.004": "The slew rate function  shall  return true when the rate of change of the input variable\n              pcxf_input exceeds the slew rate limit and false otherwise.\n            \n              abs(input - <previous value of putf_input>) > putf_delta_time * putf_slew_rate_limit",
    "LLR.PLAT.PUT.REQPLAT.001": "The platform shall provide a Simulink interface block named\n                put_RequirePlatformVersion that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionCheckParamList\n        \n          A drop-down of methods for restricting\n          the version of platform to use when building.\n        \n      \n                Calibratable: no.\n              VersionParamText\n        \n          The literal text of the version\n          number (e.g., 1.5.0) that the platform must equal in order to\n          be able to build the model. Only available when the Check parameter is set to\n          Single version.\n        \n      \n                Calibratable: no.\n              Before versionParamText\n        \n          The literal text of the version\n          number (e.g., 1.5.0) that the platform come before (not inclusive)\n          in order to be able to build the model. Only available when the Check parameter is\n          set to Before version.\n        \n      \n                Calibratable: no.\n              After versionParamText\n        \n          The literal text of the version\n          number (e.g., 1.5.0) that the platform come after (not inclusive)\n          in order to be able to build the model. Only available when the Check parameter is\n          set to After version.\n        \n      \n                Calibratable: no.\n              From versionParamText\n        \n          The literal text of the version\n          number (e.g., 1.5.0) that the platform come before (inclusive)\n          in order to be able to build the model. Only available when the Check parameter is\n          set to Range of versions.\n        \n      \n                Calibratable: no.\n              To versionParamText\n        \n          The literal text of the version\n          number (e.g., 1.5.0) that the platform come after (inclusive)\n          in order to be able to build the model. Only available when the Check parameter is\n          set to Range of versions.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PUT.REQPLAT.101": "The block put_RequirePlatformVersion shall support the targets:\n            All targets.",
    "LLR.PLAT.PUT.REQPLAT.201": "The block put_RequirePlatformVersion shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PUT.REQPLAT.002": "The block  shall  look at the Check field,\n                a drop-down of methods for restricting the version of blockset\n                to use when building, and perform the necessary checks on the\n                following items.",
    "LLR.PLAT.PUT.REQPLAT.003": "When Check\n                is Single version the block  shall  look at\n                the Version field,\n                and verify that the that the blockset can build that model and raise\n                an error if it can not.",
    "LLR.PLAT.PUT.REQPLAT.004": "When Check is Before version\n                the block  shall  look at the Before version field,\n                and verify that the blockset comes before the version given (not inclusive)\n                in order to be able to build that model and raise an error if it does not.",
    "LLR.PLAT.PUT.REQPLAT.005": "When Check is After version\n                the block  shall  look at the After version field,\n                and verify that the blockset comes after the version given (not inclusive)\n                in order to be able to build that model and raise an error if it does not.",
    "LLR.PLAT.PUT.REQPLAT.006": "When Check is Range of versions\n                the block  shall  look at the From version field and\n                verify that the blockset came after (inclusive) in order to be able to build that model and raise an error\n                if it does not.",
    "LLR.PLAT.PUT.REQPLAT.007": "When Check is Range of versions\n                the block  shall  look at the To version field and\n                verify that the blockset came before (inclusive) in order to be able to build that model and raise an\n                error if it does not.",
    "LLR.PLAT.PUT.IDENT.001": "The platform shall provide a Simulink interface block named\n                put_Identification that has\n                the following inports, outports and mask parameters.\n              ParameterDirectionTypeDescriptionECU typeParamList\n        \n          Specifies the name of the ECU\n          that the model will run on. Selection of the ECU type changes the\n          possible inputs and outputs on other blocks. The parameter should be selected at\n          the start of the model but if it must be changed later (for instance, moving to\n          another hardware platform to reduce costs) then consult the Notes\n          section for the put_Identification\n          block for more details.\n        \n      \n                Calibratable: no.\n              Part NumberParamList\n        \n          Specifies the hardware part number that appears on the ECU casing, followed by\n          a hyphen and a three-character suffix. This suffix denotes the option. Only those\n          options that require special software support are explicitly listed. If the option\n          is not explicitly listed, then option 000 should be selected.\n        \n      \n                Calibratable: no.\n              Issue NumberParamInteger\n        \n          Specifies the issue or revision number of the ECU that the model will run on.\n          This is the first number that appears after the hardware part number on the\n          label of the ECU. For example, if \"2m4\" appears after the hardware part number,\n          then the issue number to be entered is 2.\n        \n      \n                Calibratable: no.\n              Pin namingParamList\n        \n          Specifies the type of names\n          used for pin and channel identification. Generic pin naming\n          uses the following terms for each pin.\n        \n        Table\u00a03.73.\u00a0Generic pin naming conventionNameDescriptionAINAnalogue inputAOTAnalogue outputDINDigital inputDOTDigital outputMonitorFeedback signal from output driver circuitry\n        Powertrain pin naming uses a scheme that shortens the typical\n        application naming given in the target specification tables linked to in ???.\n        The default selection for this drop-down is Powertrain pin naming to\n        maintain backwards compatibility with existing models.\n        \n      \n                Calibratable: no.\n              NameParamString\n        \n          Specifies the name of the model\/application. The name has no functional effect on the\n          model but is used when generating ASAP2 files and in response to the CCP EXCHANGE-ID\n          message.\n        \n        \n          The name can include tokens which are automatically converted during model build. Tokens\n          are single words starting and ending in the \u201c%\u201d\n          character. For instance, the string \u201cApplication for\n          %target%\u201d contains one token named target,\n          which is converted to the target ECU name during a model build. The following table\n          lists the available tokens:\n        \n        TokenReplacement%copyright%Replaced with the string from the Copyright parameter.%target%Replaced with a string representing the ECU target and option.%ver-major%Replaced with the string from the Major version number parameter.%ver-minor%Replaced with the string from the Minor version number parameter.%ver-subminor%Replaced with the string from the Sub-minor version number parameter.\n      \n                Calibratable: no.\n              DescriptionParamString\n        \n          Specifies a description of\n          the model. The description is displayed in the block. The description has no\n          functional effect on the model.\n        \n      \n                Calibratable: no.\n              Major version numberParamInteger\n        \n          Specifies the major\n          version number of the model. This has no functional effect on the model. The\n          version can be read from the target at run time by displaying the\n          mpl_app_ver_major\n          automatic ASAP2 entry.\n        \n        \n          Range: [0, 65535]\n        \n      \n                Calibratable: no.\n              Minor version numberParamInteger\n        \n          Specifies the major\n          version number of the model. This has no functional effect on the model. The\n          version can be read from the target at run time by displaying the\n          mpl_app_ver_minor\n          automatic ASAP2 entry.\n        \n        \n          Range: [0, 65535]\n        \n      \n                Calibratable: no.\n              Sub-minor version numberParamInteger\n        \n          Specifies the major\n          version number of the model. This has no functional effect on the model. The\n          version can be read from the target at run time by displaying the\n          mpl_app_ver_subminor\n          automatic ASAP2 entry.\n        \n        \n          Range: [0, 65535]\n        \n      \n                Calibratable: no.\n              CopyrightParamString\n        \n          Specifies a copyright text\n          that is embedded in the built model image and calibration.\n        \n      \n                Calibratable: no.",
    "LLR.PLAT.PUT.IDENT.101": "The block put_Identification shall support the targets:\n            All targets.",
    "LLR.PLAT.PUT.IDENT.201": "The block put_Identification shall be in the license group:\n            None (Main library).",
    "LLR.PLAT.PUT.IDENT.002": "If the Matlab version is not supported then the block  shall  raise an error.",
    "LLR.PLAT.PUT.IDENT.003": "If more than one put_Identification block is detected in the model then the block  shall  raise an error.",
    "LLR.PLAT.PUT.IDENT.004": "If the parameter Major version number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.IDENT.005": "If the parameter Minor version number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.IDENT.006": "If the parameter Sub-minor version number is out of range,\n                then the block  shall  raise an error.",
    "LLR.PLAT.PUT.IDENT.007": "The blocks in the model that have pin access  shall  list only the pins available for that particular target.",
    "LLR.PLAT.PUT.IDENT.008": "The block  shall  make the following mask parameters available via a calibration tool:\n              \n                ECU typePart NumberDescriptionMajor version numberMinor version numberSub-minor version numberCopyright",
    "LLR.PLAT.PUT.STATE.001": "The platform shall provide a C interface function named\n                put_state_processing() with the\n                following parameters:\n              ParameterDirectionTypeDescriptionputf_inp_state\n          in\n        U8\nThe input state. \n Range: 0 or 1, unitlessputf_invert\n          in\n        U8\nIf inversion is set the input state is converted as follows: \n output_state = 1 - input_state \n Range: 0 or 1, unitlessputf_fault\n          in\n        U8\nIf true the function forces the output value to be equal to putf_default, no effect otherwise. \n Range: 0 or 1, unitlessputf_default\n          in\n        U8\nUsed to set the output value when putf_fault is true, no effect otherwise. \n Range: [0, 1] unitlessputf_out_state\n          out\n        U8 *\nPointer to the value that will represent the output state. \n Cannot be NULL. \n Range: [0, 1] unitless\n                The function returns void.",
    "LLR.PLAT.PUT.STATE.101": "The function put_state_processing() shall support the targets:\n                      All targets.",
    "LLR.PLAT.PUT.STATE.201": "The function put_state_processing() shall be in the license group:\n                      None (Main library).",
    "LLR.PLAT.PUT.STATE.002": "If putf_out_state is NULL, the function  shall  raise recoverable error\n              PSY_PUT\/PUT_STATE_PROCESSING_INVALID_ARG.",
    "LLR.PLAT.PUT.STATE.003": "If putf_fault is true then putf_out_state  shall  be set to\n              putf_default.",
    "LLR.PLAT.PUT.STATE.004": "If putf_fault is false the following applies:\n              If inverse is true then putf_out_state  shall  be set to the inverse\n              of putf_inp_state otherwise it  will  be set to putf_inp_state.",
    "LLR.PLAT.PXS.INT.001": "The platform  shall  provide a 100 ms periodic task to execute the periodic behaviour\n                of the device.\n              Note: \n                The mc06xs4200 has a ~300[?]ms watchdog timeout.  As long as this task is faster\n                than that, then the requirement will be satisfied.",
    "LLR.PLAT.PXS.INT.002": "The platform  shall  initialise a SPI configuration queue to set the following\n                parameter settings:\n              ParameterValuePWM_en_[1..0]0PARALLEL0T_H_en0WD_dis0VDD_FAIL_en1CSNS[1..0]_en0OV_dis0OS_dis_00OLON_dis_00OLOFF_dis_00DIR_dis_00SR[1..0]_00DELAY_0[2..0]0HOCR_01PR_00Clock_int_01CSNS_ratio_00tOCH_01tOCM_01OCH_01OCM_00OCL_00OFP_01Auto_period[1..0]_00Retry_unlimited_00retry_00OS_dis_10OLON_dis_10OLOFF_dis_10DIR_dis_10SR[1..0]_10DELAY_1[2..0]0HOCR_11PR_10Clock_int_11CSNS_ratio_10tOCH_11tOCM_11OCH_11OCM_10OCL_10OFP_11Auto_period[1..0]_10Retry_unlimited_10retry_10",
    "LLR.PLAT.PXS.INT.006": "The platform  shall  initialise a SPI configuration queue to read back the settings\n                specified above.\n              Note: \n                This will be used to validate the PSI communication.",
    "LLR.PLAT.PXS.INT.003": "If the enable pin is set to the inactive state the platform  shall  disable the SPI\n                configuration queue.\n              Note: \n                If the enable in to the ECU has not be asserted, then the extreme switch is treated\n                like it is turned off and the device should not be configured.",
    "LLR.PLAT.PXS.INT.004": "If the enable pin is set to the inactive state the platform  shall  disable the SPI\n                configuration queue.\n              Note: \n                If the enable input is set to the inactive state, then the extreme switch is\n                treated like it is turned off and the device should not be configured.",
    "LLR.PLAT.PXS.INT.005": "If the enable pin is asserted the platform  shall  enable the SPI configuration queue.",
    "LLR.PLAT.PXS.INT.008": "When the enable pin transitions from the inactive to active state, the platform\n                 shall  execute the periodic behaviour in initialisation mode.",
    "LLR.PLAT.PXS.INT.007": "The feature should provide 3 virtual analogue inputs which reads the value form a\n                buffered memory location.",
    "LLR.PLAT.PXS.INIT.001": "The periodic function  shall  reconfigure and transmit the SPI queue to the settings in\n              the above table.",
    "LLR.PLAT.PXS.INIT.002": "After writing the values to the mc06xs4200, the function  shall  store the written\n              values in memory.",
    "LLR.PLAT.PXS.INIT.003": "When running in initialisation mode, the  periodic function  shall  reconfigure the\n              current mux select to the last value and the state machine is set to read the next\n              input channel.",
    "LLR.PLAT.PXS.RUN.001": "When running in periodic mode, prior to writing the new configuration values to the\n              mx06xs4200, the function  shall  read back the previous values written.",
    "LLR.PLAT.PXS.RUN.002": "The function  shall  compare the values read back from the mx06xs4200 to the\n              corresponding values saved in memory.  If any do not match, then the function shall\n              increment the SPI fault counter for that mx06xs4200 device.",
    "LLR.PLAT.PXS.CSNS.001": "If the state machine is set to read-next-channel mode, then the function should\n                increment the channel value (mod 3) and change the state to wait-for-sync mode.",
    "LLR.PLAT.PXS.CSNS.002": "If the state machine is set in wait-for-sync mode, then the function wait up to two\n                task loops for the SYNC pin to be asserted before changing back to read-next-channel\n                mode.",
    "LLR.PLAT.PXS.CSNS.003": "If the state machine is set in wait-for-sync mode, and the SYNC pin is asserted or\n                if the requested channel is the temperature sense,  The function  shall  sample the\n                current sense input and store the read value in the corresponding buffered memory\n                location.",
    "LLR.PLAT.PXS.CSNS.004": "For the currently desired channel, the function  shall  write the corresponding\n                CSNS[1..0]_en value to set the CSNS pin to report that channel according to the\n                mapping:\n              Desired channelCSNS[1..0]_en valueCurrent Monitor Channel 00b01Current Monitor Channel 10b10Temperature Monitor0b11",
    "LLR.PLAT.PXS.DIAG.001": "The platform  shall  provide 20 digital input channels per mc06xs4200 device supported corresponding to:\n            overvoltage fault                   undervoltage fault                  power-on reset                      overtemp warning                    output pin state (Chan 0)           open load on fault (Chan 0)         open load off fault (Chan 0)        short to batt fault (Chan 0)        overtemperture fault (Chan 0)       severe short circuit fault (Chan 0) overcurrent fault (Chan 0)          input pin state (Chan 0)            output pin state (Chan 1)           open load on fault (Chan 1)         open load off fault (Chan 1)        short to batt fault (Chan 1)        overtemperture fault (Chan 1)       severe short circuit fault (Chan 1) overcurrent fault (Chan 1)          input pin state (Chan 1)",
    "LLR.PLAT.PXS.DIAG.002": "When the application reads one of the digital input channels, the feature  shall :\n            Retrieve the value of the diagnostic input from the corresponding location in the internal buffer.Clear the corresponding location in the internal buffer.Trigger the corresponding SPI channel at the calling task rate.Return the read value to the application.",
    "LLR.PLAT.PXS.DIAG.003": "The feature  shall  attach a callback function to the corresponding mc06xs4200 diagnostics\n              SPI queue such that when for each asserted flag in the queue it will assert the flag in the input buffer.\n            Note: \n              Note that nothing is done if the flag is set to the inactive state.  the error\n              persists until it is read by the application.",
    "LLR.PLAT.DOC.LIST.001": "For C-API, the following documents  shall  be provided:\n              User guides, Technical Specification for each supported ECU,\n              Release Note.",
    "LLR.PLAT.DOC.LIST.002": "For Sim-API, the following documents  shall  be provided: User\n              guides, Technical Specification for each support ECU,\n              Release Note.",
    "LLR.PLAT.DOC.FORMAT.001": "All documents  shall  be provided in PDF form.",
    "LLR.PLAT.DOC.FORMAT.002": "Both user guides   shall  be provided in HTML single file form.",
    "LLR.PLAT.DOC.FORMAT.003": "Sim-API User guides   shall  be provided in HTML chunked files form.\n            Rationale: \n              Simulink contextual help can link a block to a page in the\n              help files.",
    "LLR.PLAT.DOC.LOOK.001": "All documents  shall  have the following on page 1:\n              Pi Innovo logoDocument namePlatform Version numberPi Innovo nameOpenECU logo\n            Note: \n              Layout is not defined yet, Craig and Alistair working\n              on it.",
    "LLR.PLAT.DOC.LOOK.002": "All footers  shall  have the following:\n              Document namePlatform Version numberDocument numberDate of IssuePage number",
    "LLR.PLAT.DOC.LOOK.003": "All documents  shall  have the following (anywhere, until Craig and Alistair define a template):\n              Document numberPi Innovo website addressContact e-mail (support and commercial)\n            Note: \n              Layout is not defined yet, Craig and Alistair working\n              on it.",
    "LLR.PLAT.EXAMPLE.C.001": "A first example called step1  shall  be\n              provided for each ECU. Using this example as a support,\n              the user guide will provide a quick start explaining how\n              to build, modify, load and observe an application.  In\n              this example, we will illustrate the use of:\n              Analogue InputPWM Output\n            Rationale: \n              We need to give very detailed explanation to users so they\n              can built and run an application as soon as they have the\n              product.",
    "LLR.PLAT.EXAMPLE.C.002": "The step2 example  shall  be provided for\n              each ECU. Using this example as a support, the user guide\n              will provide details about the use of sensor and actuator\n              supplies, and basic knowledge for power hold and pcfg.\n            Rationale: \n              The logic for power hold and supplies has been known to be\n              the cause of problems for customers in their first week of\n              using OpenECU..",
    "LLR.PLAT.EXAMPLE.C.003": "All C-APIexamples  shall  be provided with a batch file\n              used to build them.\n            Rationale: \n              In the past, we have not ensured via testing that all\n              examples delivered build on a clean machine after\n              installation.",
    "LLR.PLAT.EXAMPLE.C.004": "The delivery  shall  include a minimal example illustrating\n              how to use the basic digital functionality.\n              Digital InputDigital OutputPWM InputPWM Output\n            Rationale: \n              Providing examples will help the customer discovering the\n              OpenECU platform and will reduce the required volume of\n              support.",
    "LLR.PLAT.EXAMPLE.C.005": "The delivery  shall  include an example illustrating how to\n              use the more elaborate analogue and digital functionality.\n              SPWM OuputH-Bridge outputQuadrature decode inputTLE input\n            Rationale: \n              This will allow us to explain the role of pss and pcfg.",
    "LLR.PLAT.EXAMPLE.C.006": "The delivery  shall  include an example illustrating how to\n              use power hold and non-volatile memory.",
    "LLR.PLAT.EXAMPLE.C.007": "The delivery  shall  include a example using multiple rates\n              and resources.",
    "LLR.PLAT.EXAMPLE.C.008": "The delivery  shall  include an example illustrating the\n              angular functionality.",
    "LLR.PLAT.EXAMPLE.C.009": "The delivery  shall  include an example illustrating the\n              diagnostic functionality.",
    "LLR.PLAT.EXAMPLE.C.010": "The delivery  shall  include an example illustrating the\n              J1939 functionality.",
    "LLR.GT.PROT.001": "The Host and ECU  shall  communicate on CAN at 500 kBps.",
    "LLR.GT.PROT.002": "ECU  shall  use bus 0.",
    "LLR.GT.PROT.003": "Host application  shall  allow the user to select the CAN\n              channel. (todo: list supported PC hardware)",
    "LLR.GT.PROT.004": "The Host  shall  implement the ISO15675 transport protocol.\n            Note: \n              For the EOL application, there will be no segmented\n              packet. We expect to have to release the EOL specification\n              to external manufacturer so we need to keep it simple.",
    "LLR.GT.PROT.005": "The following table defines how the messages are formed\n              per test area.\n            If interpreting unprocessed CAN frame \/ single frame (all EOL commands):\n            Byte0  Byte1  Byte2  Byte3  Byte4  Byte5  Byte6  Byte7  \n            N_PCI  SID    MODE   RID    <     data     ....      >If interpreting ISO frames:\n            Byte0  Byte1  Byte2  Byte3  Byte4  Byte5  Byte6  Byte7  \n            SID    MODE   RID    <data                    >0: all tester  will  accept\n            1: EOL command\n            2: CAPI call\n            3: DV dur\n            4: DV fun\u00a0\u00a0\n                      Present in\n                    FunctionalityMessage startEOLDV durDV funCAPIRead IO22yyy*Write IO2Eyyy*Ping CAN busyyy*Send K-Line byteyyynReceive K-Line byteyyynWrite Production datay\u00a0\u00a0\u00a0Initialise DV Test (todo Dan)31yyyyRead Production datayyyyPrepare DV Test values31 initiate base reading \/\/ get test parameters 22 \/\/  set test parameters 2Enyyyreset\u00a0\u00a0\u00a0\u00a0API call81nnnyRoutine start31nnny",
    "LLR.GT.HOST.001": "todo",
    "LLR.GT.EMB.001": "todo",
    "LLR.GT.HOST.002": "todo",
    "LLR.GT.EMB.002": "todo",
    "LLR.GT.HOST.003": "todo",
    "LLR.GT.EMB.003": "todo",
    "LLR.GT.EOL.001": "Add a reference to xls spreadsheet.",
    "LLR.GT.DV.001": "Add a reference to xls spreadsheet.",
    "LLR.GT.EMB.004": "todo",
    "LLR.GT.EMB.005": "todo",
    "LLR.GT.EMB.006": "todo",
    "LLR.GT.EMB.007": "todo",
    "LLR.GT.EMB.008": "todo",
    "LLR.GT.EMB.009": "todo",
    "LLR.GT.EMB.010": "todo",
    "LLR.GT.EMB.011": "todo",
    "LLR.GT.TODO.001": "81",
    "LLR.GT.TODO.002": "C1 as well",
    "LLR.GT.TODO.003": "81+C1 as well",
    "LLR.GT.TODO.004": "31"
}